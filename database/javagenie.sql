-- phpMyAdmin SQL Dump
-- version 4.5.1
-- http://www.phpmyadmin.net
--
-- Host: 127.0.0.1
-- Generation Time: May 05, 2016 at 06:18 AM
-- Server version: 10.1.10-MariaDB
-- PHP Version: 5.5.33

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `javagenie`
--

-- --------------------------------------------------------

--
-- Table structure for table `cheatsheet`
--

CREATE TABLE `cheatsheet` (
  `cheatid` int(11) NOT NULL,
  `topic` text NOT NULL,
  `content` text NOT NULL,
  `code` text NOT NULL,
  `notesid` int(11) NOT NULL,
  `uid` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `cheatsheet`
--

INSERT INTO `cheatsheet` (`cheatid`, `topic`, `content`, `code`, `notesid`, `uid`) VALUES
(1, 'Loop', 'To write a while-loop, we think about three parts... test -- a boolean test of what should be true before each iteration. Or put another way, the test is the "green light" condition that says that each iteration can go ahead. (The phrase "green light" is a good mnemonic for what the test does.) Eventually, the test should become false and the loop can exit. Think about the precondition that describes the state before each iteration runs -- how are things arranged, what is true? (Also known as an', 'Heres a while loop example that uses a loop to see how man times you can divide a number by 2: // Given a num, returns how many times can we divide it by 2 to get down to 1. int count2Div(int num) {   int count = 0;   // count how many divisions weve done   while (num >= 1) {     num = num / 2;     count++;   }   return count; }', 1, 0),
(45, 'data types', 'Data Types in Java\r\n\r\nIn java, there are two types of data types\r\n1. primitive data types\r\n2. non-primitive data type', '', 20, 1),
(49, 'JVM', 'JVM (Java Virtual Machine) is an abstract machine. It is a specification that provides runtime environment in which java bytecode can be executed.\r\nJVMs are available for many hardware and software platforms. JVM, JRE and JDK are platform dependent because configuration of each OS differs. But, Java is platform independent.\r\nThe JVM performs following main tasks:\r\nLoads code\r\nVerifies code\r\nExecutes code\r\nProvides runtime environment', '', 16, 1),
(50, 'Fibonacci series', 'Input: 10\r\n\r\nOutput: 0 1 1 2 3 5 8 13 21 34', 'class FibonacciExample1{  \r\npublic static void main(String args[])  \r\n{    \r\n int n1=0,n2=1,n3,i,count=10;    \r\n System.out.print(n1+" "+n2);//printing 0 and 1    \r\n    \r\n for(i=2;i<count;++i)//loop starts from 2 because 0 and 1 are already printed    \r\n {    \r\n  n3=n1+n2;    \r\n  System.out.print(" "+n3);    \r\n  n1=n2;    \r\n  n2=n3;    \r\n }    \r\n  \r\n}}  ', 22, 1),
(51, 'java operators', 'Operator in java is a symbol that is used to perform operations. There are many types of operators in java such as unary operator, arithmetic operator, relational operator, shift operator, bitwise operator, ternary operator and assignment operator.\r\n\r\nOperator,Precedence\r\npostfix, expr++ expr--\r\nunary, ++expr --expr +expr -expr ~ !\r\nmultiplicative,	* / %\r\nadditive,	+ -\r\nshift,	<< >> >>>\r\nrelational,	< > <= >= instanceof\r\nequality,	== !=\r\nbitwise AND,	&\r\nbitwise exclusive OR,	^\r\nbitwise inclusive OR,	|\r\nlogical AND,	&&\r\nlogical OR,	||\r\nternary	? :,\r\nassignment,	= += -= *= /= %= &= ^= |= <<= >>= >>>=', '', 21, 1),
(93, 'Protected access modifier', 'The protected access modifier is accessible within package and outside the package but through inheritance only.\r\n\r\nThe protected access modifier can be applied on the data member, method and constructor. It cant be applied on the class.', '//save by A.java  \r\npackage pack;  \r\npublic class A{  \r\nprotected void msg(){System.out.println("Hello");}  \r\n}  \r\n//save by B.java  \r\npackage mypack;  \r\nimport pack.*;  \r\n  \r\nclass B extends A{  \r\n  public static void main(String args[]){  \r\n   B obj = new B();  \r\n   obj.msg();  \r\n  }  \r\n}  ', 64, 2),
(95, 'Java Package', 'A java package is a group of similar types of classes, interfaces and sub-packages.\r\n\r\nPackage in java can be categorized in two form, built-in package and user-defined package.\r\n\r\nThere are many built-in packages such as java, lang, awt, javax, swing, net, io, util, sql etc.\r\n\r\nHere, we will have the detailed learning of creating and using user-defined packages.\r\n\r\nAdvantage of Java Package\r\n\r\n1) Java package is used to categorize the classes and interfaces so that they can be easily maintained.\r\n\r\n2) Java package provides access protection.\r\n\r\n3) Java package removes naming collision.', '//save as Simple.java  \r\npackage mypack;  \r\npublic class Simple{  \r\n public static void main(String args[]){  \r\n    System.out.println("Welcome to package");  \r\n   }  \r\n}  ', 60, 2),
(96, 'Using packagename.*', 'If you use package.* then all the classes and interfaces of this package will be accessible but not subpackages.\r\n\r\nThe import keyword is used to make the classes and interface of another package accessible to the current package.', '//save by A.java  \r\npackage pack;  \r\npublic class A{  \r\n  public void msg(){System.out.println("Hello");}  \r\n}  \r\n//save by B.java  \r\npackage mypack;  \r\nimport pack.*;  \r\n  \r\nclass B{  \r\n  public static void main(String args[]){  \r\n   A obj = new A();  \r\n   obj.msg();  \r\n  }  \r\n}  ', 61, 2),
(97, 'Access Modifiers in java\r\n', 'There are two types of modifiers in java: access modifiers and non-access modifiers.\r\n\r\nThe access modifiers in java specifies accessibility (scope) of a data member, method, constructor or class.\r\n\r\nThere are 4 types of java access modifiers:\r\n\r\nprivate\r\ndefault\r\nprotected\r\npublic\r\n\r\n1) private access modifier\r\n\r\nThe private access modifier is accessible only within class.\r\n\r\n\r\n\r\n\r\n', 'Example of private access modifier:\r\nclass A{  \r\nprivate int data=40;  \r\nprivate void msg(){System.out.println("Hello java");}  \r\n}  \r\n  \r\npublic class Simple{  \r\n public static void main(String args[]){  \r\n   A obj=new A();  \r\n   System.out.println(obj.data);//Compile Time Error  \r\n   obj.msg();//Compile Time Error  \r\n   }  \r\n}  ', 62, 2),
(98, 'Default access modifier', '\r\nIf you dont use any modifier, it is treated as default bydefault. The default modifier is accessible only within package.', '//save by A.java  \r\npackage pack;  \r\nclass A{  \r\n  void msg(){System.out.println("Hello");}  \r\n}  \r\n//save by B.java  \r\npackage mypack;  \r\nimport pack.*;  \r\nclass B{  \r\n  public static void main(String args[]){  \r\n   A obj = new A();//Compile Time Error  \r\n   obj.msg();//Compile Time Error  \r\n  }  \r\n} ', 63, 2),
(99, 'Object class in Java', 'The Object class is the parent class of all the classes in java bydefault. In other words, it is the topmost class of java.\r\n\r\nThe Object class is beneficial if you want to refer any object whose type you dont know. Notice that parent class reference variable can refer the child class object, know as upcasting.\r\n\r\nLets take an example, there is getObject() method that returns an object but it can be of any type like Employee,Student etc, we can use Object class reference to refer that object. For example:\r\n\r\nObject obj=getObject();//we dont what object would be returned from this method  \r\nThe Object class provides some common behaviours to all the objects such as object can be compared, object can be cloned, object can be notified etc.', '1. public final ClassgetClass()	\r\n\r\nreturns the Class class object of this object. The Class class can further be used to get the metadata of this class.\r\n\r\n2. public int hashCode()	\r\nreturns the hashcode number for this object.\r\n\r\n3. public boolean equals(Object obj)	compares the given object to this object.\r\n\r\n4. protected Object clone() throws CloneNotSupportedException	\r\ncreates and returns the exact copy (clone) of this object.\r\n\r\n5. public String toString()	\r\nreturns the string representation of this object.\r\n\r\n6. public final void notify()	\r\nwakes up single thread, waiting on this objects monitor.\r\n\r\n7. public final void notifyAll()	wakes up all the threads, waiting on this objects monitor.\r\n\r\n8. public final void wait(long timeout)throws InterruptedException	causes the current thread to wait for the specified milliseconds, until another thread notifies (invokes notify() or notifyAll() method).', 67, 2),
(100, 'public access modifier', 'The public access modifier is accessible everywhere. It has the widest scope among all other modifiers.', '//save by A.java  \r\n  \r\npackage pack;  \r\npublic class A{  \r\npublic void msg(){System.out.println("Hello");}  \r\n}  \r\n//save by B.java  \r\n  \r\npackage mypack;  \r\nimport pack.*;  \r\n  \r\nclass B{  \r\n  public static void main(String args[]){  \r\n   A obj = new A();  \r\n   obj.msg();  \r\n  }  ', 65, 2),
(112, 'implicit typecasting', 'In general an implicit cast is done when an Object reference is assigned (cast) to:\r\n\r\n* A reference variable whose type is the same as the class from which the object was instantiated.\r\nAn Object as Object is a super class of every Class.\r\n* A reference variable whose type is a super class of the class from which the object was instantiated.\r\n* A reference variable whose type is an interface that is implemented by the class from which the object was instantiated.\r\n* A reference variable whose type is an interface that is implemented by a super class of the class from which the object was instantiated.\r\n\r\nConsider an interface Vehicle, a super class Car and its subclass Ford. The following example shows the automatic conversion of object references handled by the compiler', 'interface Vehicle {\r\n}\r\nclass Car implements Vehicle {\r\n}class Ford extends Car {\r\n', 280, 32),
(114, 'Access modifiers and inheritance', 'When you create a subclass of some class, the methods in the subclass cannot have less accessible access modifiers assigned to them than they had in the superclass. For instance, if a method in the superclass is public then it must be public in the subclass too, in case the subclass overrides the method. If a method in the superclass is protected then it must be either protected or public in the subclass.\r\n\r\nWhile it is not allowed to decrease accessibility of an overridden method, it is allowed to expand accessibility of an overridden method. For instance, if a method is assigned the default access modifier in the superclass, then it is allowed to assign the overridden method in the subclass the public access modifier.', '', 307, 32),
(116, 'encapsulation', 'The whole idea behind encapsulation is to hide the implementation details from users. If a data member is private it means it can only be accessed within the same class. No outside class can access private data member (variable) of other class. However if we setup public getter and setter methods to update (for e.g. void setSSN(int ssn))and read (for e.g.  int getSSN()) the private data fields then the outside class can access those private data fields via public methods. This way data can only be accessed by public methods thus making the private fields and their implementation hidden for outside classes. That’s why encapsulation is known as data hiding. Lets see an example to understand this concept better.', 'public class EncapsulationDemo{\r\n    private int ssn;\r\n    private String empName;\r\n    private int empAge;\r\n\r\n    //Getter and Setter methods\r\n    public int getEmpSSN(){\r\n        return ssn;\r\n    }\r\n\r\n    public String getEmpName(){\r\n        return empName;\r\n    }\r\n\r\n    public int getEmpAge(){\r\n        return empAge;\r\n    }\r\n\r\n    public void setEmpAge(int newValue){\r\n        empAge = newValue;\r\n    }\r\n\r\n    public void setEmpName(String newValue){\r\n        empName = newValue;\r\n    }\r\n\r\n    public void setEmpSSN(int newValue){\r\n        ssn = newValue;\r\n    }\r\n}\r\npublic class EncapsTest{\r\n    public static void main(String args[]){\r\n         EncapsulationDemo obj = new EncapsulationDemo();\r\n         obj.setEmpName("Mario");\r\n         obj.setEmpAge(32);\r\n         obj.setEmpSSN(112233);\r\n         System.out.println("Employee Name: " + obj.getEmpName());\r\n         System.out.println("Employee SSN: " + obj.getEmpSSN());\r\n         System.out.println("Employee Age: " + obj.getEmpAge());\r\n    } \r\n}', 286, 39),
(118, 'interface', 'Interface looks like class but it is not a class. An interface can have methods and variables just like the class but the methods declared in interface are by default abstract (only method signature, no body). Also, the variables declared in an interface are public, static & final by default. We will discuss these points in detail, later in this post.', 'interface MyInterface\r\n{\r\n   public void method1();\r\n   public void method2();\r\n}\r\nclass XYZ implements MyInterface\r\n{\r\n  public void method1()\r\n  {\r\n      System.out.println("implementation of method1");\r\n  }\r\n  public void method2()\r\n  {\r\n      System.out.println("implementation of method2");\r\n  }\r\n  public static void main(String arg[])\r\n  {\r\n      MyInterface obj = new XYZ();\r\n      obj. method1();\r\n  }\r\n}', 287, 39),
(119, 'packages', 'Packages in Java is a mechanism to encapsulate a group of classes, interfaces and sub packages.', 'package foo;', 356, 39),
(120, 'What is an interface?', 'Interface looks like class but it is not a class. An interface can have methods and variables just like the class but the methods declared in interface are by default abstract (only method signature, no body). Also, the variables declared in an interface are public, static & final by default. We will discuss these points in detail, later in this post.', 'interface MyInterface\r\n{\r\n   /* All the methods are public abstract by default\r\n    * Note down that these methods are not having body\r\n    */\r\n   public void method1();\r\n   public void method2();\r\n}', 310, 30),
(121, 'Nested interfaces', 'An interface which is declared inside another interface or class is called nested interface. They are also known as inner interface. For example Entry interface in collections framework is declared inside Map interface, that’s why we don’ use it directly, rather we use it like this: Map.Entry. Read more about nested interface along with examples at the link: Nested Interface with examples.\r\n\r\nKey points: Here are the key points to remember about interfaces:\r\n1) We can’t instantiate an interface in java.\r\n\r\n2) Interface provides complete abstraction as none of its methods can have body. On the other hand, abstract class provides partial abstraction as it can have abstract and concrete(methods with body) methods both.\r\n\r\n3) implements keyword is used by classes to implement an interface.\r\n\r\n4) While providing implementation in class of any method of an interface, it needs to be mentioned as public.\r\n\r\n5) Class implementing any interface must implement all the methods, otherwise the class should be declared as “abstract”.\r\n\r\n6) Interface cannot be declared as private, protected or transient.\r\n\r\n7) All the interface methods are by default abstract and public.\r\n\r\n8) Variables declared in interface are public, static and final by default.', 'interface Try\r\n{\r\n   int a=10;\r\n   public int a=10;\r\n   public static final int a=10;\r\n   final int a=10;\r\n   static int a=0;\r\n}', 311, 30),
(122, 'blank final variable', 'Blank final variable\r\n\r\nA final variable that is not initialized at the time of declaration is known as blank final variable. We must initialize the blank final variable in constructor of the class otherwise it will throw a compilation error ', 'class Demo{  \r\n   //Blank final variable\r\n   final int MAX_VALUE;\r\n	 \r\n   Demo(){\r\n      //It must be initialized in constructor\r\n      MAX_VALUE=100;\r\n   }\r\n}', 207, 30),
(123, 'method overriding', 'Declaring a method in subclass which is already present in parent class is known as method overriding. Earlier we shared method overloading in java. In this tutorial we will see method overriding with examples.\r\n\r\nExample:\r\n\r\nOne of the simplest example – Here Boy class extends Human class. Both the classes have a common method void eat(). Boy class is giving its own implementation to the eat() method or in other words it is overriding the method eat()', 'class Human{\r\n   public void eat()\r\n   {\r\n      System.out.println("Human is eating");\r\n   }\r\n}\r\nclass Boy extends Human{\r\n   public void eat(){\r\n      System.out.println("Boy is eating");\r\n   }\r\n   public static void main( String args[]) {\r\n      Boy obj = new Boy();\r\n      obj.eat();\r\n   }\r\n}', 277, 40),
(124, 'private constructor', 'The use of private constructor is to serve singleton classes. A singleton class is one which limits the number of objects creation to one. Using private constructor we can ensure that no more than one object can be created at a time. We will see in the below example how to use private constructor for limiting the number of objects for a singleton class.', 'package beginnersbook.com;\r\npublic class SingleTonClass {\r\n   //Static Class Reference\r\n   private static SingleTonClass obj=null;\r\n   private SingleTonClass(){\r\n      /*Private Constructor will prevent \r\n       * the instantiation of this class directly*/\r\n   }\r\n   public static SingleTonClass objectCreationMethod(){\r\n	/*This logic will ensure that no more than\r\n	 * one object can be created at a time */\r\n	if(obj==null){\r\n	    obj= new SingleTonClass();\r\n	}\r\n        return obj;\r\n   }\r\n   public void display(){\r\n	System.out.println("Singleton class Example");\r\n   }\r\n   public static void main(String args[]){\r\n	//Object cannot be created directly due to private constructor \r\n        //This way it is forced to create object via our method where\r\n        //we have logic for only one object creation\r\n	SingleTonClass myobject= SingleTonClass.objectCreationMethod();\r\n	myobject.display();\r\n   }\r\n}', 271, 40),
(125, 'What is polymorphism', 'Polymorphism is the capability of a method to do different things based on the object that it is acting upon. In other words, polymorphism allows you define one interface and have multiple implementations. I know it sounds confusing. Don’t worry we will discuss this in detail.\r\n\r\nIt is a  feature that allows one interface to be used for a general class of  actions.\r\nAn operation may exhibit different behavior in different instances.\r\nThe behavior depends on the types of data used in the operation.\r\nIt plays an important role in allowing objects having different internal structures to share the same external interface.\r\nPolymorphism is extensively used in implementing inheritance.\r\nFollowing concepts demonstrate different types of polymorphism in java.\r\n1) Method Overloading\r\n2) Method Overriding', '', 273, 40),
(128, 'constructor in interface', 'This is a most frequently asked java interview question. The answer is No, interface cannot have constructors. In this post we will discuss why constructors are not allowed in interface?\r\n\r\nAs we know that all the methods in interface are public abstract by default which means the method implementation cannot be provided in the interface itself. It has to be provided by the implementing class. Consider the below piece of code:', 'public interface SumInterface{\r\n\r\n    public int mymethod(int num1, int num2);\r\n}\r\npublic class SumClass implements SumInterface{\r\n\r\n    public int mymethod(int num1, int num2){\r\n           int op= num1+num2;\r\n           return op;\r\n    }\r\n    public static void main(Sring args[])\r\n    {\r\n           SumClass obj= new SumClass();\r\n           System.out.println(obj.mymethod(2, 3));\r\n}', 272, 45),
(129, 'method overriding', 'Child class has the same method as of base class. In such cases child class overrides the parent class method without even touching the source code of the base class. This feature is known as method overriding.', 'ublic class BaseClass\r\n{\r\n    public void methodToOverride() //Base class method\r\n    {\r\n         System.out.println ("Im the method of BaseClass");\r\n    }\r\n}\r\npublic class DerivedClass extends BaseClass\r\n{\r\n    public void methodToOverride() //Derived Class method\r\n    {\r\n         System.out.println ("Im the method of DerivedClass");\r\n    }\r\n}\r\n\r\npublic class TestMethod\r\n{\r\n     public static void main (String args []) {\r\n        // BaseClass reference and object\r\n        BaseClass obj1 = new BaseClass(); \r\n        // BaseClass reference but DerivedClass object\r\n        BaseClass obj2 = new DerivedClass(); \r\n        // Calls the method from BaseClass class\r\n        obj1.methodToOverride(); \r\n        //Calls the method from DerivedClass class\r\n        obj2.methodToOverride(); \r\n     }\r\n}', 275, 45),
(130, 'Parameterized Constructor', 'Parameterized constructor: Constructor with argument list is known as parameterized constructor.', 'class Demo {       public Demo(int num, String str)       {            System.out.println("This is a parameterized constructor");       } }', 5, 0),
(131, 'Static constructor', 'Have you heard of static constructor in Java? I guess yes but the fact is that they are not allowed in Java. A constructor can not be static in Java.  Before I explain the reason letâ€™s have a look at the below piece of code:', 'public class StaticTest {      /* See below - I have marked the constructor as static */      public static StaticTest()      {          System.out.println("Static Constructor of the class");      }      public static void main(String args[])      {          /*Below: Im trying to create an object of the class          which would intern call the constructor*/          StaticTest obj = new StaticTest();      } }', 8, 0),
(132, 'Adding and accessing elements in queue', 'To add elements to a Queue you call its add() method. This method is inherited from the Collection interface. Here are a few examples:\r\n\r\nQueue queueA = new LinkedList();\r\n\r\nqueueA.add("element 1");\r\nqueueA.add("element 2");\r\nqueueA.add("element 3");\r\nThe order in which the elements added to the Queue are stored internally, depends on the implementation. The same is true for the order in which elements are retrieved from the queue. You should consult the JavaDocs for more information about the specific Queue implementations.\r\n\r\nYou can peek at the element at the head of the queue without taking the element out of the queue. This is done via the element() method. Here is how that looks:\r\n\r\nObject firstElement = queueA.element();', 'Queue queueA = new LinkedList();\r\n\r\nqueueA.add("element 0");\r\nqueueA.add("element 1");\r\nqueueA.add("element 2");\r\n\r\n//access via Iterator\r\nIterator iterator = queueA.iterator();\r\nwhile(iterator.hasNext(){\r\n  String element = (String) iterator.next();\r\n}\r\n\r\n//access via new for-loop\r\nfor(Object object : queueA) {\r\n    String element = (String) object;\r\n}', 349, 100),
(133, 'super keyword', 'When invoking a superclass version of an overridden method the super keyword is used.', 'class Vehicle {\r\n    public void move () {\r\n         System.out.println ("Vehicles are used for moving from one place to another ");\r\n    }\r\n}\r\n\r\nclass Car extends Vehicle {\r\n    public void move () {\r\n      super. move (); // invokes the super class method\r\n      System.out.println ("Car is a good medium of transport ");\r\n    }\r\n}\r\n\r\npublic class TestCar {\r\n    public static void main (String args []){\r\n        Vehicle b = new Car (); // Vehicle reference but Car object\r\n        b.move (); //Calls the method in Car class\r\n    }\r\n}', 290, 100),
(134, 'Method overloading and overriding', 'The difference between overriding and overloading in Java is a common source of confusion – but it is fairly easy to understand with the examples we present below. Let’s start the discussion by talking more about method overloading first. Method overloading in Java occurs when two or more methods in the same class have the exact same name but different parameters (remember that method parameters accept values passed into the method). Now, two or more methods with the same name in the same class sounds simple enough to understand. But, what do we mean exactly by different parameters? Well, let’s consider a very simple example.\r\n\r\nSuppose we have a class called TestClass which has two methods, and both methods have the same name. Let’s say that name is “someMethod”. Those two methods would be considered to be “overloaded” if if one or both of these conditions is true:', '//compiler error - cant overload based on the   \r\n//type returned -\r\n//(one method returns int, the other returns a float):    \r\n\r\nint changeDate(int Year) ;  \r\nfloat changeDate (int Year);    \r\n\r\n//compiler error - cant overload by changing just \r\n//the name of the parameter (from Year to Month):    \r\n\r\nint changeDate(int Year);   \r\nint changeDate(int Month) ;  \r\n \r\n//valid case of overloading, since the methods\r\n//have different number of parameters:        \r\n\r\nint changeDate(int Year, int Month) ;  \r\nint changeDate(int Year);    \r\n\r\n//also a valid case of overloading, since the   \r\n//parameters are of different types:    \r\n\r\nint changeDate(float Year) ;  \r\nint changeDate(int Year);  \r\n', 352, 100),
(135, 'HashMap', 'HashMap is a Map based collection class that is used for storing Key & value pairs. This class makes no guarantees as to the order of the map. It is similar to the Hashtable class except that it is unsynchronized and permits nulls(null values and null key)', '  /* This is how to declare HashMap */\r\n      HashMap<Integer, String> hmap = new HashMap<Integer, String>();\r\n\r\n      /*Adding elements to HashMap*/\r\n      hmap.put(12, "Chaitanya");\r\n      hmap.put(2, "Rahul");\r\n      hmap.put(7, "Singh");\r\n      hmap.put(49, "Ajeet");\r\n      hmap.put(3, "Anuj");\r\n\r\n      /* Display content using Iterator*/\r\n      Set set = hmap.entrySet();\r\n      Iterator iterator = set.iterator();\r\n      while(iterator.hasNext()) {\r\n         Map.Entry mentry = (Map.Entry)iterator.next();\r\n         System.out.print("key is: "+ mentry.getKey() + " & Value is: ");\r\n         System.out.println(mentry.getValue());\r\n      }\r\n\r\n      /* Get values based on key*/\r\n      String var= hmap.get(2);\r\n      System.out.println("Value at index 2 is: "+var);\r\n\r\n      /* Remove values based on key*/\r\n      hmap.remove(3);\r\n      System.out.println("Map key and values after removal:");\r\n      Set set2 = hmap.entrySet();\r\n      Iterator iterator2 = set2.iterator();\r\n      while(iterator2.hasNext()) {\r\n          Map.Entry mentry2 = (Map.Entry)iterator2.next();\r\n          System.out.print("Key is: "+mentry2.getKey() + " & Value is: ");\r\n          System.out.println(mentry2.getValue());\r\n       }', 220, 82),
(136, 'Synchronized block in java', 'Synchronized block can be used to perform synchronization on any specific resource of the method.\r\n\r\nSuppose you have 50 lines of code in your method, but you want to synchronize only 5 lines, you can use synchronized block.\r\n\r\nIf you put all the codes of the method in the synchronized block, it will work same as the synchronized method.\r\n\r\nPoints to remember for Synchronized block\r\n\r\nSynchronized block is used to lock an object for any shared resource.\r\nScope of synchronized block is smaller than the method.', 'class Table{  \r\n  \r\n void printTable(int n){  \r\n   synchronized(this){//synchronized block  \r\n     for(int i=1;i<=5;i++){  \r\n      System.out.println(n*i);  \r\n      try{  \r\n       Thread.sleep(400);  \r\n      }catch(Exception e){System.out.println(e);}  \r\n     }  \r\n   }  \r\n }//end of the method  \r\n}  \r\n  \r\nclass MyThread1 extends Thread{  \r\nTable t;  \r\nMyThread1(Table t){  \r\nthis.t=t;  \r\n}  \r\npublic void run(){  \r\nt.printTable(5);  \r\n}  \r\n  \r\n}  \r\nclass MyThread2 extends Thread{  \r\nTable t;  \r\nMyThread2(Table t){  \r\nthis.t=t;  \r\n}  \r\npublic void run(){  \r\nt.printTable(100);  \r\n}  \r\n}  \r\n  \r\npublic class TestSynchronizedBlock1{  \r\npublic static void main(String args[]){  \r\nTable obj = new Table();//only one object  \r\nMyThread1 t1=new MyThread1(obj);  \r\nMyThread2 t2=new MyThread2(obj);  \r\nt1.start();  \r\nt2.start();  \r\n}  \r\n}', 261, 82),
(137, 'Static synchronization', 'If you make any static method as synchronized, the lock will be on the class not on object.', 'class Table{  \r\n  \r\n synchronized static void printTable(int n){  \r\n   for(int i=1;i<=10;i++){  \r\n     System.out.println(n*i);  \r\n     try{  \r\n       Thread.sleep(400);  \r\n     }catch(Exception e){}  \r\n   }  \r\n }  \r\n}  \r\n  \r\nclass MyThread1 extends Thread{  \r\npublic void run(){  \r\nTable.printTable(1);  \r\n}  \r\n}  \r\n  \r\nclass MyThread2 extends Thread{  \r\npublic void run(){  \r\nTable.printTable(10);  \r\n}  \r\n}  \r\n  \r\nclass MyThread3 extends Thread{  \r\npublic void run(){  \r\nTable.printTable(100);  \r\n}  \r\n}  \r\n  \r\n  \r\n  \r\n  \r\nclass MyThread4 extends Thread{  \r\npublic void run(){  \r\nTable.printTable(1000);  \r\n}  \r\n}  \r\n  \r\npublic class TestSynchronization4{  \r\npublic static void main(String t[]){  \r\nMyThread1 t1=new MyThread1();  \r\nMyThread2 t2=new MyThread2();  \r\nMyThread3 t3=new MyThread3();  \r\nMyThread4 t4=new MyThread4();  \r\nt1.start();  \r\nt2.start();  \r\nt3.start();  \r\nt4.start();  \r\n}  \r\n}  ', 262, 82),
(138, 'FileInputStream and FileOutputStream (File Handling)', 'Java FileOutputStream class\r\n\r\nJava FileOutputStream is an output stream for writing data to a file.\r\n\r\nIf you have to write primitive values then use FileOutputStream.Instead, for character-oriented data, prefer FileWriter.But you can write byte-oriented as well as character-oriented data.', 'import java.io.*;  \r\nclass Test{  \r\n  public static void main(String args[]){  \r\n   try{  \r\n     FileOutputstream fout=new FileOutputStream("abc.txt");  \r\n     String s="Sachin Tendulkar is my favourite player";  \r\n     byte b[]=s.getBytes();//converting string into byte array  \r\n     fout.write(b);  \r\n     fout.close();  \r\n     System.out.println("success...");  \r\n    }catch(Exception e){system.out.println(e);}  \r\n  }  \r\n}  ', 263, 82),
(139, 'If I don’t define the constructor within the class, will compiler declare one for me every time?', 'Answer is: No ', 'class Example3\r\n{\r\n      private int var;\r\n      public Example3(int num)\r\n      {\r\n             var=num;\r\n      }\r\n      public int getValue()\r\n      {\r\n              return var;\r\n      }\r\n      public static void main(String args[])\r\n      {\r\n              Example3 myobj = new Example3();\r\n              System.out.println("value of var is: "+myobj.getValue());\r\n      }\r\n}', 268, 45),
(140, 'constructor overloading', 'Like methods, constructors can also be overloaded. We will see constructor overloading with the help of an example using this() and parameterized constructor. Before we got through the source code and examples lets discuss why we need to overload a constructor:\r\n\r\nConstructor overloading is way of having more than one constructor which does different-2 tasks. For e.g. Vector class has 4 types of constructors. If you do not want to specify the initial capacity and capacity increment then you can simply use default constructor of Vector class like this Vector v = new Vector(); however if you need to specify the capacity and increment then you call the parameterized constructor with two int args like this: Vector v= new Vector(10, 5);\r\n\r\nYou must have understood the need to overloading. Lets see how to overload a constructor with the help of below example program:', 'package beginnersbook.com;\r\npublic class StudentData\r\n{\r\n   private int stuID;\r\n   private String stuName;\r\n   private int stuAge;\r\n   StudentData()\r\n   {\r\n       //Default constructor\r\n       stuID = 100;\r\n       stuName = "New Student";\r\n       stuAge = 18;\r\n   }\r\n   StudentData(int num1, String str, int num2)\r\n   {\r\n       //Parameterized constructor\r\n       stuID = num1;\r\n       stuName = str;\r\n       stuAge = num2;\r\n   }\r\n   //Getter and setter methods\r\n   public int getStuID() {\r\n       return stuID;\r\n   }\r\n   public void setStuID(int stuID) {\r\n       this.stuID = stuID;\r\n   }\r\n   public String getStuName() {\r\n       return stuName;\r\n   }\r\n   public void setStuName(String stuName) {\r\n       this.stuName = stuName;\r\n   }\r\n   public int getStuAge() {\r\n       return stuAge;\r\n   }\r\n   public void setStuAge(int stuAge) {\r\n       this.stuAge = stuAge;\r\n   }\r\n}\r\n\r\nclass TestOverloading\r\n{\r\n   public static void main(String args[])\r\n   {\r\n       //This object creation would call the default constructor\r\n       StudentData myobj = new StudentData();\r\n       System.out.println("Student Name is: "+myobj.getStuName());\r\n       System.out.println("Student Age is: "+myobj.getStuAge());\r\n       System.out.println("Student ID is: "+myobj.getStuID());\r\n\r\n       /*This object creation would call the parameterized\r\n        * constructor StudentData(int, String, int)*/\r\n       StudentData myobj2 = new StudentData(555, "Chaitanya", 25);\r\n       System.out.println("Student Name is: "+myobj2.getStuName());\r\n       System.out.println("Student Age is: "+myobj2.getStuAge());\r\n       System.out.println("Student ID is: "+myobj2.getStuID()); \r\n  }\r\n}', 270, 45),
(142, 'OBJECT SERIALIZATION', 'Java object serialization is used to persist Java objects to a file, database, network, process or any other system. Serialization flattens objects into an ordered, or serialized stream of bytes. The ordered stream of bytes can then be read at a later time, or in another environment, to recreate the original objects.\r\n\r\nJava serialization does not cannot occur for transient or static fields. Marking the field transient prevents the state from being written to the stream and from being restored during deserialization. Java provides classes to support writing objects to streams and restoring objects from streams. Only objects that support the java.io.Serializable interface or the java.io.Externalizable interface can be written to streams.\r\npublic interface Serializable\r\n\r\nThe Serializable interface has no methods or fields. (Marker Interface)\r\nOnly objects of classes that implement java.io.Serializable interface can be serialized or deserialized', 'import java.io.Serializable;\r\npublic class PersonDetails implements Serializable {\r\n\r\n	private String name;\r\n	private int age;\r\n	private String sex;\r\n	public PersonDetails(String name, int age, String sex) {\r\n		this.name = name;\r\n		this.age = age;\r\n		this.sex = sex;\r\n	}\r\n	public int getAge() {\r\n		return age;\r\n	}\r\n	public void setAge(int age) {\r\n		this.age = age;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public String getSex() {\r\n		return sex;\r\n	}\r\n	public void setSex(String sex) {\r\n		this.sex = sex;\r\n	}\r\n}', 278, 32),
(143, 'OBJECT SERIALIZATION', 'Java object serialization is used to persist Java objects to a file, database, network, process or any other system. Serialization flattens objects into an ordered, or serialized stream of bytes. The ordered stream of bytes can then be read at a later time, or in another environment, to recreate the original objects.\r\n\r\nJava serialization does not cannot occur for transient or static fields. Marking the field transient prevents the state from being written to the stream and from being restored during deserialization. Java provides classes to support writing objects to streams and restoring objects from streams. Only objects that support the java.io.Serializable interface or the java.io.Externalizable interface can be written to streams.\r\npublic interface Serializable\r\n\r\nThe Serializable interface has no methods or fields. (Marker Interface)\r\nOnly objects of classes that implement java.io.Serializable interface can be serialized or deserialized', 'import java.io.Serializable;\r\npublic class PersonDetails implements Serializable {\r\n\r\n	private String name;\r\n	private int age;\r\n	private String sex;\r\n	public PersonDetails(String name, int age, String sex) {\r\n		this.name = name;\r\n		this.age = age;\r\n		this.sex = sex;\r\n	}\r\n	public int getAge() {\r\n		return age;\r\n	}\r\n	public void setAge(int age) {\r\n		this.age = age;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public String getSex() {\r\n		return sex;\r\n	}\r\n	public void setSex(String sex) {\r\n		this.sex = sex;\r\n	}\r\n}', 278, 32),
(144, 'variables', 'hkugsdxh', 'htdeu', 368, 45),
(145, 'static binding', 'Association of method definition to the method call is known as binding. There are two types of binding: Static binding and dynamic binding. Lets discuss them one by one.\r\n\r\nStatic Binding or Early Binding\r\n\r\nThe binding which can be resolved at compile time by compiler is known as static or early binding. All the static, private and final methods have always been bonded at compile-time . Why binding of Static, final and private methods is always a static binding? You would understand it better after reading dynamic binding. Still let me explain this – Compiler knows that all such methods cannot be overridden and will always be accessed by object of local class. Hence compiler doesn’t have any difficulty to determine object of class (local class for sure). That’s the reason binding for such methods is static.', 'class Human{\r\n....\r\n}\r\nclass Boy extends Human{\r\n   public void walk(){\r\n      System.out.println("Boy walks");\r\n   }\r\n   public static void main( String args[]) {\r\n      Boy obj1 = new Boy();\r\n      obj1.walk();\r\n   }\r\n}', 284, 39);

-- --------------------------------------------------------

--
-- Table structure for table `notes`
--

CREATE TABLE `notes` (
  `notesid` int(11) NOT NULL,
  `uid` int(11) NOT NULL,
  `topic` varchar(500) NOT NULL,
  `content` text NOT NULL,
  `code` text NOT NULL,
  `likes` int(11) NOT NULL,
  `nlevel` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `notes`
--

INSERT INTO `notes` (`notesid`, `uid`, `topic`, `content`, `code`, `likes`, `nlevel`) VALUES
(1, 0, 'Loop', 'To write a while-loop, we think about three parts... test -- a boolean test of what should be true before each iteration. Or put another way, the test is the "green light" condition that says that each iteration can go ahead. (The phrase "green light" is a good mnemonic for what the test does.) Eventually, the test should become false and the loop can exit. Think about the precondition that describes the state before each iteration runs -- how are things arranged, what is true? (Also known as an', 'Here''s a while loop example that uses a loop to see how man times you can divide a number by 2: // Given a num, returns how many times can we divide it by 2 to get down to 1. int count2Div(int num) {   int count = 0;   // count how many divisions we''ve done   while (num >= 1) {     num = num / 2;     count++;   }   return count; }', 0, 0),
(2, 0, 'For loop', 'It executes a block of statements repeatedly until the specified condition returns false. or (initialization; condition; increment/decrement) {     statement(s) //block of statements } Mind the semicolon (;) after initialization and condition in the above syntax.  Initialization expression executes only once during the beginning of loop Condition(Boolean Expression) gets evaluated each time the loop iterates. Loop executes the block of statement repeatedly until this condition returns false. Inc', 'class ForLoopExample {     public static void main(String args[]){          for(int i=10; i>1; i--){               System.out.println("The value of i is: "+i);          }     } }', 0, 0),
(3, 0, 'Do-while loop', 'do-while loop is similar to while loop, however there is a single difference between these two. Unlike while loop, do-while guarantees at-least one execution of block of statements. This happens because the do-while loop evaluates the boolean expression at the end of the loopâ€™s body. Therefore the set of statements gets executed at-least once before the check of boolean expression.  Syntax of while loop:  do{     statement(s) //block of statements }while (Boolean expression);', 'class DoWhileLoopExample {     public static void main(String args[]){          int i=10;          do{               System.out.println(i);               i--;          }while(i>1);     } }', 0, 0),
(4, 0, 'Constructor', 'Constructor is a block of code, which runs when you use new keyword in order to instantiate an object. It looks like a method, however it is not a method. Methods have return type but constructors donâ€™t have any return type.  How to call a constructor? The constructor gets called when we create an object of a class (i.e. new keyword followed by class name). For e.g. Demo obj =  new Demo(); (here Demo() is a default constructor of Demo class).  How does it look?  Default constructor: It is also', 'class Demo {      public Demo()      {          System.out.println("This is a default constructor");      } }', 0, 0),
(5, 0, 'Parameterized Constructor', 'Parameterized constructor: Constructor with argument list is known as parameterized constructor.', 'class Demo {       public Demo(int num, String str)       {            System.out.println("This is a parameterized constructor");       } }', 0, 0),
(6, 0, 'Constructor chaining', 'Constructor chaining is nothing but a scenario where in one constructor calls the constructor of its super class implicitly or explicitly. Suppose there is a class which inherits another class, in this case if you create the object of child class then first super class(or parent class) constructor will be invoked and then child class constructor will be invoked.', 'class Human {         String s1, s2;         public Human()         {               s1 ="Super class";               s2 ="Parent class";         }         public Human(String str)         {                s1= str;                s2= str;         } } class Boy extends Human {         public Boy()         {               s2 ="Child class";         }         public void disp()         {                System.out.println("String 1 is: "+s1);                System.out.println("String 2 is: "+s2);    ', 0, 0),
(7, 0, 'Private Constuctor', 'The use of private constructor is to serve singleton classes. A singleton class is one which limits the number of objects creation to one. Using private constructor we can ensure that no more than one object can be created at a time. We will see in the below example how to use private constructor for limiting the number of objects for a singleton class.', 'package beginnersbook.com; public class SingleTonClass {    //Static Class Reference    private static SingleTonClass obj=null;    private SingleTonClass(){       /*Private Constructor will prevent         * the instantiation of this class directly*/    }    public static SingleTonClass objectCreationMethod(){ 	/*This logic will ensure that no more than 	 * one object can be created at a time */ 	if(obj==null){ 	    obj= new SingleTonClass(); 	}         return obj;    }    public void display(){', 0, 0),
(8, 0, 'Static constructor', 'Have you heard of static constructor in Java? I guess yes but the fact is that they are not allowed in Java. A constructor can not be static in Java.  Before I explain the reason letâ€™s have a look at the below piece of code:', 'public class StaticTest {      /* See below - I have marked the constructor as static */      public static StaticTest()      {          System.out.println("Static Constructor of the class");      }      public static void main(String args[])      {          /*Below: I''m trying to create an object of the class          which would intern call the constructor*/          StaticTest obj = new StaticTest();      } }', 0, 0),
(9, 0, 'Constructors no allowed in interface', 'why constructors are not allowed in interface?  As we know that all the methods in interface are public abstract by default which means the method implementation cannot be provided in the interface itself. It has to be provided by the implementing class. Consider the below piece of code.....All the methods of interface doesnâ€™t have body so there is no need to call the methods in the interface itself. In order to call any method we need an object since there is no need to have object of interfa', 'public interface SumInterface{      public int mymethod(int num1, int num2); } public class SumClass implements SumInterface{      public int mymethod(int num1, int num2){            int op= num1+num2;            return op;     }     public static void main(Sring args[])     {            SumClass obj= new SumClass();            System.out.println(obj.mymethod(2, 3)); }', 0, 0),
(10, 0, 'Constructor overloading', 'Constructor overloading is way of having more than one constructor which does different-2 tasks. For e.g. Vector class has 4 types of constructors. If you do not want to specify the initial capacity and capacity increment then you can simply use default constructor of Vector class like this Vector v = new Vector(); however if you need to specify the capacity and increment then you call the parameterized constructor with two int args like this: Vector v= new Vector(10, 5);', 'package beginnersbook.com; public class StudentData {    private int stuID;    private String stuName;    private int stuAge;    StudentData()    {        //Default constructor        stuID = 100;        stuName = "New Student";        stuAge = 18;    }    StudentData(int num1, String str, int num2)    {        //Parameterized constructor        stuID = num1;        stuName = str;        stuAge = num2;    }    //Getter and setter methods    public int getStuID() {        return stuID;    }    pu', 0, 0),
(11, 1, 'Java features', 'There is given many features of java. They are also known as java buzzwords. The Java Features given below are simple and easy to understand.\r\n\r\nSimple\r\nObject-Oriented\r\nPlatform independent\r\nSecured\r\nRobust\r\nArchitecture neutral\r\nPortable\r\nDynamic\r\nInterpreted\r\nHigh Performance', '', 0, 0),
(12, 1, 'object oriented features of java', 'Basic concepts of OOPs are:\r\nObject\r\nClass\r\nInheritance\r\nPolymorphism\r\nAbstraction\r\nEncapsulation\r\n', '', 0, 0),
(13, 1, 'java world program', 'Let''s see what is the meaning of class, public, static, void, main, String[], System.out.println().\r\n\r\nclass keyword is used to declare a class in java.\r\npublic keyword is an access modifier which represents visibility, it means it is visible to all.\r\nstatic is a keyword, if we declare any method as static, it is known as static method. The core advantage of static method is that there is no need to create object to invoke the static method. The main method is executed by the JVM, so it doesn''t require to create object to invoke the main method. So it saves memory.\r\nvoid is the return type of the method, it means it doesn''t return any value.\r\nmain represents startup of the program.\r\nString[] args is used for command line argument. We will learn it later.\r\nSystem.out.println() is used print statement. We will learn about the internal working of System.out.println statement later.', 'class Simple{  \r\n    public static void main(String args[]){  \r\n     System.out.println("Hello Java");  \r\n    }  \r\n}  ', 0, 0),
(14, 1, 'Valid main methods', '', 'public static void main(String[] args)  \r\npublic static void main(String []args)  \r\npublic static void main(String args[])  \r\npublic static void main(String... args)  \r\nstatic public void main(String[] args)  \r\npublic static final void main(String[] args)  \r\nfinal public static void main(String[] args)  \r\nfinal strictfp public static void main(String[] args) ', 0, 0),
(15, 1, 'Setting path in java', 'To set the temporary path of JDK, you need to follow following steps:\r\n\r\nOpen command prompt\r\ncopy the path of jdk/bin directory\r\nwrite in command prompt: set path=copied_path\r\nFor Example:\r\n\r\nset path=C:\\Program Files\\Java\\jdk1.6.0_23\\bin', '', 0, 0),
(16, 1, 'JVM', 'JVM (Java Virtual Machine) is an abstract machine. It is a specification that provides runtime environment in which java bytecode can be executed.\r\nJVMs are available for many hardware and software platforms. JVM, JRE and JDK are platform dependent because configuration of each OS differs. But, Java is platform independent.\r\nThe JVM performs following main tasks:\r\nLoads code\r\nVerifies code\r\nExecutes code\r\nProvides runtime environment', '', 0, 0),
(17, 1, 'JRE', 'JRE\r\n\r\nJRE is an acronym for Java Runtime Environment.It is used to provide runtime environment.It is the implementation of JVM.It physically exists.It contains set of libraries + other files that JVM uses at runtime.\r\nImplementation of JVMs are also actively released by other companies besides Sun Micro Systems.', '', 0, 0),
(18, 1, 'JDK', 'JDK is an acronym for Java Development Kit.It physically exists.It contains JRE + development tools.\r\n', '', 0, 0),
(19, 1, 'Variables', 'Variable is name of reserved area allocated in memory. There are three types of variables in java\r\nlocal variable\r\ninstance variable\r\nstatic variable\r\n\r\nLocal Variable\r\n\r\nA variable that is declared inside the method is called local variable.\r\nInstance Variable\r\n\r\nA variable that is declared inside the class but outside the method is called instance variable . It is not declared as static.\r\nStatic variable\r\n\r\nA variable that is declared as static is called static variable. It cannot be local.\r\n\r\n\r\n', 'class A{  \r\nint data=50;//instance variable  \r\nstatic int m=100;//static variable  \r\nvoid method(){  \r\nint n=90;//local variable  \r\n}  \r\n}//end of class  ', 0, 0),
(20, 1, 'data types', 'Data Types in Java\r\n\r\nIn java, there are two types of data types\r\n1. primitive data types\r\n2. non-primitive data type', '', 0, 0),
(21, 1, 'java operators', 'Operator in java is a symbol that is used to perform operations. There are many types of operators in java such as unary operator, arithmetic operator, relational operator, shift operator, bitwise operator, ternary operator and assignment operator.\r\n\r\nOperator,Precedence\r\npostfix, expr++ expr--\r\nunary, ++expr --expr +expr -expr ~ !\r\nmultiplicative,	* / %\r\nadditive,	+ -\r\nshift,	<< >> >>>\r\nrelational,	< > <= >= instanceof\r\nequality,	== !=\r\nbitwise AND,	&\r\nbitwise exclusive OR,	^\r\nbitwise inclusive OR,	|\r\nlogical AND,	&&\r\nlogical OR,	||\r\nternary	? :,\r\nassignment,	= += -= *= /= %= &= ^= |= <<= >>= >>>=', '', 0, 0),
(22, 1, 'Fibonacci series', 'Input: 10\r\n\r\nOutput: 0 1 1 2 3 5 8 13 21 34', 'class FibonacciExample1{  \r\npublic static void main(String args[])  \r\n{    \r\n int n1=0,n2=1,n3,i,count=10;    \r\n System.out.print(n1+" "+n2);//printing 0 and 1    \r\n    \r\n for(i=2;i<count;++i)//loop starts from 2 because 0 and 1 are already printed    \r\n {    \r\n  n3=n1+n2;    \r\n  System.out.print(" "+n3);    \r\n  n1=n2;    \r\n  n2=n3;    \r\n }    \r\n  \r\n}}  ', 0, 0),
(23, 1, 'Check whether number is prime or not?\r\n', 'Input: 44\r\n\r\nOutput: not prime number\r\n\r\nInput: 7\r\n\r\nOutput: prime number', 'class PrimeExample{  \r\n public static void main(String args[]){  \r\n  int i,m=0,flag=0;    \r\n  int n=17;//it is the number to be checked  \r\n  m=n/2;    \r\n  for(i=2;i<=m;i++){    \r\n   if(n%i==0){    \r\n   System.out.println("Number is not prime");    \r\n   flag=1;    \r\n   break;    \r\n   }    \r\n  }    \r\n  if(flag==0)    \r\n  System.out.println("Number is prime");    \r\n}  \r\n}  ', 0, 0),
(24, 1, 'Palindrome number program', 'Palindrome number algorithm\r\n\r\nGet the number to check for palindrome\r\nHold the number in temporary variable\r\nReverse the number\r\nCompare the temporary number with reversed number\r\nIf both numbers are same, print "palindrome number"\r\nElse print "not palindrome number"\r\n\r\nInput: 329\r\n\r\nOutput: not palindrome number\r\n\r\nInput: 12321\r\n\r\nOutput: palindrome number', 'class PalindromeExample{  \r\n public static void main(String args[]){  \r\n  int r,sum=0,temp;    \r\n  int n=454;//It is the number variable to be checked for palindrome  \r\n  \r\n  temp=n;    \r\n  while(n>0){    \r\n   r=n%10;  //getting remainder  \r\n   sum=(sum*10)+r;    \r\n   n=n/10;    \r\n  }    \r\n  if(temp==sum)    \r\n   System.out.println("palindrome number ");    \r\n  else    \r\n   System.out.println("not palindrome");    \r\n}  \r\n}  ', 0, 0),
(25, 1, 'print factorial of a number.', 'Input: 5\r\n\r\nOutput: 120\r\n\r\nInput: 6\r\n\r\nOutput: 720', 'class FactorialExample{  \r\n public static void main(String args[]){  \r\n  int i,fact=1;  \r\n  int number=5;//It is the number to calculate factorial    \r\n  for(i=1;i<=number;i++){    \r\n      fact=fact*i;    \r\n  }    \r\n  System.out.println("Factorial of "+number+" is: "+fact);    \r\n }  \r\n}  ', 0, 0),
(26, 1, 'Armstrong Number in Java', '153 = (1*1*1)+(5*5*5)+(3*3*3)  \r\nwhere:  \r\n(1*1*1)=1  \r\n(5*5*5)=125  \r\n(3*3*3)=27  \r\nSo:  \r\n1+125+27=153 ', 'class ArmstrongExample{  \r\n  public static void main(String[] args)  {  \r\n    int c=0,a,temp;  \r\n    int n=153;//It is the number to check armstrong  \r\n    temp=n;  \r\n    while(n>0)  \r\n    {  \r\n    a=n%10;  \r\n    n=n/10;  \r\n    c=c+(a*a*a);  \r\n    }  \r\n    if(temp==c)  \r\n    System.out.println("armstrong number");   \r\n    else  \r\n        System.out.println("Not armstrong number");   \r\n   }  \r\n}  ', 0, 0),
(27, 1, 'Bubble sort', 'In bubble sort algorithm, array is traversed from first element to last element. Here, current element is compared with the next element. If current element is greater than the next element, it is swapped.', 'public class BubbleSortExample {  \r\n    static void bubbleSort(int[] arr) {  \r\n        int n = arr.length;  \r\n        int temp = 0;  \r\n         for(int i=0; i < n; i++){  \r\n                 for(int j=1; j < (n-i); j++){  \r\n                          if(arr[j-1] > arr[j]){  \r\n                                 //swap elements  \r\n                                 temp = arr[j-1];  \r\n                                 arr[j-1] = arr[j];  \r\n                                 arr[j] = temp;  \r\n                         }  \r\n                          \r\n                 }  \r\n         }  \r\n  \r\n    }  \r\n    public static void main(String[] args) {  \r\n                int arr[] ={3,60,35,2,45,320,5};  \r\n                 \r\n                System.out.println("Array Before Bubble Sort");  \r\n                for(int i=0; i < arr.length; i++){  \r\n                        System.out.print(arr[i] + " ");  \r\n                }  \r\n                System.out.println();  \r\n                  \r\n                bubbleSort(arr);//sorting array elements using bubble sort  \r\n                 \r\n                System.out.println("Array After Bubble Sort");  \r\n                for(int i=0; i < arr.length; i++){  \r\n                        System.out.print(arr[i] + " ");  \r\n                }  \r\n   \r\n        }  \r\n}  ', 0, 0),
(28, 1, 'Java naming convention', 'By using standard Java naming conventions, you make your code easier to read for yourself and for other programmers. Readability of Java program is very important. It indicates that less time is spent to figure out what the code does.\r\n\r\nName	Convention\r\nclass name	should start with uppercase letter and be a noun e.g. String, Color, Button, System, Thread etc.\r\ninterface name	should start with uppercase letter and be an adjective e.g. Runnable, Remote, ActionListener etc.\r\nmethod name	should start with lowercase letter and be a verb e.g. actionPerformed(), main(), print(), println() etc.\r\nvariable name	should start with lowercase letter e.g. firstName, orderNumber etc.\r\npackage name	should be in lowercase letter e.g. java, lang, sql, util etc.\r\nconstants name	should be in uppercase letter. e.g. RED, YELLOW, MAX_PRIORITY etc.', '', 0, 0),
(29, 1, 'objects in java', 'An entity that has state and behavior is known as an object e.g. chair, bike, marker, pen, table, car etc. It can be physical or logical (tengible and intengible). The example of integible object is banking system.\r\n\r\nAn object has three characteristics:\r\n\r\nstate: represents data (value) of an object.\r\nbehavior: represents the behavior (functionality) of an object such as deposit, withdraw etc.\r\nidentity: Object identity is typically implemented via a unique ID. The value of the ID is not visible to the external user. But,it is used internally by the JVM to identify each object uniquely.\r\nFor Example: Pen is an object. Its name is Reynolds, color is white etc. known as its state. It is used to write, so writing is its behavior.\r\nObject is an instance of a class. Class is a template or blueprint from which objects are created. So object is the instance(result) of a class.', 'class Student1{  \r\n int id;//data member (also instance variable)  \r\n String name;//data member(also instance variable)  \r\n  \r\n public static void main(String args[]){  \r\n  Student1 s1=new Student1();//creating an object of Student  \r\n  System.out.println(s1.id);  \r\n  System.out.println(s1.name);  \r\n }  \r\n}  ', 0, 0),
(30, 1, 'Class in java', 'A class is a group of objects that has common properties. It is a template or blueprint from which objects are created.\r\nA class in java can contain:\r\n\r\ndata member\r\nmethod\r\nconstructor\r\nblock\r\nclass and interface\r\n\r\nSyntax to declare a class:\r\n\r\nclass <class_name>{  \r\n    data member;  \r\n    method;  \r\n}  ', 'class Student1{  \r\n int id;//data member (also instance variable)  \r\n String name;//data member(also instance variable)  \r\n  \r\n public static void main(String args[]){  \r\n  Student1 s1=new Student1();//creating an object of Student  \r\n  System.out.println(s1.id);  \r\n  System.out.println(s1.name);  \r\n }  \r\n} ', 0, 0),
(31, 1, 'method overloading (By changing number of arguments)', 'If a class have multiple methods by same name but different parameters, it is known as Method Overloading.\r\n\r\nIf we have to perform only one operation, having same name of the methods increases the readability of the program.\r\n\r\nSuppose you have to perform addition of the given numbers but there can be any number of arguments, if you write the method such as a(int,int) for two parameters, and b(int,int,int) for three parameters then it may be difficult for you as well as other programmers to understand the behaviour of the method because its name differs. So, we perform method overloading to figure out the program quickly.\r\n\r\n', 'class Calculation{  \r\n  void sum(int a,int b){System.out.println(a+b);}  \r\n  void sum(int a,int b,int c){System.out.println(a+b+c);}  \r\n  \r\n  public static void main(String args[]){  \r\n  Calculation obj=new Calculation();  \r\n  obj.sum(10,10,10);  \r\n  obj.sum(20,20);  \r\n  \r\n  }  \r\n}  ', 0, 0),
(32, 1, 'Method Overloading by changing data type of argument', 'In this example, we have created two overloaded methods that differs in data type. The first sum method receives two integer arguments and second sum method receives two double arguments.', 'class Calculation2{  \r\n  void sum(int a,int b){System.out.println(a+b);}  \r\n  void sum(double a,double b){System.out.println(a+b);}  \r\n  \r\n  public static void main(String args[]){  \r\n  Calculation2 obj=new Calculation2();  \r\n  obj.sum(10.5,10.5);  \r\n  obj.sum(20,20);  \r\n  \r\n  }  \r\n}  ', 0, 0),
(33, 1, 'Method Overloading by changing data type of argument', 'In this example, we have created two overloaded methods that differs in data type. The first sum method receives two integer arguments and second sum method receives two double arguments.', 'class Calculation2{  \r\n  void sum(int a,int b){System.out.println(a+b);}  \r\n  void sum(double a,double b){System.out.println(a+b);}  \r\n  \r\n  public static void main(String args[]){  \r\n  Calculation2 obj=new Calculation2();  \r\n  obj.sum(10.5,10.5);  \r\n  obj.sum(20,20);  \r\n  \r\n  }  \r\n}  ', 0, 0),
(34, 1, 'Can we overload main() method?', 'Yes, by method overloading. You can have any number of main methods in a class by method overloading. Let''s see the simple example:', 'class Overloading1{  \r\n  public static void main(int a){  \r\n  System.out.println(a);  \r\n  }  \r\n    \r\n  public static void main(String args[]){  \r\n  System.out.println("main() method invoked");  \r\n  main(10);  \r\n  }  \r\n} ', 0, 0),
(35, 1, 'constructors in java', 'Constructor in java is a special type of method that is used to initialize the object.\r\n\r\nJava constructor is invoked at the time of object creation. It constructs the values i.e. provides data for the object that is why it is known as constructor.\r\n\r\nRules for creating java constructor\r\n\r\nThere are basically two rules defined for the constructor.\r\n\r\nConstructor name must be same as its class name\r\nConstructor must have no explicit return type\r\n\r\nTypes of java constructors\r\n\r\nThere are two types of constructors:\r\n\r\n1. Default constructor (no-arg constructor)\r\n2. Parameterized constructor\r\n\r\nJava Default Constructor\r\n\r\nA constructor that have no parameter is known as default constructor.\r\nSyntax of default constructor:\r\n\r\n<class_name>(){} \r\n\r\n \r\n\r\n', 'Example of default constructor\r\n\r\nIn this example, we are creating the no-arg constructor in the Bike class. It will be invoked at the time of object creation.\r\nclass Bike1{  \r\nBike1(){System.out.println("Bike is created");}  \r\npublic static void main(String args[]){  \r\nBike1 b=new Bike1();  \r\n}  \r\n}  ', 0, 0),
(36, 1, 'parameterized constructor', 'Java parameterized constructor\r\n\r\nA constructor that have parameters is known as parameterized constructor.\r\nWhy use parameterized constructor?\r\n\r\nParameterized constructor is used to provide different values to the distinct objects.', 'Example of parameterized constructor\r\n\r\nIn this example, we have created the constructor of Student class that have two parameters. We can have any number of parameters in the constructor.\r\nclass Student4{  \r\n    int id;  \r\n    String name;  \r\n      \r\n    Student4(int i,String n){  \r\n    id = i;  \r\n    name = n;  \r\n    }  \r\n    void display(){System.out.println(id+" "+name);}  \r\n   \r\n    public static void main(String args[]){  \r\n    Student4 s1 = new Student4(111,"Karan");  \r\n    Student4 s2 = new Student4(222,"Aryan");  \r\n    s1.display();  \r\n    s2.display();  \r\n   }  \r\n}  ', 0, 0),
(37, 1, 'constructor overloading', 'Constructor overloading is a technique in Java in which a class can have any number of constructors that differ in parameter lists.The compiler differentiates these constructors by taking into account the number of parameters in the list and their type.', 'class Student5{  \r\n    int id;  \r\n    String name;  \r\n    int age;  \r\n    Student5(int i,String n){  \r\n    id = i;  \r\n    name = n;  \r\n    }  \r\n    Student5(int i,String n,int a){  \r\n    id = i;  \r\n    name = n;  \r\n    age=a;  \r\n    }  \r\n    void display(){System.out.println(id+" "+name+" "+age);}  \r\n   \r\n    public static void main(String args[]){  \r\n    Student5 s1 = new Student5(111,"Karan");  \r\n    Student5 s2 = new Student5(222,"Aryan",25);  \r\n    s1.display();  \r\n    s2.display();  \r\n   }  \r\n} ', 0, 0),
(38, 1, 'copy constructor', 'There is no copy constructor in java. But, we can copy the values of one object to another like copy constructor in C++.\r\n\r\nThere are many ways to copy the values of one object into another in java. They are:\r\n\r\nBy constructor\r\nBy assigning the values of one object into another\r\nBy clone() method of Object class\r\nIn this example, we are going to copy the values of one object into another using java constructor.', 'class Student6{  \r\n    int id;  \r\n    String name;  \r\n    Student6(int i,String n){  \r\n    id = i;  \r\n    name = n;  \r\n    }  \r\n      \r\n    Student6(Student6 s){  \r\n    id = s.id;  \r\n    name =s.name;  \r\n    }  \r\n    void display(){System.out.println(id+" "+name);}  \r\n   \r\n    public static void main(String args[]){  \r\n    Student6 s1 = new Student6(111,"Karan");  \r\n    Student6 s2 = new Student6(s1);  \r\n    s1.display();  \r\n    s2.display();  \r\n   }  \r\n}  ', 0, 0),
(39, 1, 'static variable', 'If you declare any variable as static, it is known static variable.\r\n\r\nThe static variable can be used to refer the common property of all objects (that is not unique for each object) e.g. company name of employees,college name of students etc.\r\nThe static variable gets memory only once in class area at the time of class loading.\r\nAdvantage of static variable\r\n\r\nIt makes your program memory efficient (i.e it saves memory).', '/Program of static variable  \r\n  \r\nclass Student8{  \r\n   int rollno;  \r\n   String name;  \r\n   static String college ="ITS";  \r\n     \r\n   Student8(int r,String n){  \r\n   rollno = r;  \r\n   name = n;  \r\n   }  \r\n void display (){System.out.println(rollno+" "+name+" "+college);}  \r\n  \r\n public static void main(String args[]){  \r\n Student8 s1 = new Student8(111,"Karan");  \r\n Student8 s2 = new Student8(222,"Aryan");  \r\n   \r\n s1.display();  \r\n s2.display();  \r\n }  \r\n} ', 0, 0),
(40, 1, 'static method', 'If you apply static keyword with any method, it is known as static method.\r\n\r\nA static method belongs to the class rather than object of a class.\r\nA static method can be invoked without the need for creating an instance of a class.\r\nstatic method can access static data member and can change the value of it.', '//Program of changing the common property of all objects(static field).  \r\n  \r\nclass Student9{  \r\n     int rollno;  \r\n     String name;  \r\n     static String college = "ITS";  \r\n       \r\n     static void change(){  \r\n     college = "BBDIT";  \r\n     }  \r\n  \r\n     Student9(int r, String n){  \r\n     rollno = r;  \r\n     name = n;  \r\n     }  \r\n  \r\n     void display (){System.out.println(rollno+" "+name+" "+college);}  \r\n  \r\n    public static void main(String args[]){  \r\n    Student9.change();  \r\n  \r\n    Student9 s1 = new Student9 (111,"Karan");  \r\n    Student9 s2 = new Student9 (222,"Aryan");  \r\n    Student9 s3 = new Student9 (333,"Sonoo");  \r\n  \r\n    s1.display();  \r\n    s2.display();  \r\n    s3.display();  \r\n    }  \r\n}  ', 0, 0),
(41, 1, 'static block', 'Is used to initialize the static data member.\r\nIt is executed before main method at the time of classloading.', 'class A2{  \r\n  static{System.out.println("static block is invoked");}  \r\n  public static void main(String args[]){  \r\n   System.out.println("Hello main");  \r\n  }  \r\n}', 0, 0),
(42, 1, 'this keyword', 'this keyword can be used to refer current class instance variable.\r\nthis() can be used to invoke current class constructor.\r\nthis keyword can be used to invoke current class method (implicitly)\r\nthis can be passed as an argument in the method call.\r\nthis can be passed as argument in the constructor call.\r\nthis keyword can also be used to return the current class instance.', '//example of this keyword  \r\nclass Student11{  \r\n    int id;  \r\n    String name;  \r\n      \r\n    Student11(int id,String name){  \r\n    this.id = id;  \r\n    this.name = name;  \r\n    }  \r\n    void display(){System.out.println(id+" "+name);}  \r\n    public static void main(String args[]){  \r\n    Student11 s1 = new Student11(111,"Karan");  \r\n    Student11 s2 = new Student11(222,"Aryan");  \r\n    s1.display();  \r\n    s2.display();  \r\n}  \r\n}  ', 0, 0),
(43, 1, 'inheritance', 'Inheritance in java is a mechanism in which one object acquires all the properties and behaviors of parent object.\r\n\r\nThe idea behind inheritance in java is that you can create new classes that are built upon existing classes. When you inherit from an existing class, you can reuse methods and fields of parent class, and you can add new methods and fields also.\r\n\r\nInheritance represents the IS-A relationship, also known as parent-child relationship.\r\n\r\nSyntax of Java Inheritance\r\n\r\nclass Subclass-name extends Superclass-name  \r\n{  \r\n   //methods and fields  \r\n}  \r\nThe extends keyword indicates that you are making a new class that derives from an existing class.\r\n\r\nIn the terminology of Java, a class that is inherited is called a super class. The new class is called a subclass.', 'class Employee{  \r\n float salary=40000;  \r\n}  \r\nclass Programmer extends Employee{  \r\n int bonus=10000;  \r\n public static void main(String args[]){  \r\n   Programmer p=new Programmer();  \r\n   System.out.println("Programmer salary is:"+p.salary);  \r\n   System.out.println("Bonus of Programmer is:"+p.bonus);  \r\n}  \r\n}  \r\n\r\nProgrammer is the subclass and Employee is the superclass. Relationship between two classes is Programmer IS-A Employee.It means that Programmer is a type of Employee.', 0, 0),
(44, 1, 'types of inheritance', 'On the basis of class, there can be three types of inheritance in java: single, multilevel and hierarchical.\r\n\r\nIn java programming, multiple and hybrid inheritance is supported through interface only. We will learn about interfaces later.\r\n\r\nNote: Multiple inheritance is not supported in java through class.\r\n\r\nWhen a class extends multiple classes i.e. known as multiple inheritance.', '', 0, 0),
(45, 1, 'Why multiple inheritance not supported in java?', 'To reduce the complexity and simplify the language, multiple inheritance is not supported in java.\r\n\r\nConsider a scenario where A, B and C are three classes. The C class inherits A and B classes. If A and B classes have same method and you call it from child class object, there will be ambiguity to call method of A or B class.\r\n\r\nSince compile time errors are better than runtime errors, java renders compile time error if you inherit 2 classes. So whether you have same method or different, there will be compile time error now.', 'class A{  \r\nvoid msg(){System.out.println("Hello");}  \r\n}  \r\nclass B{  \r\nvoid msg(){System.out.println("Welcome");}  \r\n}  \r\nclass C extends A,B{//suppose if it were  \r\n   \r\n Public Static void main(String args[]){  \r\n   C obj=new C();  \r\n   obj.msg();//Now which msg() method would be invoked?  \r\n}  \r\n} ', 0, 0),
(46, 1, 'Aggregation in java', 'If a class have an entity reference, it is known as Aggregation. Aggregation represents HAS-A relationship.\r\n\r\nConsider a situation, Employee object contains many informations such as id, name, emailId etc. It contains one more object named address, which contains its own informations such as city, state, country, zipcode etc. as given below.\r\n\r\nclass Employee{  \r\nint id;  \r\nString name;  \r\nAddress address;//Address is a class  \r\n...  \r\n} ', 'class Operation{  \r\n int square(int n){  \r\n  return n*n;  \r\n }  \r\n}  \r\n  \r\nclass Circle{  \r\n Operation op;//aggregation  \r\n double pi=3.14;  \r\n    \r\n double area(int radius){  \r\n   op=new Operation();  \r\n   int rsquare=op.square(radius);//code reusability (i.e. delegates the method call).  \r\n   return pi*rsquare;  \r\n }  \r\n  \r\n     \r\n    \r\n public static void main(String args[]){  \r\n   Circle c=new Circle();  \r\n   double result=c.area(5);  \r\n   System.out.println(result);  \r\n }  \r\n} ', 0, 0),
(47, 1, 'Method overriding', 'f subclass (child class) has the same method as declared in the parent class, it is known as method overriding in java.\r\n\r\nIn other words, If subclass provides the specific implementation of the method that has been provided by one of its parent class, it is known as method overriding.\r\n\r\nUsage of Java Method Overriding\r\n\r\nMethod overriding is used to provide specific implementation of a method that is already provided by its super class.\r\nMethod overriding is used for runtime polymorphism\r\nRules for Java Method Overriding\r\n\r\nmethod must have same name as in the parent class\r\nmethod must have same parameter as in the parent class.\r\nmust be IS-A relationship (inheritance).', 'In this example, we have defined the run method in the subclass as defined in the parent class but it has some specific implementation. The name and parameter of the method is same and there is IS-A relationship between the classes, so there is method overriding.\r\n\r\nclass Vehicle{  \r\nvoid run(){System.out.println("Vehicle is running");}  \r\n}  \r\nclass Bike2 extends Vehicle{  \r\nvoid run(){System.out.println("Bike is running safely");}  \r\n  \r\npublic static void main(String args[]){  \r\nBike2 obj = new Bike2();  \r\nobj.run();  \r\n}', 0, 0),
(48, 1, 'covariant return type', 'The covariant return type specifies that the return type may vary in the same direction as the subclass.\r\n\r\nBefore Java5, it was not possible to override any method by changing the return type. But now, since Java5, it is possible to override method by changing the return type if subclass overrides any method whose return type is Non-Primitive but it changes its return type to subclass type. Let''s take a simple example', 'class A{  \r\nA get(){return this;}  \r\n}  \r\n  \r\nclass B1 extends A{  \r\nB1 get(){return this;}  \r\nvoid message(){System.out.println("welcome to covariant return type");}  \r\n  \r\npublic static void main(String args[]){  \r\nnew B1().get().message();  \r\n}  \r\n}  ', 0, 0),
(49, 1, 'super keyword', 'The super keyword in java is a reference variable that is used to refer immediate parent class object.\r\n\r\nWhenever you create the instance of subclass, an instance of parent class is created implicitly i.e. referred by super reference variable.\r\n\r\nUsage of java super Keyword\r\n\r\nsuper is used to refer immediate parent class instance variable.\r\nsuper() is used to invoke immediate parent class constructor.\r\nsuper is used to invoke immediate parent class method.', '/example of super keyword  \r\n  \r\nclass Vehicle{  \r\n  int speed=50;  \r\n}  \r\n  \r\nclass Bike4 extends Vehicle{  \r\n  int speed=100;  \r\n      \r\n  void display(){  \r\n   System.out.println(super.speed);//will print speed of Vehicle now  \r\n  }  \r\n  public static void main(String args[]){  \r\n   Bike4 b=new Bike4();  \r\n   b.display();  \r\n     \r\n}  \r\n}  ', 0, 0),
(50, 1, 'Final variable', 'If you make any variable as final, you cannot change the value of final variable(It will be constant).', 'There is a final variable speedlimit, we are going to change the value of this variable, but It can''t be changed because final variable once assigned a value can never be changed.\r\n\r\nclass Bike9{  \r\n final int speedlimit=90;//final variable  \r\n void run(){  \r\n  speedlimit=400;  \r\n }  \r\n public static void main(String args[]){  \r\n Bike9 obj=new  Bike9();  \r\n obj.run();  \r\n }  \r\n}//end of class  ', 0, 0),
(51, 1, 'Final Method', 'If you make any method as final, you cannot override it.', 'class Bike{  \r\n  final void run(){System.out.println("running");}  \r\n}  \r\n     \r\nclass Honda extends Bike{  \r\n   void run(){System.out.println("running safely with 100kmph");}  \r\n     \r\n   public static void main(String args[]){  \r\n   Honda honda= new Honda();  \r\n   honda.run();  \r\n   }  \r\n} ', 0, 0),
(52, 1, 'Final class', 'If you make any class as final, you cannot extend it.', 'final class Bike{}  \r\n  \r\nclass Honda1 extends Bike{  \r\n  void run(){System.out.println("running safely with 100kmph");}  \r\n    \r\n  public static void main(String args[]){  \r\n  Honda1 honda= new Honda();  \r\n  honda.run();  \r\n  }  \r\n}  ', 0, 0),
(53, 1, 'What is blank or uninitialized final variable?', 'A final variable that is not initialized at the time of declaration is known as blank final variable.\r\n\r\nIf you want to create a variable that is initialized at the time of creating object and once initialized may not be changed, it is useful. For example PAN CARD number of an employee.\r\n\r\nIt can be initialized only in constructor.', 'class Student{  \r\nint id;  \r\nString name;  \r\nfinal String PAN_CARD_NUMBER;  \r\n...  \r\n}', 0, 0),
(54, 1, 'Polymorphism in Java', 'Polymorphism in java is a concept by which we can perform a single action by different ways. Polymorphism is derived from 2 greek words: poly and morphs. The word "poly" means many and "morphs" means forms. So polymorphism means many forms.\r\n\r\nThere are two types of polymorphism in java: compile time polymorphism and runtime polymorphism. We can perform polymorphism in java by method overloading and method overriding.\r\n\r\nIf you overload static method in java, it is the example of compile time polymorphism\r\n\r\nRuntime Polymorphism in Java\r\n\r\nRuntime polymorphism or Dynamic Method Dispatch is a process in which a call to an overridden method is resolved at runtime rather than compile-time.\r\n\r\nIn this process, an overridden method is called through the reference variable of a superclass. The determination of the method to be called is based on the object being referred to by the reference variable.\r\n\r\nLet''s first understand the upcasting before Runtime Polymorphism.\r\n\r\nUpcasting\r\n\r\nWhen reference variable of Parent class refers to the object of Child class, it is known as upcasting. \r\n\r\nclass A{}  \r\nclass B extends A{}  \r\nA a=new B();//upcasting  \r\n\r\n\r\n', 'class Bike{  \r\n  void run(){System.out.println("running");}  \r\n}  \r\nclass Splender extends Bike{  \r\n  void run(){System.out.println("running safely with 60km");}  \r\n  \r\n  public static void main(String args[]){  \r\n    Bike b = new Splender();//upcasting  \r\n    b.run();  \r\n  }  \r\n} ', 0, 0),
(55, 1, 'Static Binding and Dynamic Binding', 'Connecting a method call to the method body is known as binding.\r\n\r\nThere are two types of binding\r\n\r\nstatic binding (also known as early binding).\r\ndynamic binding (also known as late binding).\r\n\r\nstatic binding\r\n\r\nWhen type of the object is determined at compiled time(by the compiler), it is known as static binding.\r\n\r\nIf there is any private, final or static method in a class, there is static binding.\r\n\r\nDynamic binding\r\n\r\nWhen type of the object is determined at run-time, it is known as dynamic binding.\r\n', 'Example of static binding\r\n\r\nclass Dog{  \r\n private void eat(){System.out.println("dog is eating...");}  \r\n  \r\n public static void main(String args[]){  \r\n  Dog d1=new Dog();  \r\n  d1.eat();  \r\n }  \r\n} \r\n\r\nExample of dynamic binding\r\n\r\nclass Animal{  \r\n void eat(){System.out.println("animal is eating...");}  \r\n}  \r\n  \r\nclass Dog extends Animal{  \r\n void eat(){System.out.println("dog is eating...");}  \r\n  \r\n public static void main(String args[]){  \r\n  Animal a=new Dog();  \r\n  a.eat();  \r\n }  \r\n}  \r\n\r\n', 0, 0),
(56, 1, 'Java instanceof', 'The java instanceof operator is used to test whether the object is an instance of the specified type (class or subclass or interface).\r\n\r\nThe instanceof in java is also known as type comparison operator because it compares the instance with type. It returns either true or false. If we apply the instanceof operator with any variable that has null value, it returns false.', 'class Simple1{  \r\n public static void main(String args[]){  \r\n Simple1 s=new Simple1();  \r\n System.out.println(s instanceof Simple1);//true  \r\n }  \r\n}', 0, 0),
(57, 1, 'Abstract class in Java', 'A class that is declared as abstract is known as abstract class. It needs to be extended and its method implemented. It cannot be instantiated.\r\n\r\nExample abstract class\r\n\r\nabstract class A{}  ', 'abstract class Bike{  \r\n  abstract void run();  \r\n}  \r\n  \r\nclass Honda4 extends Bike{  \r\nvoid run(){System.out.println("running safely..");}  \r\n  \r\npublic static void main(String args[]){  \r\n Bike obj = new Honda4();  \r\n obj.run();  \r\n}  \r\n} ', 0, 0),
(58, 1, 'Interface in Java', 'An interface in java is a blueprint of a class. It has static constants and abstract methods only.\r\n\r\nThe interface in java is a mechanism to achieve fully abstraction. There can be only abstract methods in the java interface not method body. It is used to achieve fully abstraction and multiple inheritance in Java.\r\n\r\nJava Interface also represents IS-A relationship.\r\n\r\nIt cannot be instantiated just like abstract class.\r\n', 'interface printable{  \r\nvoid print();  \r\n}  \r\n  \r\nclass A6 implements printable{  \r\npublic void print(){System.out.println("Hello");}  \r\n  \r\npublic static void main(String args[]){  \r\nA6 obj = new A6();  \r\nobj.print();  \r\n }  \r\n} ', 0, 0),
(59, 0, 'Difference between abstract class and interface', 'Abstract class\r\n\r\n1) Abstract class can have abstract and non-abstract methods.\r\n2) Abstract class doesn''t support multiple inheritance.\r\n3) Abstract class can have final, non-final, static and non-static variables.\r\n4) Abstract class can have static methods, main method and constructor.\r\n5) Abstract class can provide the implementation of interface.\r\n6) The abstract keyword is used to declare abstract class.\r\n\r\nInterface in java:\r\n1. Interface can have only abstract methods.\r\n2. Interface supports multiple inheritance.\r\n3. Interface supports multiple inheritance.\r\n4. Interface can''t have static methods, main method or constructor.\r\n5. Interface can''t provide the implementation of abstract class.\r\n6. The interface keyword is used to declare interface.\r\n\r\n\r\n\r\n\r\n', 'Abstract class example:\r\n\r\npublic abstract class Shape{\r\npublic abstract void draw();\r\n}\r\n\r\nInterface example\r\npublic interface Drawable{\r\nvoid draw();\r\n}', 0, 0),
(60, 2, 'Java Package', 'A java package is a group of similar types of classes, interfaces and sub-packages.\r\n\r\nPackage in java can be categorized in two form, built-in package and user-defined package.\r\n\r\nThere are many built-in packages such as java, lang, awt, javax, swing, net, io, util, sql etc.\r\n\r\nHere, we will have the detailed learning of creating and using user-defined packages.\r\n\r\nAdvantage of Java Package\r\n\r\n1) Java package is used to categorize the classes and interfaces so that they can be easily maintained.\r\n\r\n2) Java package provides access protection.\r\n\r\n3) Java package removes naming collision.', '//save as Simple.java  \r\npackage mypack;  \r\npublic class Simple{  \r\n public static void main(String args[]){  \r\n    System.out.println("Welcome to package");  \r\n   }  \r\n}  ', 0, 0),
(61, 2, 'Using packagename.*', 'If you use package.* then all the classes and interfaces of this package will be accessible but not subpackages.\r\n\r\nThe import keyword is used to make the classes and interface of another package accessible to the current package.', '//save by A.java  \r\npackage pack;  \r\npublic class A{  \r\n  public void msg(){System.out.println("Hello");}  \r\n}  \r\n//save by B.java  \r\npackage mypack;  \r\nimport pack.*;  \r\n  \r\nclass B{  \r\n  public static void main(String args[]){  \r\n   A obj = new A();  \r\n   obj.msg();  \r\n  }  \r\n}  ', 0, 0),
(62, 2, 'Access Modifiers in java\r\n', 'There are two types of modifiers in java: access modifiers and non-access modifiers.\r\n\r\nThe access modifiers in java specifies accessibility (scope) of a data member, method, constructor or class.\r\n\r\nThere are 4 types of java access modifiers:\r\n\r\nprivate\r\ndefault\r\nprotected\r\npublic\r\n\r\n1) private access modifier\r\n\r\nThe private access modifier is accessible only within class.\r\n\r\n\r\n\r\n\r\n', 'Example of private access modifier:\r\nclass A{  \r\nprivate int data=40;  \r\nprivate void msg(){System.out.println("Hello java");}  \r\n}  \r\n  \r\npublic class Simple{  \r\n public static void main(String args[]){  \r\n   A obj=new A();  \r\n   System.out.println(obj.data);//Compile Time Error  \r\n   obj.msg();//Compile Time Error  \r\n   }  \r\n}  ', 0, 0),
(63, 2, 'Default access modifier', '\r\nIf you don''t use any modifier, it is treated as default bydefault. The default modifier is accessible only within package.', '//save by A.java  \r\npackage pack;  \r\nclass A{  \r\n  void msg(){System.out.println("Hello");}  \r\n}  \r\n//save by B.java  \r\npackage mypack;  \r\nimport pack.*;  \r\nclass B{  \r\n  public static void main(String args[]){  \r\n   A obj = new A();//Compile Time Error  \r\n   obj.msg();//Compile Time Error  \r\n  }  \r\n} ', 0, 0),
(64, 2, 'Protected access modifier', 'The protected access modifier is accessible within package and outside the package but through inheritance only.\r\n\r\nThe protected access modifier can be applied on the data member, method and constructor. It can''t be applied on the class.', '//save by A.java  \r\npackage pack;  \r\npublic class A{  \r\nprotected void msg(){System.out.println("Hello");}  \r\n}  \r\n//save by B.java  \r\npackage mypack;  \r\nimport pack.*;  \r\n  \r\nclass B extends A{  \r\n  public static void main(String args[]){  \r\n   B obj = new B();  \r\n   obj.msg();  \r\n  }  \r\n}  ', 0, 0),
(65, 2, 'public access modifier', 'The public access modifier is accessible everywhere. It has the widest scope among all other modifiers.', '//save by A.java  \r\n  \r\npackage pack;  \r\npublic class A{  \r\npublic void msg(){System.out.println("Hello");}  \r\n}  \r\n//save by B.java  \r\n  \r\npackage mypack;  \r\nimport pack.*;  \r\n  \r\nclass B{  \r\n  public static void main(String args[]){  \r\n   A obj = new A();  \r\n   obj.msg();  \r\n  }  ', 0, 0),
(66, 1, 'Encapsulation in Java', 'Encapsulation in java is a process of wrapping code and data together into a single unit, for example capsule i.e. mixed of several medicines.', '//save as Student.java  \r\npackage com.javatpoint;  \r\npublic class Student{  \r\nprivate String name;  \r\n   \r\npublic String getName(){  \r\nreturn name;  \r\n}  \r\npublic void setName(String name){  \r\nthis.name=name  \r\n}  \r\n}  \r\n//save as Test.java  \r\npackage com.javatpoint;  \r\nclass Test{  \r\npublic static void main(String[] args){  \r\nStudent s=new Student();  \r\ns.setname("vijay");  \r\nSystem.out.println(s.getName());  \r\n}  \r\n}  ', 0, 0);
INSERT INTO `notes` (`notesid`, `uid`, `topic`, `content`, `code`, `likes`, `nlevel`) VALUES
(67, 2, 'Object class in Java', 'The Object class is the parent class of all the classes in java bydefault. In other words, it is the topmost class of java.\r\n\r\nThe Object class is beneficial if you want to refer any object whose type you don''t know. Notice that parent class reference variable can refer the child class object, know as upcasting.\r\n\r\nLet''s take an example, there is getObject() method that returns an object but it can be of any type like Employee,Student etc, we can use Object class reference to refer that object. For example:\r\n\r\nObject obj=getObject();//we don''t what object would be returned from this method  \r\nThe Object class provides some common behaviours to all the objects such as object can be compared, object can be cloned, object can be notified etc.', '1. public final ClassgetClass()	\r\n\r\nreturns the Class class object of this object. The Class class can further be used to get the metadata of this class.\r\n\r\n2. public int hashCode()	\r\nreturns the hashcode number for this object.\r\n\r\n3. public boolean equals(Object obj)	compares the given object to this object.\r\n\r\n4. protected Object clone() throws CloneNotSupportedException	\r\ncreates and returns the exact copy (clone) of this object.\r\n\r\n5. public String toString()	\r\nreturns the string representation of this object.\r\n\r\n6. public final void notify()	\r\nwakes up single thread, waiting on this object''s monitor.\r\n\r\n7. public final void notifyAll()	wakes up all the threads, waiting on this object''s monitor.\r\n\r\n8. public final void wait(long timeout)throws InterruptedException	causes the current thread to wait for the specified milliseconds, until another thread notifies (invokes notify() or notifyAll() method).', 0, 0),
(68, 2, 'Object cloning in java', 'The object cloning is a way to create exact copy of an object. For this purpose, clone() method of Object class is used to clone an object.\r\n\r\nThe java.lang.Cloneable interface must be implemented by the class whose object clone we want to create. If we don''t implement Cloneable interface, clone() method generates CloneNotSupportedException.\r\n\r\nThe clone() method is defined in the Object class. Syntax of the clone() method is as follows:\r\n\r\nprotected Object clone() throws CloneNotSupportedException ', 'class Student18 implements Cloneable{  \r\nint rollno;  \r\nString name;  \r\n  \r\nStudent18(int rollno,String name){  \r\nthis.rollno=rollno;  \r\nthis.name=name;  \r\n}  \r\n  \r\npublic Object clone()throws CloneNotSupportedException{  \r\nreturn super.clone();  \r\n}  \r\n  \r\npublic static void main(String args[]){  \r\ntry{  \r\nStudent18 s1=new Student18(101,"amit");  \r\n  \r\nStudent18 s2=(Student18)s1.clone();  \r\n  \r\nSystem.out.println(s1.rollno+" "+s1.name);  \r\nSystem.out.println(s2.rollno+" "+s2.name);  \r\n  \r\n}catch(CloneNotSupportedException c){}  \r\n  \r\n}  \r\n} ', 0, 0),
(69, 2, 'Java Array', 'class Student18 implements Cloneable{  \r\nint rollno;  \r\nString name;  \r\n  \r\nStudent18(int rollno,String name){  \r\nthis.rollno=rollno;  \r\nthis.name=name;  \r\n}  \r\n  \r\npublic Object clone()throws CloneNotSupportedException{  \r\nreturn super.clone();  \r\n}  \r\n  \r\npublic static void main(String args[]){  \r\ntry{  \r\nStudent18 s1=new Student18(101,"amit");  \r\n  \r\nStudent18 s2=(Student18)s1.clone();  \r\n  \r\nSystem.out.println(s1.rollno+" "+s1.name);  \r\nSystem.out.println(s2.rollno+" "+s2.name);  \r\n  \r\n}catch(CloneNotSupportedException c){}  \r\n  \r\n}  \r\n} \r\n\r\nSyntax to Declare an Array in java\r\n\r\ndataType[] arr; (or)  \r\ndataType []arr; (or)  \r\ndataType arr[];  \r\nInstantiation of an Array in java\r\n\r\narrayRefVar=new datatype[size];  ', 'class Testarray{  \r\npublic static void main(String args[]){  \r\n  \r\nint a[]=new int[5];//declaration and instantiation  \r\na[0]=10;//initialization  \r\na[1]=20;  \r\na[2]=70;  \r\na[3]=40;  \r\na[4]=50;  \r\n  \r\n//printing array  \r\nfor(int i=0;i<a.length;i++)//length is the property of array  \r\nSystem.out.println(a[i]);  \r\n  \r\n}} ', 0, 0),
(70, 2, 'Passing array to method in java', 'We can pass the java array to method so that we can reuse the same logic on any array.\r\n\r\nLet''s see the simple example to get minimum number of an array using method.', 'class Testarray2{  \r\nstatic void min(int arr[]){  \r\nint min=arr[0];  \r\nfor(int i=1;i<arr.length;i++)  \r\n if(min>arr[i])  \r\n  min=arr[i];  \r\n  \r\nSystem.out.println(min);  \r\n}  \r\n  \r\npublic static void main(String args[]){  \r\n  \r\nint a[]={33,3,4,5};  \r\nmin(a);//passing array to method  \r\n  \r\n}} ', 0, 0),
(71, 2, 'Multidimensional array in java\r\n', 'In such case, data is stored in row and column based index (also known as matrix form).\r\n\r\nSyntax to Declare Multidimensional Array in java\r\n\r\ndataType[][] arrayRefVar; (or)  \r\ndataType [][]arrayRefVar; (or)  \r\ndataType arrayRefVar[][]; (or)  \r\ndataType []arrayRefVar[];   \r\nExample to instantiate Multidimensional Array in java\r\n\r\nint[][] arr=new int[3][3];//3 row and 3 column  \r\nExample to initialize Multidimensional Array in java\r\n\r\narr[0][0]=1;  \r\narr[0][1]=2;  \r\narr[0][2]=3;  \r\narr[1][0]=4;  \r\narr[1][1]=5;  \r\narr[1][2]=6;  \r\narr[2][0]=7;  \r\narr[2][1]=8;  \r\narr[2][2]=9;  ', 'class Testarray3{  \r\npublic static void main(String args[]){  \r\n  \r\n//declaring and initializing 2D array  \r\nint arr[][]={{1,2,3},{2,4,5},{4,4,5}};  \r\n  \r\n//printing 2D array  \r\nfor(int i=0;i<3;i++){  \r\n for(int j=0;j<3;j++){  \r\n   System.out.print(arr[i][j]+" ");  \r\n }  \r\n System.out.println();  \r\n}  \r\n  \r\n}} ', 0, 0),
(72, 2, 'class name of java array', 'In java, array is an object. For array object, an proxy class is created whose name can be obtained by getClass().getName() method on the object.', 'class Testarray4{  \r\npublic static void main(String args[]){  \r\n  \r\nint arr[]={4,4,5};  \r\n  \r\nClass c=arr.getClass();  \r\nString name=c.getName();  \r\n  \r\nSystem.out.println(name);  \r\n  \r\n}} ', 0, 0),
(73, 2, 'Wrapper class in Java', 'Wrapper class in java provides the mechanism to convert primitive into object and object into primitive.\r\n\r\nSince J2SE 5.0, autoboxing and unboxing feature converts primitive into object and object into primitive automatically. The automatic conversion of primitive into object is known and autoboxing and vice-versa unboxing.', 'Wrapper class Example: Primitive to Wrapper\r\n\r\npublic class WrapperExample1{  \r\npublic static void main(String args[]){  \r\n//Converting int into Integer  \r\nint a=20;  \r\nInteger i=Integer.valueOf(a);//converting int into Integer  \r\nInteger j=a;//autoboxing, now compiler will write Integer.valueOf(a) internally  \r\n  \r\nSystem.out.println(a+" "+i+" "+j);  \r\n}}  \r\nOutput:\r\n\r\n20 20 20\r\nWrapper class Example: Wrapper to Primitive\r\n\r\npublic class WrapperExample2{    \r\npublic static void main(String args[]){    \r\n//Converting Integer to int    \r\nInteger a=new Integer(3);    \r\nint i=a.intValue();//converting Integer to int  \r\nint j=a;//unboxing, now compiler will write a.intValue() internally    \r\n    \r\nSystem.out.println(a+" "+i+" "+j);    \r\n}}    \r\nOutput:\r\n\r\n3 3 3', 0, 0),
(74, 2, 'Call by Value and Call by Reference in Java', 'There is only call by value in java, not call by reference. If we call a method passing a value, it is known as call by value. The changes being done in the called method, is not affected in the calling method.', 'Example of call by value in java\r\n\r\nIn case of call by value original value is not changed. Let''s take a simple example:\r\nclass Operation{  \r\n int data=50;  \r\n  \r\n void change(int data){  \r\n data=data+100;//changes will be in the local variable only  \r\n }  \r\n     \r\n public static void main(String args[]){  \r\n   Operation op=new Operation();  \r\n  \r\n   System.out.println("before change "+op.data);  \r\n   op.change(500);  \r\n   System.out.println("after change "+op.data);  \r\n  \r\n }  \r\n}', 0, 0),
(75, 2, 'Java Strictfp Keyword', 'Java strictfp keyword ensures that you will get the same result on every platform if you perform operations in the floating-point variable. The precision may differ from platform to platform that is why java programming language have provided the strictfp keyword, so that you get same result on every platform. So, now you have better control over the floating-point arithmetic.', 'The strictfp keyword can be applied on methods, classes and interfaces.\r\n\r\nstrictfp class A{}//strictfp applied on class  \r\nstrictfp interface M{}//strictfp applied on interface  \r\nclass A{  \r\nstrictfp void m(){}//strictfp applied on method  \r\n} ', 0, 0),
(76, 2, 'Creating API Document | javadoc tool\r\n', 'We can create document api in java by the help of javadoc tool. In the java file, we must use the documentation comment /**... */ to post information for the class, method, constructor, fields etc.', 'package com.abc;  \r\n/** This class is a user-defined class that contains one methods cube.*/  \r\npublic class M{  \r\n  \r\n/** The cube method prints cube of the given number */  \r\npublic static void  cube(int n){System.out.println(n*n*n);}  \r\n} ', 0, 0),
(77, 0, 'Java Command Line Arguments', 'The java command-line argument is an argument i.e. passed at the time of running the java program.\r\n\r\nThe arguments passed from the console can be received in the java program and it can be used as an input.\r\n\r\nSo, it provides a convenient way to check the behavior of the program for the different values. You can pass N (1,2,3 and so on) numbers of arguments from the command prompt.', 'Simple example of command-line argument in java\r\n\r\nIn this example, we are receiving only one argument and printing it. To run this java program, you must pass at least one argument from the command prompt.\r\nclass CommandLineExample{  \r\npublic static void main(String args[]){  \r\nSystem.out.println("Your first argument is: "+args[0]);  \r\n}  \r\n}  \r\ncompile by > javac CommandLineExample.java  \r\nrun by > java CommandLineExample sonoo  \r\nOutput: Your first argument is: sonoo', 0, 0),
(78, 0, 'Difference between object and class', 'Object:\r\n1)	Object is an instance of a class.\r\n2)	Object is a real world entity such as pen, laptop, mobile, bed, keyboard, mouse, chair etc.\r\n3)	Object is a physical entity.\r\n4)	Object is created through new keyword mainly e.g.\r\nStudent s1=new Student();\r\n5)	Object is created many times as per requirement.\r\n6)	Object allocates memory when it is created.\r\n7)	There are many ways to create object in java such as new keyword, newInstance() method, clone() method, factory method and deserialization.\r\n\r\nClass:\r\n1. Class is a blueprint or template from which objects are created.\r\n2. Class is a group of similar objects.\r\n3. Class is a logical entity.\r\n4. Class is declared using class keyword e.g. class Student{}\r\n5. Class is declared once.\r\n6. Class doesn''t allocated memory when it is created.\r\n7. There is only one way to define class in java using class keyword.\r\n', '', 0, 0),
(79, 0, 'Difference between method overloading and method overriding in java', 'Method overloading:\r\n1)	Method overloading is used to increase the readability of the program.\r\n2)	Method overloading is performed within class.\r\n3)	In case of method overloading, parameter must be different.\r\n4)	Method overloading is the example of compile time polymorphism.\r\n5)	In java, method overloading can''t be performed by changing return type of the method only. Return type can be same or different in method overloading. But you must have to change the parameter.\r\n\r\nMethod overriding:\r\n1. Method overriding is used to provide the specific implementation of the method that is already provided by its super class.\r\n2. Method overriding occurs in two classes that have IS-A (inheritance) relationship.\r\n3. In case of method overriding, parameter must be same.\r\n4. Method overriding is the example of run time polymorphism.\r\n5. Return type must be same or covariant in method overriding.', 'Java Method Overloading example\r\n\r\nclass OverloadingExample{  \r\nstatic int add(int a,int b){return a+b;}  \r\nstatic int add(int a,int b,int c){return a+b+c;}  \r\n}  \r\nJava Method Overriding example\r\n\r\nclass Animal{  \r\nvoid eat(){System.out.println("eating...");}  \r\n}  \r\nclass Dog extends Animal{  \r\nvoid eat(){System.out.println("eating bread...");}  \r\n}  ', 0, 0),
(80, 0, 'Java String', 'ava String provides a lot of concepts that can be performed on a string such as compare, concat, equals, split, length, replace, compareTo, intern, substring etc.\r\n\r\nIn java, string is basically an object that represents sequence of char values.\r\n\r\nAn array of characters works same as java string. For example:\r\n\r\nchar[] ch={''j'',''a'',''v'',''a'',''t'',''p'',''o'',''i'',''n'',''t''};  \r\nString s=new String(ch);  \r\nis same as:\r\n\r\nString s="javatpoint";  \r\nThe java.lang.String class implements Serializable, Comparable and CharSequence interfaces.\r\n\r\nThe java String is immutable i.e. it cannot be changed but a new instance is created. For mutable class, you can use StringBuffer and StringBuilder class.\r\n\r\nWe will discuss about immutable string later. Let''s first understand what is string in java and how to create the string object.', 'public class StringExample{  \r\npublic static void main(String args[]){  \r\nString s1="java";//creating string by java string literal  \r\n  \r\nchar ch[]={''s'',''t'',''r'',''i'',''n'',''g'',''s''};  \r\nString s2=new String(ch);//converting char array to string  \r\n  \r\nString s3=new String("example");//creating java string by new keyword  \r\n  \r\nSystem.out.println(s1);  \r\nSystem.out.println(s2);  \r\nSystem.out.println(s3);  \r\n}}  ', 0, 0),
(81, 2, 'Java String class methods', 'Method:\r\n1	char charAt(int index)\r\nreturns char value for the particular index\r\n\r\n2	int length()	\r\nreturns string length\r\n\r\n3	static String format(String format, Object... args)	\r\nreturns formatted string\r\n\r\n4	static String format(Locale l, String format, Object... args)	\r\nreturns formatted string with given locale\r\n\r\n5	String substring(int beginIndex)	returns substring for given begin index\r\n\r\n6	String substring(int beginIndex, int endIndex)	\r\nreturns substring for given begin index and end index', '', 0, 0),
(82, 2, 'Immutable String in Java', 'In java, string objects are immutable. Immutable simply means unmodifiable or unchangeable.\r\n\r\nOnce string object is created its data or state can''t be changed but a new string object is created.', 'class Testimmutablestring{  \r\n public static void main(String args[]){  \r\n   String s="Sachin";  \r\n   s.concat(" Tendulkar");//concat() method appends the string at the end  \r\n   System.out.println(s);//will print Sachin because strings are immutable objects  \r\n }  \r\n}  ', 0, 0),
(83, 0, 'Java String compare', 'We can compare string in java on the basis of content and reference.\r\n\r\nIt is used in authentication (by equals() method), sorting (by compareTo() method), reference matching (by == operator) etc.\r\n\r\nThere are three ways to compare string in java:\r\n\r\nBy equals() method\r\nBy = = operator\r\nBy compareTo() method', 'class Teststringcomparison1{  \r\n public static void main(String args[]){  \r\n   String s1="Sachin";  \r\n   String s2="Sachin";  \r\n   String s3=new String("Sachin");  \r\n   String s4="Saurav";  \r\n   System.out.println(s1.equals(s2));//true  \r\n   System.out.println(s1.equals(s3));//true  \r\n   System.out.println(s1.equals(s4));//false  \r\n }  \r\n}', 0, 0),
(84, 2, 'String compare by equals() method', 'The String equals() method compares the original content of the string. It compares values of string for equality. String class provides two methods:\r\n\r\npublic boolean equals(Object another) compares this string to the specified object.\r\npublic boolean equalsIgnoreCase(String another) compares this String to another string, ignoring case.', 'class Teststringcomparison1{  \r\n public static void main(String args[]){  \r\n   String s1="Sachin";  \r\n   String s2="Sachin";  \r\n   String s3=new String("Sachin");  \r\n   String s4="Saurav";  \r\n   System.out.println(s1.equals(s2));//true  \r\n   System.out.println(s1.equals(s3));//true  \r\n   System.out.println(s1.equals(s4));//false  \r\n }  \r\n}  ', 0, 0),
(85, 2, 'String compare by == operator', 'The = = operator compares references not values.', 'class Teststringcomparison3{  \r\n public static void main(String args[]){  \r\n   String s1="Sachin";  \r\n   String s2="Sachin";  \r\n   String s3=new String("Sachin");  \r\n   System.out.println(s1==s2);//true (because both refer to same instance)  \r\n   System.out.println(s1==s3);//false(because s3 refers to instance created in nonpool)  \r\n }  \r\n}  ', 0, 0),
(86, 2, 'String compare by compareTo() method', 'The String compareTo() method compares values lexicographically and returns an integer value that describes if first string is less than, equal to or greater than second string.\r\n\r\nSuppose s1 and s2 are two string variables. If:\r\n\r\ns1 == s2 :0\r\ns1 > s2   :positive value\r\ns1 < s2   :negative value', 'class Teststringcomparison4{  \r\n public static void main(String args[]){  \r\n   String s1="Sachin";  \r\n   String s2="Sachin";  \r\n   String s3="Ratan";  \r\n   System.out.println(s1.compareTo(s2));//0  \r\n   System.out.println(s1.compareTo(s3));//1(because s1>s3)  \r\n   System.out.println(s3.compareTo(s1));//-1(because s3 < s1 )  \r\n }  \r\n} ', 0, 0),
(87, 0, 'String Concatenation in Java', 'Java string concatenation operator (+) is used to add strings', 'class TestStringConcatenation1{  \r\n public static void main(String args[]){  \r\n   String s="Sachin"+" Tendulkar";  \r\n   System.out.println(s);//Sachin Tendulkar  \r\n }  \r\n}  ', 0, 0),
(88, 2, 'String Concatenation by concat() method', 'The String concat() method concatenates the specified string to the end of current string. Syntax:\r\n\r\npublic String concat(String another)  ', 'class TestStringConcatenation3{  \r\n public static void main(String args[]){  \r\n   String s1="Sachin ";  \r\n   String s2="Tendulkar";  \r\n   String s3=s1.concat(s2);  \r\n   System.out.println(s3);//Sachin Tendulkar  \r\n  }  \r\n}', 0, 0),
(89, 2, 'Substring in Java', 'A part of string is called substring. In other words, substring is a subset of another string. In case of substring startIndex is inclusive and endIndex is exclusive.\r\n\r\nNote: Index starts from 0.\r\n\r\nYou can get substring from the given string object by one of the two methods:\r\n\r\npublic String substring(int startIndex): This method returns new String object containing the substring of the given string from specified startIndex (inclusive).\r\npublic String substring(int startIndex, int endIndex): This method returns new String object containing the substring of the given string from specified startIndex to endIndex.\r\nIn case of string:\r\n\r\nstartIndex: inclusive\r\nendIndex: exclusive', 'public class TestSubstring{  \r\n public static void main(String args[]){  \r\n   String s="Sachin Tendulkar";  \r\n   System.out.println(s.substring(6));//Tendulkar  \r\n   System.out.println(s.substring(0,6));//Sachin  \r\n }  \r\n}  ', 0, 0),
(90, 2, 'Java String class methods', 'The java.lang.String class provides a lot of methods to work on string. By the help of these methods, we can perform operations on string such as trimming, concatenating, converting, comparing, replacing strings etc.\r\n\r\nJava String is a powerful concept because everything is treated as a string if you submit any form in window based, web based or mobile application.\r\n\r\nLet''s see the important methods of String class.\r\n\r\nJava String toUpperCase() and toLowerCase() method\r\n\r\nThe java string toUpperCase() method converts this string into uppercase letter and string toLowerCase() method into lowercase letter.', 'String s="Sachin";  \r\nSystem.out.println(s.toUpperCase());//SACHIN  \r\nSystem.out.println(s.toLowerCase());//sachin  \r\nSystem.out.println(s);//Sachin(no change in original)  ', 0, 0),
(91, 0, 'Java String trim() method', 'The string trim() method eliminates white spaces before and after string.', 'String s="  Sachin  ";  \r\nSystem.out.println(s);//  Sachin    \r\nSystem.out.println(s.trim());//Sachin  ', 0, 0),
(92, 2, 'Java String charAt() method', 'The string charAt() method returns a character at specified index.', 'String s="Sachin";  \r\nSystem.out.println(s.charAt(0));//S  \r\nSystem.out.println(s.charAt(3));//h  ', 0, 0),
(93, 2, 'Java StringBuffer class', 'Java StringBuffer class is used to created mutable (modifiable) string. The StringBuffer class in java is same as String class except it is mutable i.e. it can be changed.\r\n\r\nImportant Constructors of StringBuffer class\r\n\r\nStringBuffer(): creates an empty string buffer with the initial capacity of 16.\r\nStringBuffer(String str): creates a string buffer with the specified string.\r\nStringBuffer(int capacity): creates an empty string buffer with the specified capacity as length.\r\n\r\n\r\nImportant methods of StringBuffer class\r\n\r\npublic synchronized StringBuffer append(String s): is used to append the specified string with this string. The append() method is overloaded like append(char), append(boolean), append(int), append(float), append(double) etc.\r\npublic synchronized StringBuffer insert(int offset, String s): is used to insert the specified string with this string at the specified position. The insert() method is overloaded like insert(int, char), insert(int, boolean), insert(int, int), insert(int, float), insert(int, double) etc.\r\npublic synchronized StringBuffer replace(int startIndex, int endIndex, String str): is used to replace the string from specified startIndex and endIndex.\r\npublic synchronized StringBuffer delete(int startIndex, int endIndex): is used to delete the string from specified startIndex and endIndex.\r\npublic synchronized StringBuffer reverse(): is used to reverse the string.\r\npublic int capacity(): is used to return the current capacity.\r\npublic void ensureCapacity(int minimumCapacity): is used to ensure the capacity at least equal to the given minimum.\r\npublic char charAt(int index): is used to return the character at the specified position.\r\npublic int length(): is used to return the length of the string i.e. total number of characters.\r\npublic String substring(int beginIndex): is used to return the substring from the specified beginIndex.\r\npublic String substring(int beginIndex, int endIndex): is used to return the substring from the specified beginIndex and endIndex.\r\n\r\n', '', 0, 0),
(94, 2, 'Java StringBuilder class', 'Java StringBuilder class is used to create mutable (modifiable) string. The Java StringBuilder class is same as StringBuffer class except that it is non-synchronized. It is available since JDK 1.5.\r\n\r\nImportant Constructors of StringBuilder class\r\n\r\nStringBuilder(): creates an empty string Builder with the initial capacity of 16.\r\nStringBuilder(String str): creates a string Builder with the specified string.\r\nStringBuilder(int length): creates an empty string Builder with the specified capacity as length.', '1) StringBuilder append() method\r\n\r\nThe StringBuilder append() method concatenates the given argument with this string.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder("Hello ");  \r\nsb.append("Java");//now original string is changed  \r\nSystem.out.println(sb);//prints Hello Java  \r\n}  \r\n}  \r\n2) StringBuilder insert() method\r\n\r\nThe StringBuilder insert() method inserts the given string with this string at the given position.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder("Hello ");  \r\nsb.insert(1,"Java");//now original string is changed  \r\nSystem.out.println(sb);//prints HJavaello  \r\n}  \r\n}  \r\n3) StringBuilder replace() method\r\n\r\nThe StringBuilder replace() method replaces the given string from the specified beginIndex and endIndex.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder("Hello");  \r\nsb.replace(1,3,"Java");  \r\nSystem.out.println(sb);//prints HJavalo  \r\n}  \r\n}  \r\n4) StringBuilder delete() method\r\n\r\nThe delete() method of StringBuilder class deletes the string from the specified beginIndex to endIndex.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder("Hello");  \r\nsb.delete(1,3);  \r\nSystem.out.println(sb);//prints Hlo  \r\n}  \r\n}  \r\n5) StringBuilder reverse() method\r\n\r\nThe reverse() method of StringBuilder class reverses the current string.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder("Hello");  \r\nsb.reverse();  \r\nSystem.out.println(sb);//prints olleH  \r\n}  \r\n}  \r\n6) StringBuilder capacity() method\r\n\r\nThe capacity() method of StringBuilder class returns the current capacity of the Builder. The default capacity of the Builder is 16. If the number of character increases from its current capacity, it increases the capacity by (oldcapacity*2)+2. For example if your current capacity is 16, it will be (16*2)+2=34.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder();  \r\nSystem.out.println(sb.capacity());//default 16  \r\nsb.append("Hello");  \r\nSystem.out.println(sb.capacity());//now 16  \r\nsb.append("java is my favourite language");  \r\nSystem.out.println(sb.capacity());//now (16*2)+2=34 i.e (oldcapacity*2)+2  \r\n}  \r\n}  \r\n7) StringBuilder ensureCapacity() method\r\n\r\nThe ensureCapacity() method of StringBuilder class ensures that the given capacity is the minimum to the current capacity. If it is greater than the current capacity, it increases the capacity by (oldcapacity*2)+2. For example if your current capacity is 16, it will be (16*2)+2=34.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder();  \r\nSystem.out.println(sb.capacity());//default 16  \r\nsb.append("Hello");  \r\nSystem.out.println(sb.capacity());//now 16  \r\nsb.append("java is my favourite language");  \r\nSystem.out.println(sb.capacity());//now (16*2)+2=34 i.e (oldcapacity*2)+2  \r\nsb.ensureCapacity(10);//now no change  \r\nSystem.out.println(sb.capacity());//now 34  \r\nsb.ensureCapacity(50);//now (34*2)+2  \r\nSystem.out.println(sb.capacity());//now 70  \r\n}  \r\n}  ', 0, 0),
(95, 2, 'Performance Test of StringBuffer and StringBuilder', 'Let''s see the code to check the performance of StringBuffer and StringBuilder classes.', 'public class ConcatTest{  \r\n    public static void main(String[] args){  \r\n        long startTime = System.currentTimeMillis();  \r\n        StringBuffer sb = new StringBuffer("Java");  \r\n        for (int i=0; i<10000; i++){  \r\n            sb.append("Tpoint");  \r\n        }  \r\n        System.out.println("Time taken by StringBuffer: " + (System.currentTimeMillis() - startTime) + "ms");  \r\n        startTime = System.currentTimeMillis();  \r\n        StringBuilder sb2 = new StringBuilder("Java");  \r\n        for (int i=0; i<10000; i++){  \r\n            sb2.append("Tpoint");  \r\n        }  \r\n        System.out.println("Time taken by StringBuilder: " + (System.currentTimeMillis() - startTime) + "ms");  \r\n    }  \r\n} \r\n\r\nOutput:\r\nTime taken by StringBuffer: 16ms\r\nTime taken by StringBuilder: 0ms\r\n', 0, 0),
(96, 2, 'Immutable class', 'There are many immutable classes like String, Boolean, Byte, Short, Integer, Long, Float, Double etc. In short, all the wrapper classes and String class is immutable. We can also create immutable class by creating final class that have final data members as the example given below:', 'In this example, we have created a final class named Employee. It have one final datamember, a parameterized constructor and getter method.\r\npublic final class Employee{  \r\nfinal String pancardNumber;  \r\n  \r\npublic Employee(String pancardNumber){  \r\nthis.pancardNumber=pancardNumber;  \r\n}  \r\n  \r\npublic String getPancardNumber(){  \r\nreturn pancardNumber;  \r\n}  \r\n  \r\n}  \r\nThe above class is immutable because:\r\nThe instance variable of the class is final i.e. we cannot change the value of it after creating an object.\r\nThe class is final so we cannot create the subclass.\r\nThere is no setter methods i.e. we have no option to change the value of the instance variable.', 0, 0),
(97, 2, 'StringTokenizer in Java', 'The java.util.StringTokenizer class allows you to break a string into tokens. It is simple way to break string.\r\n\r\nIt doesn''t provide the facility to differentiate numbers, quoted strings, identifiers etc. like StreamTokenizer class. We will discuss about the StreamTokenizer class in I/O chapter.\r\n\r\nConstructors of StringTokenizer class\r\n\r\nThere are 3 constructors defined in the StringTokenizer class.\r\n\r\n1. StringTokenizer(String str)	\r\ncreates StringTokenizer with specified string.\r\n\r\n2. StringTokenizer(String str, String delim)	\r\ncreates StringTokenizer with specified string and delimeter.\r\n\r\n3. StringTokenizer(String str, String delim, boolean returnValue)	\r\ncreates StringTokenizer with specified string, delimeter and returnValue. If return value is true, delimiter characters are considered to be tokens. If it is false, delimiter characters serve to separate tokens.\r\n\r\n', '', 0, 0),
(98, 0, 'Java String charAt', 'The java string charAt() method returns a char value at the given index number. The index number starts from 0.\r\n\r\nSignature\r\n\r\nThe signature of string charAt() method is given below:\r\n\r\npublic char charAt(int index)  \r\nParameter\r\n\r\nindex : index number, starts with 0\r\n\r\nReturns\r\n\r\nchar value\r\n\r\nSpecified by\r\n\r\nCharSequence interface\r\n\r\nThrows\r\n\r\nIndexOutOfBoundsException : if index is negative value or greater than this string length.', 'public class CharAtExample{  \r\npublic static void main(String args[]){  \r\nString name="javatpoint";  \r\nchar ch=name.charAt(4);//returns the char value at the 4th index  \r\nSystem.out.println(ch);  \r\n}} \r\n\r\nOutput:\r\nt', 0, 0),
(99, 2, 'Java String compareTo() method', 'The java string compareTo() method compares the given string with current string lexicographically. It returns positive number, negative number or 0.\r\n\r\nIf first string is greater than second string, it returns positive number (difference of character value). If first string is less than second string, it returns negative number and if first string is equal to second string, it returns 0.\r\n\r\ns1 > s2 => positive number  \r\ns1 < s2 => negative number  \r\ns1 == s2 => 0  \r\nSignature\r\n\r\npublic int compareTo(String anotherString)  \r\nParameters\r\n\r\nanotherString: represents string that is to be compared with current string\r\n\r\nReturns\r\n\r\nan integer value', 'public class LastIndexOfExample{  \r\npublic static void main(String args[]){  \r\nString s1="hello";  \r\nString s2="hello";  \r\nString s3="meklo";  \r\nString s4="hemlo";  \r\nSystem.out.println(s1.compareTo(s2));  \r\nSystem.out.println(s1.compareTo(s3));  \r\nSystem.out.println(s1.compareTo(s4));  \r\n}}  \r\nOutput:\r\n\r\n0\r\n-5\r\n-1', 0, 0),
(100, 0, 'Java String concat', 'The java string concat() method combines specified string at the end of this string. It returns combined string. It is like appending another string.\r\n\r\nSignature\r\n\r\nThe signature of string concat() method is given below:\r\n\r\npublic String concat(String anotherString)  \r\nParameter\r\n\r\nanotherString : another string i.e. to be combined at the end of this string.\r\n\r\nReturns\r\n\r\ncombined string', 'public class ConcatExample{  \r\npublic static void main(String args[]){  \r\nString s1="java string";  \r\ns1.concat("is immutable");  \r\nSystem.out.println(s1);  \r\ns1=s1.concat(" is immutable so assign it explicitly");  \r\nSystem.out.println(s1);  \r\n}} ', 0, 0),
(201, 7, 'private constructor ', 'Used in singleton class. Makes sure that only one object is created for that class.', 'public class SingleTonClass {\r\n   //Static Class Reference\r\n   private static SingleTonClass obj=null;\r\n   private SingleTonClass(){\r\n      /*Private Constructor will prevent \r\n       * the instantiation of this class directly*/\r\n   }\r\n   public static SingleTonClass objectCreationMethod(){\r\n	/*This logic will ensure that no more than\r\n	 * one object can be created at a time */\r\n	if(obj==null){\r\n	    obj= new SingleTonClass();\r\n	}\r\n        return obj;\r\n   }\r\n   public void display(){\r\n	System.out.println("Singleton class Example");\r\n   }\r\n   public static void main(String args[]){\r\n	//Object cannot be created directly due to private constructor \r\n        //This way it is forced to create object via our method where\r\n        //we have logic for only one object creation\r\n	SingleTonClass myobject= SingleTonClass.objectCreationMethod();\r\n	myobject.display();\r\n   }\r\n}', 0, 2),
(202, 80, 'encapsulation', 'hide the private variables from the user and access them using getter and setter methods.', 'public class EncapsulationDemo{\r\n    private int ssn;\r\n    private String empName;\r\n    private int empAge;\r\n\r\n    //Getter and Setter methods\r\n    public int getEmpSSN(){\r\n        return ssn;\r\n    }\r\n\r\n    public String getEmpName(){\r\n        return empName;\r\n    }\r\n}', 0, 0),
(203, 23, 'aggregation', 'instance of one class in another class. Like a Student object having a Has-A relationship with Address object. ', 'class StudentClass\r\n{\r\n   int rollNum;\r\n   String studentName;\r\n   Address studentAddr; \r\n   StudentClass(int roll, String name, Address addr){\r\n       this.rollNum=roll;\r\n       this.studentName=name;\r\n       this.studentAddr = addr;\r\n   }', 0, 1),
(204, 67, 'super', '1) super.<variable_name> refers to the variable of variable of parent class.\r\n2) super() invokes the constructor of immediate parent class.\r\n3) super.<method_name> refers to the method of parent class.', '//Parent class or Superclass\r\nclass Parentclass\r\n{\r\n	int num=100;\r\n}\r\n//Child class or subclass\r\nclass Subclass extends Parentclass\r\n{\r\n    /* I am declaring the same variable \r\n     * num in child class too.\r\n     */\r\n    int num=110;\r\n    void printNumber(){\r\n 	System.out.println(num);\r\n    }\r\n    public static void main(String args[]){\r\n       Subclass obj= new Subclass();\r\n       obj.printNumber();	\r\n    }\r\n}', 0, 1),
(205, 65, 'static variable', 'Static variable’s value is same for all the object(or instances) of the class or in other words you can say that all instances(objects) of the same class share a single copy of static variables.\r\n', 'class VariableDemo\r\n{\r\n   static int count=0;\r\n   public void increment()\r\n   {\r\n       count++;\r\n   }\r\n}', 0, 1),
(207, 30, 'blank final variable', 'Blank final variable\r\n\r\nA final variable that is not initialized at the time of declaration is known as blank final variable. We must initialize the blank final variable in constructor of the class otherwise it will throw a compilation error ', 'class Demo{  \r\n   //Blank final variable\r\n   final int MAX_VALUE;\r\n	 \r\n   Demo(){\r\n      //It must be initialized in constructor\r\n      MAX_VALUE=100;\r\n   }\r\n}', 0, 1),
(208, 23, 'final method\r\n\r\n', 'A final method cannot be overridden. Which means even though a sub class can call the final method of parent class without any issues but it cannot override it.', 'class XYZ{  \r\n   final void demo(){\r\n      System.out.println("XYZ Class Method");\r\n   }  \r\n}  \r\n	     \r\nclass ABC extends XYZ{  \r\n   void demo(){\r\n      System.out.println("ABC Class Method");\r\n   }  \r\n	     \r\n   public static void main(String args[]){  \r\n      ABC obj= new ABC();  \r\n      obj.demo();  \r\n   }  \r\n}', 0, 0),
(209, 77, 'final class\r\n\r\n', 'We cannot extend a final class.', 'final class XYZ{  \r\n}  \r\n	     \r\nclass ABC extends XYZ{  \r\n   void demo(){\r\n      System.out.println("My Method");\r\n   }  \r\n   public static void main(String args[]){  \r\n      ABC obj= new ABC(); \r\n      obj.demo();\r\n   }  \r\n}\r\nOutput:\r\n\r\nThe type ABC cannot subclass the final class XYZ', 0, 1),
(210, 89, 'interfaces', 'Interface looks like class but it is not a class. An interface can have methods and variables just like the class but the methods declared in interface are by default abstract (only method signature, no body). Also, the variables declared in an interface are public, static & final by default.', 'interface MyInterface\r\n{\r\n   /* All the methods are public abstract by default\r\n    * Note down that these methods are not having body\r\n    */\r\n   public void method1();\r\n   public void method2();\r\n}', 0, 2),
(211, 5, 'Multilevel inheritance', 'It’s pretty clear with the diagram that in Multilevel inheritance there is a concept of grand parent class. If we take the example of above diagram then class C inherits class B and class B inherits class A which means B is a parent class of C and A is a parent class of B. So in this case class C is implicitly inheriting the properties and method of class A along with B that’s what is called multilevel inheritance.', 'class Car{\r\n	public Car()\r\n	{\r\n		System.out.println("Class Car");\r\n	}\r\n	public void vehicleType()\r\n	{\r\n		System.out.println("Vehicle Type: Car");\r\n	}\r\n}\r\nclass Maruti extends Car{\r\n	public Maruti()\r\n	{\r\n		System.out.println("Class Maruti");\r\n	}\r\n	public void brand()\r\n	{\r\n		System.out.println("Brand: Maruti");\r\n	}\r\n	public void speed()\r\n	{\r\n		System.out.println("Max: 90Kmph");\r\n	}\r\n}\r\npublic class Maruti800 extends Maruti{\r\n\r\n	 public Maruti800()\r\n	 {\r\n		 System.out.println("Maruti Model: 800");\r\n	 }\r\n	 public void speed()\r\n		{\r\n			System.out.println("Max: 80Kmph");\r\n		}\r\n	 public static void main(String args[])\r\n	 {\r\n		 Maruti800 obj=new Maruti800();\r\n		 obj.vehicleType();\r\n		 obj.brand();\r\n		 obj.speed();\r\n	 }\r\n}\r\nOutput:\r\n\r\nClass Car\r\nClass Maruti\r\nMaruti Model: 800\r\nVehicle Type: Car\r\nBrand: Maruti\r\nMax: 80Kmph', 0, 2),
(212, 78, 'Garbage collection', 'Garbage collection deals with it and its main purpose are to delete all the objects that are either not in use or out of reach. So, all we do through a Java code is that we create objects as per our need and then destroy them when they are no longer in use. This garbage collector is under the control of JVM. Though JVM can be commanded to run the Garbage collector but then there seems no guarantee that actually the Garbage collector will be set out to work. So, the Garbage collector is normally run at the times when the JVM falls short of memory.', '', 0, 2),
(213, 0, 'inner class', 'What is an inner class?\r\n\r\nInner class are defined inside the body of another class (known as outer class). These classes can have access modifier or even can be marked as abstract and final. Inner classes have special relationship with outer class instances. This relationship allows them to have access to outer class members including private members too.', 'class MyOuterClassDemo {\r\n   private int x= 1;\r\n   public void innerInstance()\r\n   {\r\n       MyInnerClassDemo inner = new MyInnerClassDemo();\r\n       inner. seeOuter();\r\n   }\r\n   public static void main(String args[]){\r\n       MyOuterClassDemo obj = new MyOuterClassDemo();\r\n       obj.innerInstance();\r\n   }\r\n   // inner class definition\r\n   class MyInnerClassDemo {\r\n       public void seeOuter () {\r\n          System.out.println("Outer Value of x is :" + x);\r\n       }\r\n   } // close inner class definition	   \r\n} // close Top level class definition\r\nOutput:\r\n\r\nOuter Value of x is :1', 0, 2),
(214, 34, 'oops paradigms', '1)Encapsulation \r\n\r\nBinding the data with the code that manipulates it.\r\nIt keeps the data and the code safe from external interference\r\n\r\n2)Inheritance\r\n\r\nInheritance is the mechanism by which an object acquires the some/all properties of another object.\r\nIt supports the concept of hierarchical classification.\r\n\r\n3)Polymorphism\r\nPolymorphism means to process objects differently based on their data type.\r\nIn other words it means, one method with multiple implementation, for a certain class of action. And which implementation to be used is decided at runtime depending upon the situation (i.e., data type of the object)\r\nThis can be implemented by designing a generic interface, which provides generic methods for a certain class of action and there can be multiple classes, which provides the implementation of these generic methods.\r\n\r\n', '', 0, 0),
(215, 9, ' Static Nested Classes\r\n\r\n', 'A static nested classes are the inner classes marked with static modifier.Because this is static in nature so this type of inner class doesn’t share any special kind of relationship with an instance of outer class.A static nested class cannot access non static members of outer class.', 'class Outer{\r\n   static class Nested{}\r\n}\r\n//A static nested class can be //instantiated like this:\r\n\r\nclass Outer{// outer class\r\n   static class Nested{}// static nested class\r\n}\r\n\r\nclass Demo{\r\n   public static void main(string[] args){\r\n      // use both class names\r\n      Outer.Nested n= new Outer.Nested();\r\n   }\r\n}', 0, 1),
(216, 56, 'Hierarchical inheritance', 'As you can see in the above diagram that when a class has more than one child classes (sub classes) or in other words more than one child classes have the same parent class then such kind of inheritance is known as hierarchical.', 'Class A\r\n{\r\n  public void methodA()\r\n  {\r\n     System.out.println("method of Class A");\r\n  }\r\n}\r\nClass B extends A\r\n{\r\n  public void methodB()\r\n  {\r\n     System.out.println("method of Class B");\r\n  }\r\n}\r\nClass C extends A\r\n{\r\n public void methodC()\r\n {\r\n System.out.println("method of Class C");\r\n }\r\n}\r\nClass D extends A\r\n{\r\n  public void methodD()\r\n  {\r\n     System.out.println("method of Class D");\r\n  }\r\n}\r\nClass MyClass\r\n{\r\n  public void methodB()\r\n  {\r\n     System.out.println("method of Class B");\r\n  }\r\n  public static void main(String args[])\r\n  {\r\n     B obj1 = new B();\r\n     C obj2 = new C();\r\n     D obj3 = new D();\r\n     obj1.methodA();\r\n     obj2.methodA();\r\n     obj3.methodA();\r\n  }\r\n}', 0, 2),
(217, 36, 'packages', 'Packages in Java is a mechanism to encapsulate a group of classes, interfaces and sub packages. Many implementations of Java use a hierarchical file system to manage source and class files. It is easy to organize class files into packages. All we need to do is put related class files in the same directory, give the directory a name that relates to the purpose of the classes, and add a line to the top of each class file that declares the package name, which is the same as the directory name where they reside.', '', 0, 2),
(218, 90, 'Constructor overloading', 'Constructor overloading is way of having more than one constructor which does different-2 tasks. For e.g. Vector class has 4 types of constructors. If you do not want to specify the initial capacity and capacity increment then you can simply use default constructor of Vector class like this Vector v = new Vector(); however if you need to specify the capacity and increment then you call the parameterized constructor with two int args like this: Vector v= new Vector(10, 5);', 'public class StudentData\r\n{\r\n   private int stuID;\r\n   private String stuName;\r\n   private int stuAge;\r\n   StudentData()\r\n   {\r\n       //Default constructor\r\n       stuID = 100;\r\n       stuName = "New Student";\r\n       stuAge = 18;\r\n   }\r\n   StudentData(int num1, String str, int num2)\r\n   {\r\n       //Parameterized constructor\r\n       stuID = num1;\r\n       stuName = str;\r\n       stuAge = num2;\r\n   }\r\n   //Getter and setter methods\r\n   public int getStuID() {\r\n       return stuID;\r\n   }\r\n   public void setStuID(int stuID) {\r\n       this.stuID = stuID;\r\n   }\r\n   public String getStuName() {\r\n       return stuName;\r\n   }\r\n   public void setStuName(String stuName) {\r\n       this.stuName = stuName;\r\n   }\r\n   public int getStuAge() {\r\n       return stuAge;\r\n   }\r\n   public void setStuAge(int stuAge) {\r\n       this.stuAge = stuAge;\r\n   }\r\n}\r\n\r\nclass TestOverloading\r\n{\r\n   public static void main(String args[])\r\n   {\r\n       //This object creation would call the default constructor\r\n       StudentData myobj = new StudentData();\r\n       System.out.println("Student Name is: "+myobj.getStuName());\r\n       System.out.println("Student Age is: "+myobj.getStuAge());\r\n       System.out.println("Student ID is: "+myobj.getStuID());\r\n\r\n       /*This object creation would call the parameterized\r\n        * constructor StudentData(int, String, int)*/\r\n       StudentData myobj2 = new StudentData(555, "Chaitanya", 25);\r\n       System.out.println("Student Name is: "+myobj2.getStuName());\r\n       System.out.println("Student Age is: "+myobj2.getStuAge());\r\n       System.out.println("Student ID is: "+myobj2.getStuID()); \r\n  }\r\n}', 0, 1),
(219, 55, 'Enum', 'An enum is a special type of data type which is basically a collection (set) of constants.', 'public enum Directions{\r\n  EAST, \r\n  WEST, \r\n  NORTH, \r\n  SOUTH\r\n}', 0, 0),
(220, 34, 'HashMap', 'HashMap is a Map based collection class that is used for storing Key & value pairs. This class makes no guarantees as to the order of the map. It is similar to the Hashtable class except that it is unsynchronized and permits nulls(null values and null key)', '  /* This is how to declare HashMap */\r\n      HashMap<Integer, String> hmap = new HashMap<Integer, String>();\r\n\r\n      /*Adding elements to HashMap*/\r\n      hmap.put(12, "Chaitanya");\r\n      hmap.put(2, "Rahul");\r\n      hmap.put(7, "Singh");\r\n      hmap.put(49, "Ajeet");\r\n      hmap.put(3, "Anuj");\r\n\r\n      /* Display content using Iterator*/\r\n      Set set = hmap.entrySet();\r\n      Iterator iterator = set.iterator();\r\n      while(iterator.hasNext()) {\r\n         Map.Entry mentry = (Map.Entry)iterator.next();\r\n         System.out.print("key is: "+ mentry.getKey() + " & Value is: ");\r\n         System.out.println(mentry.getValue());\r\n      }\r\n\r\n      /* Get values based on key*/\r\n      String var= hmap.get(2);\r\n      System.out.println("Value at index 2 is: "+var);\r\n\r\n      /* Remove values based on key*/\r\n      hmap.remove(3);\r\n      System.out.println("Map key and values after removal:");\r\n      Set set2 = hmap.entrySet();\r\n      Iterator iterator2 = set2.iterator();\r\n      while(iterator2.hasNext()) {\r\n          Map.Entry mentry2 = (Map.Entry)iterator2.next();\r\n          System.out.print("Key is: "+mentry2.getKey() + " & Value is: ");\r\n          System.out.println(mentry2.getValue());\r\n       }', 0, 2),
(221, 22, 'creating Vector objects', 'Vector implements List Interface. Like ArrayList it also maintains insertion order but it is rarely used in non-thread environment as it is synchronized and due to which it gives poor performance in searching, adding, delete and update of its elements.', '//Method 1:\r\nVector vec = new Vector();\r\n\r\n\r\n//Method 2:\r\n//Syntax: \r\nVector object= new Vector(int initialCapacity)\r\nVector vec = new Vector(3);\r\n//It will create a Vector of initial capacity of 3.\r\n\r\n//Method 3:\r\n//Syntax:\r\nVector object= new vector(int initialcapacity, capacityIncrement)\r\nVector vec= new Vector(4, 6)\r\n/*Here we have provided two arguments. The initial capacity is 4 and capacityIncrement is 6. It means upon insertion of 5th element the size would be 10 (4+6) and on 11th insertion it would be 16(10+6).\r\n*/', 0, 2),
(222, 12, 'Thread creation using runnable', 'One way of creating a thread is to create a class that implements the Runnable interface. We must need to give the definition of run() method.\r\nThis run method is the entry point for the thread and thread will be alive till run method finishes its execution.\r\nOnce the thread is created it will start running when start() method gets called. Basically start() method calls run() method implicitly.', 'class MultithreadingDemo implements Runnable{  \r\n  public void run(){  \r\n    System.out.println("My thread is in running state.");  \r\n  }   \r\n  public static void main(String args[]){  \r\n     MultithreadingDemo obj=new MultithreadingDemo();  \r\n     Thread tobj =new Thread(obj);  \r\n     tobj.start();  \r\n }  \r\n}', 0, 2),
(223, 12, 'Thread creation by extending Thread class', 'This is the second way of creating a thread. Here we need to create a new class that extends the Thread class.\r\nThe class should override the run() method which is the entry point for the new thread as described above.\r\nCall start() method to start the execution of a thread.', 'class MultithreadingDemo extends Thread{  \r\n  public void run(){  \r\n    System.out.println("My thread is in running state.");  \r\n  }   \r\n  public static void main(String args[]){  \r\n     MultithreadingDemo obj=new MultithreadingDemo();   \r\n     obj.start();  \r\n  }  \r\n}', 0, 2);
INSERT INTO `notes` (`notesid`, `uid`, `topic`, `content`, `code`, `likes`, `nlevel`) VALUES
(224, 15, 'Synchronized', 'Multithreading introduces asynchronous behavior to the programs. If a thread is writing some data another thread may be reading the same data at that time. This may bring inconsistency.\r\nWhen two or more threads need access to a shared resource there should be some way that the resource will be used only by one resource at a time. The process to achieve this is called synchronization.\r\nTo implement the synchronous behavior java has synchronous method. Once a thread is inside a synchronized method, no other thread can call any other synchronized method on the same object. All the other threads then wait until the first thread come out of the synchronized block.\r\nWhen we want to synchronize access to objects of a class which was not designed for the multithreaded access and the code of the method which needs to be accessed synchronously is not available with us, in this case we cannot add the synchronized to the appropriate methods. In java we have the solution for this, put the calls to the methods (which needs to be synchronized) defined by this class inside a synchronized block in following manner.', 'Synchronized(object)\r\n{\r\n    // statement to be synchronized\r\n}', 0, 2),
(225, 45, 'execution on JVM', '1) JVM executes Java byte codes\r\n2) Other programming language codes if converted to adequate Java byte code can be executed on JVM\r\n3) JVM is different for different platforms and can also act as a platform itself\r\n4) JVM supports automatic  error handling by  intercepting the errors which can be controlled\r\n5) This feature is useful in platform independency and multi user ability of Java.', '', 0, 0),
(226, 33, 'Compilation of java code', '1) The compiler requires to know the TYPE of every CLASS used in the program source code\r\n2) This is done by setting a default user environment variable CLASSPATH\r\n3) The Javac (Java Compiler) reads the program and converts it into byte code files called as class files', '', 0, 0),
(227, 19, 'for loop', 'It executes a block of statements repeatedly until the specified condition returns false.', 'for (initialization; condition; increment/decrement) {\r\n    statement(s) //block of statements\r\n}', 0, 0),
(228, 24, 'Even or odd number', 'Check whether an entered number is even or odd', 'import java.util.Scanner;\r\n\r\nclass CheckEvenOdd\r\n{\r\n  public static void main(String args[])\r\n  {\r\n    int num;\r\n    System.out.println("Enter an Integer number:");\r\n\r\n    //The input provided by user is stored in num\r\n    Scanner input = new Scanner(System.in);\r\n    num = input.nextInt();\r\n\r\n    /* If number is divisible by 2 then it''s an even number\r\n     * else odd number*/\r\n    if ( num % 2 == 0 )\r\n        System.out.println("Entered number is even");\r\n     else\r\n        System.out.println("Entered number is odd");\r\n  }\r\n}', 0, 0),
(229, 67, 'Exception', 'An Exception can be anything which interrupts the normal flow of the program. When an exception occurs program processing gets terminated and doesn’t continue further. In such cases we get a system generated error message. The good thing about exceptions is that they can be handled. We will cover the handling part later in this same tutorial.\r\n\r\nWhen an exception can occur?\r\nException can occur at runtime (known as runtime exceptions) as well as at compile-time (known Compile-time exceptions).\r\n\r\nReasons for Exceptions\r\nThere can be several reasons for an exception. For example, following situations can cause an exception – Opening a non-existing file, Network connection problem, Operands being manipulated are out of prescribed ranges, class file missing which was supposed to be loaded and so on.', '', 0, 1),
(230, 90, 'try-catch ', 'What is Try Block?\r\n\r\nThe try block contains a block of program statements within which an exception might occur. A try block is always followed by a catch block, which handles the exception that occurs in associated try block. A try block must followed by a Catch block or Finally block or both.\r\n\r\nWhat is Catch Block?\r\n\r\nA catch block must be associated with a try block. The corresponding catch block executes if an exception of a particular type occurs within the try block. For example if an arithmetic exception occurs in try block then the statements enclosed in catch block for arithmetic exception executes.', 'try\r\n{\r\n     //statements that may cause an exception\r\n}\r\ncatch (exception(type) e(object))?\r\n{\r\n     //error handling code\r\n}', 0, 1),
(231, 55, 'Multiple catch blocks ', 'Multiple catch blocks in Java\r\n\r\n1. A try block can have any number of catch blocks.\r\n2. A catch block that is written for catching the class Exception can catch all other exceptions\r\n3. If multiple catch blocks are present in a program then the above mentioned catch block should be placed at the last as per the exception handling best practices.\r\n4. If the try block is not throwing any exception, the catch block will be completely ignored and the program continues.\r\n5. If the try block throws an exception, the appropriate catch block (if one exists) will catch it\r\n–catch(ArithmeticException e) is a catch block that can catch ArithmeticException\r\n–catch(NullPointerException e) is a catch block that can catch NullPointerException\r\n6. All the statements in the catch block will be executed and then the program continues.', 'class Example2{\r\n   public static void main(String args[]){\r\n     try{\r\n         int a[]=new int[7];\r\n         a[4]=30/0;\r\n         System.out.println("First print statement in try block");\r\n     }\r\n     catch(ArithmeticException e){\r\n        System.out.println("Warning: ArithmeticException");\r\n     }\r\n     catch(ArrayIndexOutOfBoundsException e){\r\n        System.out.println("Warning: ArrayIndexOutOfBoundsException");\r\n     }\r\n     catch(Exception e){\r\n        System.out.println("Warning: Some Other exception");\r\n     }\r\n   System.out.println("Out of try-catch block...");\r\n  }\r\n}', 0, 2),
(232, 103, 'Nested try catch', 'The try catch blocks can be nested. One try-catch block can be present in the another try’s body. This is called Nesting of try catch blocks. Each time a try block does not have a catch handler for a particular exception, the stack is unwound and the next try block’s catch (i.e., parent try block’s catch) handlers are inspected for a match.\r\n\r\nIf no catch block matches, then the java run-time system will handle the exception.', '....\r\n//Main try block\r\ntry\r\n{\r\n   statement 1;\r\n   statement 2;\r\n   //try-catch block inside another try block\r\n   try\r\n   {\r\n      statement 3;\r\n      statement 4;\r\n   }\r\n   catch(Exception e1)\r\n   {\r\n       //Exception Message\r\n   }\r\n   //try-catch block inside another try block\r\n   try\r\n   {\r\n       statement 5;\r\n       statement 6;\r\n   }\r\n   catch(Exception e2)\r\n   {\r\n       //Exception Message\r\n   }\r\n}\r\ncatch(Exception e3) //Catch of Main(parent) try block\r\n{\r\n      //Exception Message\r\n}\r\n....', 0, 2),
(233, 255, 'Throws clause', '1. The throws keyword is used in method declaration, in order to explicitly specify the exceptions that a particular method might throw. When a method declaration has one or more exceptions defined using throws clause then the method-call must handle all the defined exceptions.\r\n2. When defining a method you must include a throws clause to declare those exceptions that might be thrown but doesn’t get caught in the method.\r\n3. If a method is using throws clause along with few exceptions then this implicitly tells other methods that – “ If you call me, you must handle these exceptions that I throw”.', 'void MethodName() throws ExceptionName{\r\n    Statement1\r\n    ...\r\n    ...\r\n}', 0, 1),
(234, 234, 'User defined exception', 'User defined exceptions in java are also known as Custom exceptions. Most of the times when we are developing an application in java, we often feel a need to create and throw our own exceptions. These exceptions are known as User defined or Custom exceptions. ', 'lass MyException extends Exception{\r\n    String str1;\r\n    MyException(String str2) {\r\n       str1=str2;\r\n    }\r\n    public String toString(){ \r\n       return ("Output String = "+str1) ;\r\n    }\r\n}\r\n\r\nclass CustomException{\r\n    public static void main(String args[]){\r\n       try{\r\n          throw new MyException("Custom");\r\n          // I''m throwing user defined custom exception above\r\n       }\r\n       catch(MyException exp){\r\n          System.out.println("Hi this is my catch block") ;\r\n          System.out.println(exp) ;\r\n       }\r\n    }\r\n}\r\nOutput:\r\n\r\nHi this is my catch block\r\nOutput String = Custom', 0, 2),
(235, 456, 'Hybrid inheritance', ' that it’s a combine form of single and multiple inheritance. Since java doesn’t support multiple inheritance, the hybrid inheritance is also not possible.\r\n\r\nCase 1:  Using classes: If in above figure B and C are classes then this inheritance is not allowed as a single class cannot extend more than one class (Class D is extending both B and C).\r\n\r\nCase 2: Using Interfaces: If B and C are interfaces then the above hybrid inheritance is allowed as a single class can implement any number of interfaces in java.', 'public class A\r\n{\r\n     public void methodA()\r\n     {\r\n           System.out.println("Class A methodA");\r\n      }\r\n}\r\npublic class B extends A\r\n{\r\n      public void methodA()\r\n      {\r\n           System.out.println("Child class B is overriding inherited method A");\r\n      }\r\n      public void methodB()\r\n      {\r\n           System.out.println("Class B methodB");\r\n       }\r\n}\r\npublic class C extends A\r\n{\r\n      public void methodA()\r\n      {\r\n           System.out.println("Child class C is overriding the methodA");\r\n       }\r\n      public void methodC()\r\n      {\r\n           System.out.println("Class C methodC");\r\n       }\r\n}\r\npublic class D extends B, C\r\n{\r\n      public void methodD()\r\n      {\r\n           System.out.println("Class D methodD");\r\n       }\r\n       public static void main(String args[])\r\n       {\r\n              D obj1= new D();\r\n              obj1.methodD();\r\n              obj1.methodA();\r\n       }\r\n}', 0, 2),
(236, 32, 'testing blah blah blah', 'hello', '', 1, 0);

-- --------------------------------------------------------

--
-- Table structure for table `notesman`
--

CREATE TABLE `notesman` (
  `notesid` int(11) NOT NULL,
  `uid` int(11) NOT NULL,
  `topic` text NOT NULL,
  `content` text NOT NULL,
  `code` text NOT NULL,
  `likes` int(11) NOT NULL,
  `nlevel` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `notesman`
--

INSERT INTO `notesman` (`notesid`, `uid`, `topic`, `content`, `code`, `likes`, `nlevel`) VALUES
(1, 0, 'Loop', 'To write a while-loop, we think about three parts... test -- a boolean test of what should be true before each iteration. Or put another way, the test is the "green light" condition that says that each iteration can go ahead. (The phrase "green light" is a good mnemonic for what the test does.) Eventually, the test should become false and the loop can exit. Think about the precondition that describes the state before each iteration runs -- how are things arranged, what is true? (Also known as an', 'Here''s a while loop example that uses a loop to see how man times you can divide a number by 2: // Given a num, returns how many times can we divide it by 2 to get down to 1. int count2Div(int num) {   int count = 0;   // count how many divisions we''ve done   while (num >= 1) {     num = num / 2;     count++;   }   return count; }', 10, 0),
(2, 0, 'For loop', 'It executes a block of statements repeatedly until the specified condition returns false. or (initialization; condition; increment/decrement) {     statement(s) //block of statements } Mind the semicolon (;) after initialization and condition in the above syntax.  Initialization expression executes only once during the beginning of loop Condition(Boolean Expression) gets evaluated each time the loop iterates. Loop executes the block of statement repeatedly until this condition returns false. Inc', 'class ForLoopExample {     public static void main(String args[]){          for(int i=10; i>1; i--){               System.out.println("The value of i is: "+i);          }     } }', 10, 0),
(3, 0, 'Do-while loop', 'do-while loop is similar to while loop, however there is a single difference between these two. Unlike while loop, do-while guarantees at-least one execution of block of statements. This happens because the do-while loop evaluates the boolean expression at the end of the loopâ€™s body. Therefore the set of statements gets executed at-least once before the check of boolean expression.  Syntax of while loop:  do{     statement(s) //block of statements }while (Boolean expression);', 'class DoWhileLoopExample {     public static void main(String args[]){          int i=10;          do{               System.out.println(i);               i--;          }while(i>1);     } }', 10, 0),
(4, 0, 'Constructor', 'Constructor is a block of code, which runs when you use new keyword in order to instantiate an object. It looks like a method, however it is not a method. Methods have return type but constructors donâ€™t have any return type.  How to call a constructor? The constructor gets called when we create an object of a class (i.e. new keyword followed by class name). For e.g. Demo obj =  new Demo(); (here Demo() is a default constructor of Demo class).  How does it look?  Default constructor: It is also', 'class Demo {      public Demo()      {          System.out.println("This is a default constructor");      } }', 10, 0),
(5, 0, 'Parameterized Constructor', 'Parameterized constructor: Constructor with argument list is known as parameterized constructor.', 'class Demo {       public Demo(int num, String str)       {            System.out.println("This is a parameterized constructor");       } }', 10, 0),
(6, 0, 'Constructor chaining', 'Constructor chaining is nothing but a scenario where in one constructor calls the constructor of its super class implicitly or explicitly. Suppose there is a class which inherits another class, in this case if you create the object of child class then first super class(or parent class) constructor will be invoked and then child class constructor will be invoked.', 'class Human {         String s1, s2;         public Human()         {               s1 ="Super class";               s2 ="Parent class";         }         public Human(String str)         {                s1= str;                s2= str;         } } class Boy extends Human {         public Boy()         {               s2 ="Child class";         }         public void disp()         {                System.out.println("String 1 is: "+s1);                System.out.println("String 2 is: "+s2);    ', 10, 0),
(7, 1, 'Private Constuctor', 'The use of private constructor is to serve singleton classes. A singleton class is one which limits the number of objects creation to one. Using private constructor we can ensure that no more than one object can be created at a time. We will see in the below example how to use private constructor for limiting the number of objects for a singleton class.', 'package beginnersbook.com; public class SingleTonClass {    //Static Class Reference    private static SingleTonClass obj=null;    private SingleTonClass(){       /*Private Constructor will prevent         * the instantiation of this class directly*/    }    public static SingleTonClass objectCreationMethod(){ 	/*This logic will ensure that no more than 	 * one object can be created at a time */ 	if(obj==null){ 	    obj= new SingleTonClass(); 	}         return obj;    }    public void display(){', 15, 0),
(8, 0, 'Static constructor', 'Have you heard of static constructor in Java? I guess yes but the fact is that they are not allowed in Java. A constructor can not be static in Java.  Before I explain the reason letâ€™s have a look at the below piece of code:', 'public class StaticTest {      /* See below - I have marked the constructor as static */      public static StaticTest()      {          System.out.println("Static Constructor of the class");      }      public static void main(String args[])      {          /*Below: I''m trying to create an object of the class          which would intern call the constructor*/          StaticTest obj = new StaticTest();      } }', 10, 0),
(9, 1, 'Constructors no allowed in interface', 'why constructors are not allowed in interface?  As we know that all the methods in interface are public abstract by default which means the method implementation cannot be provided in the interface itself. It has to be provided by the implementing class. Consider the below piece of code.....All the methods of interface doesnâ€™t have body so there is no need to call the methods in the interface itself. In order to call any method we need an object since there is no need to have object of interfa', 'public interface SumInterface{      public int mymethod(int num1, int num2); } public class SumClass implements SumInterface{      public int mymethod(int num1, int num2){            int op= num1+num2;            return op;     }     public static void main(Sring args[])     {            SumClass obj= new SumClass();            System.out.println(obj.mymethod(2, 3)); }', 15, 0),
(10, 1, 'Constructor overloading', 'Constructor overloading is way of having more than one constructor which does different-2 tasks. For e.g. Vector class has 4 types of constructors. If you do not want to specify the initial capacity and capacity increment then you can simply use default constructor of Vector class like this Vector v = new Vector(); however if you need to specify the capacity and increment then you call the parameterized constructor with two int args like this: Vector v= new Vector(10, 5);', 'package beginnersbook.com; public class StudentData {    private int stuID;    private String stuName;    private int stuAge;    StudentData()    {        //Default constructor        stuID = 100;        stuName = "New Student";        stuAge = 18;    }    StudentData(int num1, String str, int num2)    {        //Parameterized constructor        stuID = num1;        stuName = str;        stuAge = num2;    }    //Getter and setter methods    public int getStuID() {        return stuID;    }    pu', 10, 0),
(11, 1, 'Java features', 'There is given many features of java. They are also known as java buzzwords. The Java Features given below are simple and easy to understand.\r\n\r\nSimple\r\nObject-Oriented\r\nPlatform independent\r\nSecured\r\nRobust\r\nArchitecture neutral\r\nPortable\r\nDynamic\r\nInterpreted\r\nHigh Performance', '', 10, 0),
(12, 1, 'object oriented features of java', 'Basic concepts of OOPs are:\r\nObject\r\nClass\r\nInheritance\r\nPolymorphism\r\nAbstraction\r\nEncapsulation\r\n', '', 10, 0),
(13, 1, 'java world program', 'Let''s see what is the meaning of class, public, static, void, main, String[], System.out.println().\r\n\r\nclass keyword is used to declare a class in java.\r\npublic keyword is an access modifier which represents visibility, it means it is visible to all.\r\nstatic is a keyword, if we declare any method as static, it is known as static method. The core advantage of static method is that there is no need to create object to invoke the static method. The main method is executed by the JVM, so it doesn''t require to create object to invoke the main method. So it saves memory.\r\nvoid is the return type of the method, it means it doesn''t return any value.\r\nmain represents startup of the program.\r\nString[] args is used for command line argument. We will learn it later.\r\nSystem.out.println() is used print statement. We will learn about the internal working of System.out.println statement later.', 'class Simple{  \r\n    public static void main(String args[]){  \r\n     System.out.println("Hello Java");  \r\n    }  \r\n}  ', 10, 0),
(14, 1, 'Valid main methods', '', 'public static void main(String[] args)  \r\npublic static void main(String []args)  \r\npublic static void main(String args[])  \r\npublic static void main(String... args)  \r\nstatic public void main(String[] args)  \r\npublic static final void main(String[] args)  \r\nfinal public static void main(String[] args)  \r\nfinal strictfp public static void main(String[] args) ', 10, 0),
(15, 1, 'Setting path in java', 'To set the temporary path of JDK, you need to follow following steps:\r\n\r\nOpen command prompt\r\ncopy the path of jdk/bin directory\r\nwrite in command prompt: set path=copied_path\r\nFor Example:\r\n\r\nset path=C:\\Program Files\\Java\\jdk1.6.0_23\\bin', '', 10, 0),
(16, 1, 'JVM', 'JVM (Java Virtual Machine) is an abstract machine. It is a specification that provides runtime environment in which java bytecode can be executed.\r\nJVMs are available for many hardware and software platforms. JVM, JRE and JDK are platform dependent because configuration of each OS differs. But, Java is platform independent.\r\nThe JVM performs following main tasks:\r\nLoads code\r\nVerifies code\r\nExecutes code\r\nProvides runtime environment', '', 10, 0),
(17, 0, 'JRE', 'JRE\r\n\r\nJRE is an acronym for Java Runtime Environment.It is used to provide runtime environment.It is the implementation of JVM.It physically exists.It contains set of libraries + other files that JVM uses at runtime.\r\nImplementation of JVMs are also actively released by other companies besides Sun Micro Systems.', '', 12, 0),
(18, 0, 'JDK', 'JDK is an acronym for Java Development Kit.It physically exists.It contains JRE + development tools.\r\n', '', 10, 0),
(19, 0, 'Variables', 'Variable is name of reserved area allocated in memory. There are three types of variables in java\r\nlocal variable\r\ninstance variable\r\nstatic variable\r\n\r\nLocal Variable\r\n\r\nA variable that is declared inside the method is called local variable.\r\nInstance Variable\r\n\r\nA variable that is declared inside the class but outside the method is called instance variable . It is not declared as static.\r\nStatic variable\r\n\r\nA variable that is declared as static is called static variable. It cannot be local.\r\n\r\n\r\n', 'class A{  \r\nint data=50;//instance variable  \r\nstatic int m=100;//static variable  \r\nvoid method(){  \r\nint n=90;//local variable  \r\n}  \r\n}//end of class  ', 15, 0),
(20, 0, 'data types', 'Data Types in Java\r\n\r\nIn java, there are two types of data types\r\n1. primitive data types\r\n2. non-primitive data type', '', 10, 0),
(21, 1, 'java operators', 'Operator in java is a symbol that is used to perform operations. There are many types of operators in java such as unary operator, arithmetic operator, relational operator, shift operator, bitwise operator, ternary operator and assignment operator.\r\n\r\nOperator,Precedence\r\npostfix, expr++ expr--\r\nunary, ++expr --expr +expr -expr ~ !\r\nmultiplicative,	* / %\r\nadditive,	+ -\r\nshift,	<< >> >>>\r\nrelational,	< > <= >= instanceof\r\nequality,	== !=\r\nbitwise AND,	&\r\nbitwise exclusive OR,	^\r\nbitwise inclusive OR,	|\r\nlogical AND,	&&\r\nlogical OR,	||\r\nternary	? :,\r\nassignment,	= += -= *= /= %= &= ^= |= <<= >>= >>>=', '', 10, 0),
(22, 1, 'Fibonacci series', 'Input: 10\r\n\r\nOutput: 0 1 1 2 3 5 8 13 21 34', 'class FibonacciExample1{  \r\npublic static void main(String args[])  \r\n{    \r\n int n1=0,n2=1,n3,i,count=10;    \r\n System.out.print(n1+" "+n2);//printing 0 and 1    \r\n    \r\n for(i=2;i<count;++i)//loop starts from 2 because 0 and 1 are already printed    \r\n {    \r\n  n3=n1+n2;    \r\n  System.out.print(" "+n3);    \r\n  n1=n2;    \r\n  n2=n3;    \r\n }    \r\n  \r\n}}  ', 10, 0),
(23, 1, 'Check whether number is prime or not?\r\n', 'Input: 44\r\n\r\nOutput: not prime number\r\n\r\nInput: 7\r\n\r\nOutput: prime number', 'class PrimeExample{  \r\n public static void main(String args[]){  \r\n  int i,m=0,flag=0;    \r\n  int n=17;//it is the number to be checked  \r\n  m=n/2;    \r\n  for(i=2;i<=m;i++){    \r\n   if(n%i==0){    \r\n   System.out.println("Number is not prime");    \r\n   flag=1;    \r\n   break;    \r\n   }    \r\n  }    \r\n  if(flag==0)    \r\n  System.out.println("Number is prime");    \r\n}  \r\n}  ', 10, 0),
(24, 1, 'Palindrome number program', 'Palindrome number algorithm\r\n\r\nGet the number to check for palindrome\r\nHold the number in temporary variable\r\nReverse the number\r\nCompare the temporary number with reversed number\r\nIf both numbers are same, print "palindrome number"\r\nElse print "not palindrome number"\r\n\r\nInput: 329\r\n\r\nOutput: not palindrome number\r\n\r\nInput: 12321\r\n\r\nOutput: palindrome number', 'class PalindromeExample{  \r\n public static void main(String args[]){  \r\n  int r,sum=0,temp;    \r\n  int n=454;//It is the number variable to be checked for palindrome  \r\n  \r\n  temp=n;    \r\n  while(n>0){    \r\n   r=n%10;  //getting remainder  \r\n   sum=(sum*10)+r;    \r\n   n=n/10;    \r\n  }    \r\n  if(temp==sum)    \r\n   System.out.println("palindrome number ");    \r\n  else    \r\n   System.out.println("not palindrome");    \r\n}  \r\n}  ', 10, 0),
(25, 1, 'print factorial of a number.', 'Input: 5\r\n\r\nOutput: 120\r\n\r\nInput: 6\r\n\r\nOutput: 720', 'class FactorialExample{  \r\n public static void main(String args[]){  \r\n  int i,fact=1;  \r\n  int number=5;//It is the number to calculate factorial    \r\n  for(i=1;i<=number;i++){    \r\n      fact=fact*i;    \r\n  }    \r\n  System.out.println("Factorial of "+number+" is: "+fact);    \r\n }  \r\n}  ', 10, 0),
(26, 0, 'Armstrong Number in Java', '153 = (1*1*1)+(5*5*5)+(3*3*3)  \r\nwhere:  \r\n(1*1*1)=1  \r\n(5*5*5)=125  \r\n(3*3*3)=27  \r\nSo:  \r\n1+125+27=153 ', 'class ArmstrongExample{  \r\n  public static void main(String[] args)  {  \r\n    int c=0,a,temp;  \r\n    int n=153;//It is the number to check armstrong  \r\n    temp=n;  \r\n    while(n>0)  \r\n    {  \r\n    a=n%10;  \r\n    n=n/10;  \r\n    c=c+(a*a*a);  \r\n    }  \r\n    if(temp==c)  \r\n    System.out.println("armstrong number");   \r\n    else  \r\n        System.out.println("Not armstrong number");   \r\n   }  \r\n}  ', 15, 0),
(27, 1, 'Bubble sort', 'In bubble sort algorithm, array is traversed from first element to last element. Here, current element is compared with the next element. If current element is greater than the next element, it is swapped.', 'public class BubbleSortExample {  \r\n    static void bubbleSort(int[] arr) {  \r\n        int n = arr.length;  \r\n        int temp = 0;  \r\n         for(int i=0; i < n; i++){  \r\n                 for(int j=1; j < (n-i); j++){  \r\n                          if(arr[j-1] > arr[j]){  \r\n                                 //swap elements  \r\n                                 temp = arr[j-1];  \r\n                                 arr[j-1] = arr[j];  \r\n                                 arr[j] = temp;  \r\n                         }  \r\n                          \r\n                 }  \r\n         }  \r\n  \r\n    }  \r\n    public static void main(String[] args) {  \r\n                int arr[] ={3,60,35,2,45,320,5};  \r\n                 \r\n                System.out.println("Array Before Bubble Sort");  \r\n                for(int i=0; i < arr.length; i++){  \r\n                        System.out.print(arr[i] + " ");  \r\n                }  \r\n                System.out.println();  \r\n                  \r\n                bubbleSort(arr);//sorting array elements using bubble sort  \r\n                 \r\n                System.out.println("Array After Bubble Sort");  \r\n                for(int i=0; i < arr.length; i++){  \r\n                        System.out.print(arr[i] + " ");  \r\n                }  \r\n   \r\n        }  \r\n}  ', 10, 0),
(29, 1, 'objects in java', 'An entity that has state and behavior is known as an object e.g. chair, bike, marker, pen, table, car etc. It can be physical or logical (tengible and intengible). The example of integible object is banking system.\r\n\r\nAn object has three characteristics:\r\n\r\nstate: represents data (value) of an object.\r\nbehavior: represents the behavior (functionality) of an object such as deposit, withdraw etc.\r\nidentity: Object identity is typically implemented via a unique ID. The value of the ID is not visible to the external user. But,it is used internally by the JVM to identify each object uniquely.\r\nFor Example: Pen is an object. Its name is Reynolds, color is white etc. known as its state. It is used to write, so writing is its behavior.\r\nObject is an instance of a class. Class is a template or blueprint from which objects are created. So object is the instance(result) of a class.', 'class Student1{  \r\n int id;//data member (also instance variable)  \r\n String name;//data member(also instance variable)  \r\n  \r\n public static void main(String args[]){  \r\n  Student1 s1=new Student1();//creating an object of Student  \r\n  System.out.println(s1.id);  \r\n  System.out.println(s1.name);  \r\n }  \r\n}  ', 10, 0),
(30, 1, 'Class in java', 'A class is a group of objects that has common properties. It is a template or blueprint from which objects are created.\r\nA class in java can contain:\r\n\r\ndata member\r\nmethod\r\nconstructor\r\nblock\r\nclass and interface\r\n\r\nSyntax to declare a class:\r\n\r\nclass <class_name>{  \r\n    data member;  \r\n    method;  \r\n}  ', 'class Student1{  \r\n int id;//data member (also instance variable)  \r\n String name;//data member(also instance variable)  \r\n  \r\n public static void main(String args[]){  \r\n  Student1 s1=new Student1();//creating an object of Student  \r\n  System.out.println(s1.id);  \r\n  System.out.println(s1.name);  \r\n }  \r\n} ', 10, 0),
(31, 0, 'method overloading (By changing number of arguments)', 'If a class have multiple methods by same name but different parameters, it is known as Method Overloading.\r\n\r\nIf we have to perform only one operation, having same name of the methods increases the readability of the program.\r\n\r\nSuppose you have to perform addition of the given numbers but there can be any number of arguments, if you write the method such as a(int,int) for two parameters, and b(int,int,int) for three parameters then it may be difficult for you as well as other programmers to understand the behaviour of the method because its name differs. So, we perform method overloading to figure out the program quickly.\r\n\r\n', 'class Calculation{  \r\n  void sum(int a,int b){System.out.println(a+b);}  \r\n  void sum(int a,int b,int c){System.out.println(a+b+c);}  \r\n  \r\n  public static void main(String args[]){  \r\n  Calculation obj=new Calculation();  \r\n  obj.sum(10,10,10);  \r\n  obj.sum(20,20);  \r\n  \r\n  }  \r\n}  ', 20, 0),
(32, 1, 'Method Overloading by changing data type of argument', 'In this example, we have created two overloaded methods that differs in data type. The first sum method receives two integer arguments and second sum method receives two double arguments.', 'class Calculation2{  \r\n  void sum(int a,int b){System.out.println(a+b);}  \r\n  void sum(double a,double b){System.out.println(a+b);}  \r\n  \r\n  public static void main(String args[]){  \r\n  Calculation2 obj=new Calculation2();  \r\n  obj.sum(10.5,10.5);  \r\n  obj.sum(20,20);  \r\n  \r\n  }  \r\n}  ', 10, 0),
(34, 1, 'Can we overload main() method?', 'Yes, by method overloading. You can have any number of main methods in a class by method overloading. Let''s see the simple example:', 'class Overloading1{  \r\n  public static void main(int a){  \r\n  System.out.println(a);  \r\n  }  \r\n    \r\n  public static void main(String args[]){  \r\n  System.out.println("main() method invoked");  \r\n  main(10);  \r\n  }  \r\n} ', 10, 0),
(35, 101, 'constructors in java', 'Constructor in java is a special type of method that is used to initialize the object.\r\n\r\nJava constructor is invoked at the time of object creation. It constructs the values i.e. provides data for the object that is why it is known as constructor.\r\n\r\nRules for creating java constructor\r\n\r\nThere are basically two rules defined for the constructor.\r\n\r\nConstructor name must be same as its class name\r\nConstructor must have no explicit return type\r\n\r\nTypes of java constructors\r\n\r\nThere are two types of constructors:\r\n\r\n1. Default constructor (no-arg constructor)\r\n2. Parameterized constructor\r\n\r\nJava Default Constructor\r\n\r\nA constructor that have no parameter is known as default constructor.\r\nSyntax of default constructor:\r\n\r\n<class_name>(){} \r\n\r\n \r\n\r\n', 'Example of default constructor\r\n\r\nIn this example, we are creating the no-arg constructor in the Bike class. It will be invoked at the time of object creation.\r\nclass Bike1{  \r\nBike1(){System.out.println("Bike is created");}  \r\npublic static void main(String args[]){  \r\nBike1 b=new Bike1();  \r\n}  \r\n}  ', 10, 0),
(36, 101, 'parameterized constructor', 'Java parameterized constructor\r\n\r\nA constructor that have parameters is known as parameterized constructor.\r\nWhy use parameterized constructor?\r\n\r\nParameterized constructor is used to provide different values to the distinct objects.', 'Example of parameterized constructor\r\n\r\nIn this example, we have created the constructor of Student class that have two parameters. We can have any number of parameters in the constructor.\r\nclass Student4{  \r\n    int id;  \r\n    String name;  \r\n      \r\n    Student4(int i,String n){  \r\n    id = i;  \r\n    name = n;  \r\n    }  \r\n    void display(){System.out.println(id+" "+name);}  \r\n   \r\n    public static void main(String args[]){  \r\n    Student4 s1 = new Student4(111,"Karan");  \r\n    Student4 s2 = new Student4(222,"Aryan");  \r\n    s1.display();  \r\n    s2.display();  \r\n   }  \r\n}  ', 20, 0),
(37, 101, 'constructor overloading', 'Constructor overloading is a technique in Java in which a class can have any number of constructors that differ in parameter lists.The compiler differentiates these constructors by taking into account the number of parameters in the list and their type.', 'class Student5{  \r\n    int id;  \r\n    String name;  \r\n    int age;  \r\n    Student5(int i,String n){  \r\n    id = i;  \r\n    name = n;  \r\n    }  \r\n    Student5(int i,String n,int a){  \r\n    id = i;  \r\n    name = n;  \r\n    age=a;  \r\n    }  \r\n    void display(){System.out.println(id+" "+name+" "+age);}  \r\n   \r\n    public static void main(String args[]){  \r\n    Student5 s1 = new Student5(111,"Karan");  \r\n    Student5 s2 = new Student5(222,"Aryan",25);  \r\n    s1.display();  \r\n    s2.display();  \r\n   }  \r\n} ', 20, 0),
(38, 1, 'copy constructor', 'There is no copy constructor in java. But, we can copy the values of one object to another like copy constructor in C++.\r\n\r\nThere are many ways to copy the values of one object into another in java. They are:\r\n\r\nBy constructor\r\nBy assigning the values of one object into another\r\nBy clone() method of Object class\r\nIn this example, we are going to copy the values of one object into another using java constructor.', 'class Student6{  \r\n    int id;  \r\n    String name;  \r\n    Student6(int i,String n){  \r\n    id = i;  \r\n    name = n;  \r\n    }  \r\n      \r\n    Student6(Student6 s){  \r\n    id = s.id;  \r\n    name =s.name;  \r\n    }  \r\n    void display(){System.out.println(id+" "+name);}  \r\n   \r\n    public static void main(String args[]){  \r\n    Student6 s1 = new Student6(111,"Karan");  \r\n    Student6 s2 = new Student6(s1);  \r\n    s1.display();  \r\n    s2.display();  \r\n   }  \r\n}  ', 10, 0),
(39, 101, 'static variable', 'If you declare any variable as static, it is known static variable.\r\n\r\nThe static variable can be used to refer the common property of all objects (that is not unique for each object) e.g. company name of employees,college name of students etc.\r\nThe static variable gets memory only once in class area at the time of class loading.\r\nAdvantage of static variable\r\n\r\nIt makes your program memory efficient (i.e it saves memory).', '/Program of static variable  \r\n  \r\nclass Student8{  \r\n   int rollno;  \r\n   String name;  \r\n   static String college ="ITS";  \r\n     \r\n   Student8(int r,String n){  \r\n   rollno = r;  \r\n   name = n;  \r\n   }  \r\n void display (){System.out.println(rollno+" "+name+" "+college);}  \r\n  \r\n public static void main(String args[]){  \r\n Student8 s1 = new Student8(111,"Karan");  \r\n Student8 s2 = new Student8(222,"Aryan");  \r\n   \r\n s1.display();  \r\n s2.display();  \r\n }  \r\n} ', 10, 0),
(40, 101, 'static method', 'If you apply static keyword with any method, it is known as static method.\r\n\r\nA static method belongs to the class rather than object of a class.\r\nA static method can be invoked without the need for creating an instance of a class.\r\nstatic method can access static data member and can change the value of it.', '//Program of changing the common property of all objects(static field).  \r\n  \r\nclass Student9{  \r\n     int rollno;  \r\n     String name;  \r\n     static String college = "ITS";  \r\n       \r\n     static void change(){  \r\n     college = "BBDIT";  \r\n     }  \r\n  \r\n     Student9(int r, String n){  \r\n     rollno = r;  \r\n     name = n;  \r\n     }  \r\n  \r\n     void display (){System.out.println(rollno+" "+name+" "+college);}  \r\n  \r\n    public static void main(String args[]){  \r\n    Student9.change();  \r\n  \r\n    Student9 s1 = new Student9 (111,"Karan");  \r\n    Student9 s2 = new Student9 (222,"Aryan");  \r\n    Student9 s3 = new Student9 (333,"Sonoo");  \r\n  \r\n    s1.display();  \r\n    s2.display();  \r\n    s3.display();  \r\n    }  \r\n}  ', 20, 0),
(41, 1, 'static block', 'Is used to initialize the static data member.\r\nIt is executed before main method at the time of classloading.', 'class A2{  \r\n  static{System.out.println("static block is invoked");}  \r\n  public static void main(String args[]){  \r\n   System.out.println("Hello main");  \r\n  }  \r\n}', 10, 0),
(42, 1, 'this keyword', 'this keyword can be used to refer current class instance variable.\r\nthis() can be used to invoke current class constructor.\r\nthis keyword can be used to invoke current class method (implicitly)\r\nthis can be passed as an argument in the method call.\r\nthis can be passed as argument in the constructor call.\r\nthis keyword can also be used to return the current class instance.', '//example of this keyword  \r\nclass Student11{  \r\n    int id;  \r\n    String name;  \r\n      \r\n    Student11(int id,String name){  \r\n    this.id = id;  \r\n    this.name = name;  \r\n    }  \r\n    void display(){System.out.println(id+" "+name);}  \r\n    public static void main(String args[]){  \r\n    Student11 s1 = new Student11(111,"Karan");  \r\n    Student11 s2 = new Student11(222,"Aryan");  \r\n    s1.display();  \r\n    s2.display();  \r\n}  \r\n}  ', 10, 0),
(43, 101, 'inheritance', 'Inheritance in java is a mechanism in which one object acquires all the properties and behaviors of parent object.\r\n\r\nThe idea behind inheritance in java is that you can create new classes that are built upon existing classes. When you inherit from an existing class, you can reuse methods and fields of parent class, and you can add new methods and fields also.\r\n\r\nInheritance represents the IS-A relationship, also known as parent-child relationship.\r\n\r\nSyntax of Java Inheritance\r\n\r\nclass Subclass-name extends Superclass-name  \r\n{  \r\n   //methods and fields  \r\n}  \r\nThe extends keyword indicates that you are making a new class that derives from an existing class.\r\n\r\nIn the terminology of Java, a class that is inherited is called a super class. The new class is called a subclass.', 'class Employee{  \r\n float salary=40000;  \r\n}  \r\nclass Programmer extends Employee{  \r\n int bonus=10000;  \r\n public static void main(String args[]){  \r\n   Programmer p=new Programmer();  \r\n   System.out.println("Programmer salary is:"+p.salary);  \r\n   System.out.println("Bonus of Programmer is:"+p.bonus);  \r\n}  \r\n}  \r\n\r\nProgrammer is the subclass and Employee is the superclass. Relationship between two classes is Programmer IS-A Employee.It means that Programmer is a type of Employee.', 20, 0),
(44, 1, 'types of inheritance', 'On the basis of class, there can be three types of inheritance in java: single, multilevel and hierarchical.\r\n\r\nIn java programming, multiple and hybrid inheritance is supported through interface only. We will learn about interfaces later.\r\n\r\nNote: Multiple inheritance is not supported in java through class.\r\n\r\nWhen a class extends multiple classes i.e. known as multiple inheritance.', '', 10, 0),
(45, 1, 'Why multiple inheritance not supported in java?', 'To reduce the complexity and simplify the language, multiple inheritance is not supported in java.\r\n\r\nConsider a scenario where A, B and C are three classes. The C class inherits A and B classes. If A and B classes have same method and you call it from child class object, there will be ambiguity to call method of A or B class.\r\n\r\nSince compile time errors are better than runtime errors, java renders compile time error if you inherit 2 classes. So whether you have same method or different, there will be compile time error now.', 'class A{  \r\nvoid msg(){System.out.println("Hello");}  \r\n}  \r\nclass B{  \r\nvoid msg(){System.out.println("Welcome");}  \r\n}  \r\nclass C extends A,B{//suppose if it were  \r\n   \r\n Public Static void main(String args[]){  \r\n   C obj=new C();  \r\n   obj.msg();//Now which msg() method would be invoked?  \r\n}  \r\n} ', 10, 0),
(46, 1, 'Aggregation in java', 'If a class have an entity reference, it is known as Aggregation. Aggregation represents HAS-A relationship.\r\n\r\nConsider a situation, Employee object contains many informations such as id, name, emailId etc. It contains one more object named address, which contains its own informations such as city, state, country, zipcode etc. as given below.\r\n\r\nclass Employee{  \r\nint id;  \r\nString name;  \r\nAddress address;//Address is a class  \r\n...  \r\n} ', 'class Operation{  \r\n int square(int n){  \r\n  return n*n;  \r\n }  \r\n}  \r\n  \r\nclass Circle{  \r\n Operation op;//aggregation  \r\n double pi=3.14;  \r\n    \r\n double area(int radius){  \r\n   op=new Operation();  \r\n   int rsquare=op.square(radius);//code reusability (i.e. delegates the method call).  \r\n   return pi*rsquare;  \r\n }  \r\n  \r\n     \r\n    \r\n public static void main(String args[]){  \r\n   Circle c=new Circle();  \r\n   double result=c.area(5);  \r\n   System.out.println(result);  \r\n }  \r\n} ', 10, 0),
(47, 101, 'Method overriding', 'f subclass (child class) has the same method as declared in the parent class, it is known as method overriding in java.\r\n\r\nIn other words, If subclass provides the specific implementation of the method that has been provided by one of its parent class, it is known as method overriding.\r\n\r\nUsage of Java Method Overriding\r\n\r\nMethod overriding is used to provide specific implementation of a method that is already provided by its super class.\r\nMethod overriding is used for runtime polymorphism\r\nRules for Java Method Overriding\r\n\r\nmethod must have same name as in the parent class\r\nmethod must have same parameter as in the parent class.\r\nmust be IS-A relationship (inheritance).', 'In this example, we have defined the run method in the subclass as defined in the parent class but it has some specific implementation. The name and parameter of the method is same and there is IS-A relationship between the classes, so there is method overriding.\r\n\r\nclass Vehicle{  \r\nvoid run(){System.out.println("Vehicle is running");}  \r\n}  \r\nclass Bike2 extends Vehicle{  \r\nvoid run(){System.out.println("Bike is running safely");}  \r\n  \r\npublic static void main(String args[]){  \r\nBike2 obj = new Bike2();  \r\nobj.run();  \r\n}', 10, 0),
(48, 1, 'covariant return type', 'The covariant return type specifies that the return type may vary in the same direction as the subclass.\r\n\r\nBefore Java5, it was not possible to override any method by changing the return type. But now, since Java5, it is possible to override method by changing the return type if subclass overrides any method whose return type is Non-Primitive but it changes its return type to subclass type. Let''s take a simple example', 'class A{  \r\nA get(){return this;}  \r\n}  \r\n  \r\nclass B1 extends A{  \r\nB1 get(){return this;}  \r\nvoid message(){System.out.println("welcome to covariant return type");}  \r\n  \r\npublic static void main(String args[]){  \r\nnew B1().get().message();  \r\n}  \r\n}  ', 10, 0),
(49, 1, 'super keyword', 'The super keyword in java is a reference variable that is used to refer immediate parent class object.\r\n\r\nWhenever you create the instance of subclass, an instance of parent class is created implicitly i.e. referred by super reference variable.\r\n\r\nUsage of java super Keyword\r\n\r\nsuper is used to refer immediate parent class instance variable.\r\nsuper() is used to invoke immediate parent class constructor.\r\nsuper is used to invoke immediate parent class method.', '/example of super keyword  \r\n  \r\nclass Vehicle{  \r\n  int speed=50;  \r\n}  \r\n  \r\nclass Bike4 extends Vehicle{  \r\n  int speed=100;  \r\n      \r\n  void display(){  \r\n   System.out.println(super.speed);//will print speed of Vehicle now  \r\n  }  \r\n  public static void main(String args[]){  \r\n   Bike4 b=new Bike4();  \r\n   b.display();  \r\n     \r\n}  \r\n}  ', 10, 0),
(50, 101, 'Final variable', 'If you make any variable as final, you cannot change the value of final variable(It will be constant).', 'There is a final variable speedlimit, we are going to change the value of this variable, but It can''t be changed because final variable once assigned a value can never be changed.\r\n\r\nclass Bike9{  \r\n final int speedlimit=90;//final variable  \r\n void run(){  \r\n  speedlimit=400;  \r\n }  \r\n public static void main(String args[]){  \r\n Bike9 obj=new  Bike9();  \r\n obj.run();  \r\n }  \r\n}//end of class  ', 15, 0),
(51, 1, 'Final Method', 'If you make any method as final, you cannot override it.', 'class Bike{  \r\n  final void run(){System.out.println("running");}  \r\n}  \r\n     \r\nclass Honda extends Bike{  \r\n   void run(){System.out.println("running safely with 100kmph");}  \r\n     \r\n   public static void main(String args[]){  \r\n   Honda honda= new Honda();  \r\n   honda.run();  \r\n   }  \r\n} ', 10, 0),
(52, 1, 'Final class', 'If you make any class as final, you cannot extend it.', 'final class Bike{}  \r\n  \r\nclass Honda1 extends Bike{  \r\n  void run(){System.out.println("running safely with 100kmph");}  \r\n    \r\n  public static void main(String args[]){  \r\n  Honda1 honda= new Honda();  \r\n  honda.run();  \r\n  }  \r\n}  ', 10, 0),
(53, 1, 'What is blank or uninitialized final variable?', 'A final variable that is not initialized at the time of declaration is known as blank final variable.\r\n\r\nIf you want to create a variable that is initialized at the time of creating object and once initialized may not be changed, it is useful. For example PAN CARD number of an employee.\r\n\r\nIt can be initialized only in constructor.', 'class Student{  \r\nint id;  \r\nString name;  \r\nfinal String PAN_CARD_NUMBER;  \r\n...  \r\n}', 10, 0),
(54, 1, 'Polymorphism in Java', 'Polymorphism in java is a concept by which we can perform a single action by different ways. Polymorphism is derived from 2 greek words: poly and morphs. The word "poly" means many and "morphs" means forms. So polymorphism means many forms.\r\n\r\nThere are two types of polymorphism in java: compile time polymorphism and runtime polymorphism. We can perform polymorphism in java by method overloading and method overriding.\r\n\r\nIf you overload static method in java, it is the example of compile time polymorphism\r\n\r\nRuntime Polymorphism in Java\r\n\r\nRuntime polymorphism or Dynamic Method Dispatch is a process in which a call to an overridden method is resolved at runtime rather than compile-time.\r\n\r\nIn this process, an overridden method is called through the reference variable of a superclass. The determination of the method to be called is based on the object being referred to by the reference variable.\r\n\r\nLet''s first understand the upcasting before Runtime Polymorphism.\r\n\r\nUpcasting\r\n\r\nWhen reference variable of Parent class refers to the object of Child class, it is known as upcasting. \r\n\r\nclass A{}  \r\nclass B extends A{}  \r\nA a=new B();//upcasting  \r\n\r\n\r\n', 'class Bike{  \r\n  void run(){System.out.println("running");}  \r\n}  \r\nclass Splender extends Bike{  \r\n  void run(){System.out.println("running safely with 60km");}  \r\n  \r\n  public static void main(String args[]){  \r\n    Bike b = new Splender();//upcasting  \r\n    b.run();  \r\n  }  \r\n} ', 10, 0),
(55, 1, 'Static Binding and Dynamic Binding', 'Connecting a method call to the method body is known as binding.\r\n\r\nThere are two types of binding\r\n\r\nstatic binding (also known as early binding).\r\ndynamic binding (also known as late binding).\r\n\r\nstatic binding\r\n\r\nWhen type of the object is determined at compiled time(by the compiler), it is known as static binding.\r\n\r\nIf there is any private, final or static method in a class, there is static binding.\r\n\r\nDynamic binding\r\n\r\nWhen type of the object is determined at run-time, it is known as dynamic binding.\r\n', 'Example of static binding\r\n\r\nclass Dog{  \r\n private void eat(){System.out.println("dog is eating...");}  \r\n  \r\n public static void main(String args[]){  \r\n  Dog d1=new Dog();  \r\n  d1.eat();  \r\n }  \r\n} \r\n\r\nExample of dynamic binding\r\n\r\nclass Animal{  \r\n void eat(){System.out.println("animal is eating...");}  \r\n}  \r\n  \r\nclass Dog extends Animal{  \r\n void eat(){System.out.println("dog is eating...");}  \r\n  \r\n public static void main(String args[]){  \r\n  Animal a=new Dog();  \r\n  a.eat();  \r\n }  \r\n}  \r\n\r\n', 10, 0),
(56, 1, 'Java instanceof', 'The java instanceof operator is used to test whether the object is an instance of the specified type (class or subclass or interface).\r\n\r\nThe instanceof in java is also known as type comparison operator because it compares the instance with type. It returns either true or false. If we apply the instanceof operator with any variable that has null value, it returns false.', 'class Simple1{  \r\n public static void main(String args[]){  \r\n Simple1 s=new Simple1();  \r\n System.out.println(s instanceof Simple1);//true  \r\n }  \r\n}', 10, 0),
(57, 1, 'Abstract class in Java', 'A class that is declared as abstract is known as abstract class. It needs to be extended and its method implemented. It cannot be instantiated.\r\n\r\nExample abstract class\r\n\r\nabstract class A{}  ', 'abstract class Bike{  \r\n  abstract void run();  \r\n}  \r\n  \r\nclass Honda4 extends Bike{  \r\nvoid run(){System.out.println("running safely..");}  \r\n  \r\npublic static void main(String args[]){  \r\n Bike obj = new Honda4();  \r\n obj.run();  \r\n}  \r\n} ', 10, 0),
(58, 1, 'Interface in Java', 'An interface in java is a blueprint of a class. It has static constants and abstract methods only.\r\n\r\nThe interface in java is a mechanism to achieve fully abstraction. There can be only abstract methods in the java interface not method body. It is used to achieve fully abstraction and multiple inheritance in Java.\r\n\r\nJava Interface also represents IS-A relationship.\r\n\r\nIt cannot be instantiated just like abstract class.\r\n', 'interface printable{  \r\nvoid print();  \r\n}  \r\n  \r\nclass A6 implements printable{  \r\npublic void print(){System.out.println("Hello");}  \r\n  \r\npublic static void main(String args[]){  \r\nA6 obj = new A6();  \r\nobj.print();  \r\n }  \r\n} ', 10, 0),
(59, 0, 'Difference between abstract class and interface', 'Abstract class\r\n\r\n1) Abstract class can have abstract and non-abstract methods.\r\n2) Abstract class doesn''t support multiple inheritance.\r\n3) Abstract class can have final, non-final, static and non-static variables.\r\n4) Abstract class can have static methods, main method and constructor.\r\n5) Abstract class can provide the implementation of interface.\r\n6) The abstract keyword is used to declare abstract class.\r\n\r\nInterface in java:\r\n1. Interface can have only abstract methods.\r\n2. Interface supports multiple inheritance.\r\n3. Interface supports multiple inheritance.\r\n4. Interface can''t have static methods, main method or constructor.\r\n5. Interface can''t provide the implementation of abstract class.\r\n6. The interface keyword is used to declare interface.\r\n\r\n\r\n\r\n\r\n', 'Abstract class example:\r\n\r\npublic abstract class Shape{\r\npublic abstract void draw();\r\n}\r\n\r\nInterface example\r\npublic interface Drawable{\r\nvoid draw();\r\n}', 10, 0),
(60, 2, 'Java Package', 'A java package is a group of similar types of classes, interfaces and sub-packages.\r\n\r\nPackage in java can be categorized in two form, built-in package and user-defined package.\r\n\r\nThere are many built-in packages such as java, lang, awt, javax, swing, net, io, util, sql etc.\r\n\r\nHere, we will have the detailed learning of creating and using user-defined packages.\r\n\r\nAdvantage of Java Package\r\n\r\n1) Java package is used to categorize the classes and interfaces so that they can be easily maintained.\r\n\r\n2) Java package provides access protection.\r\n\r\n3) Java package removes naming collision.', '//save as Simple.java  \r\npackage mypack;  \r\npublic class Simple{  \r\n public static void main(String args[]){  \r\n    System.out.println("Welcome to package");  \r\n   }  \r\n}  ', 10, 1),
(61, 2, 'Using packagename.*', 'If you use package.* then all the classes and interfaces of this package will be accessible but not subpackages.\r\n\r\nThe import keyword is used to make the classes and interface of another package accessible to the current package.', '//save by A.java  \r\npackage pack;  \r\npublic class A{  \r\n  public void msg(){System.out.println("Hello");}  \r\n}  \r\n//save by B.java  \r\npackage mypack;  \r\nimport pack.*;  \r\n  \r\nclass B{  \r\n  public static void main(String args[]){  \r\n   A obj = new A();  \r\n   obj.msg();  \r\n  }  \r\n}  ', 10, 1),
(62, 202, 'Access Modifiers in java\r\n', 'There are two types of modifiers in java: access modifiers and non-access modifiers.\r\n\r\nThe access modifiers in java specifies accessibility (scope) of a data member, method, constructor or class.\r\n\r\nThere are 4 types of java access modifiers:\r\n\r\nprivate\r\ndefault\r\nprotected\r\npublic\r\n\r\n1) private access modifier\r\n\r\nThe private access modifier is accessible only within class.\r\n\r\n\r\n\r\n\r\n', 'Example of private access modifier:\r\nclass A{  \r\nprivate int data=40;  \r\nprivate void msg(){System.out.println("Hello java");}  \r\n}  \r\n  \r\npublic class Simple{  \r\n public static void main(String args[]){  \r\n   A obj=new A();  \r\n   System.out.println(obj.data);//Compile Time Error  \r\n   obj.msg();//Compile Time Error  \r\n   }  \r\n}  ', 20, 1),
(63, 2, 'Default access modifier', '\r\nIf you don''t use any modifier, it is treated as default bydefault. The default modifier is accessible only within package.', '//save by A.java  \r\npackage pack;  \r\nclass A{  \r\n  void msg(){System.out.println("Hello");}  \r\n}  \r\n//save by B.java  \r\npackage mypack;  \r\nimport pack.*;  \r\nclass B{  \r\n  public static void main(String args[]){  \r\n   A obj = new A();//Compile Time Error  \r\n   obj.msg();//Compile Time Error  \r\n  }  \r\n} ', 10, 0),
(64, 2, 'Protected access modifier', 'The protected access modifier is accessible within package and outside the package but through inheritance only.\r\n\r\nThe protected access modifier can be applied on the data member, method and constructor. It can''t be applied on the class.', '//save by A.java  \r\npackage pack;  \r\npublic class A{  \r\nprotected void msg(){System.out.println("Hello");}  \r\n}  \r\n//save by B.java  \r\npackage mypack;  \r\nimport pack.*;  \r\n  \r\nclass B extends A{  \r\n  public static void main(String args[]){  \r\n   B obj = new B();  \r\n   obj.msg();  \r\n  }  \r\n}  ', 10, 0),
(65, 202, 'public access modifier', 'The public access modifier is accessible everywhere. It has the widest scope among all other modifiers.', '//save by A.java  \r\n  \r\npackage pack;  \r\npublic class A{  \r\npublic void msg(){System.out.println("Hello");}  \r\n}  \r\n//save by B.java  \r\n  \r\npackage mypack;  \r\nimport pack.*;  \r\n  \r\nclass B{  \r\n  public static void main(String args[]){  \r\n   A obj = new A();  \r\n   obj.msg();  \r\n  }  ', 20, 1),
(66, 1, 'Encapsulation in Java', 'Encapsulation in java is a process of wrapping code and data together into a single unit, for example capsule i.e. mixed of several medicines.', '//save as Student.java  \r\npackage com.javatpoint;  \r\npublic class Student{  \r\nprivate String name;  \r\n   \r\npublic String getName(){  \r\nreturn name;  \r\n}  \r\npublic void setName(String name){  \r\nthis.name=name  \r\n}  \r\n}  \r\n//save as Test.java  \r\npackage com.javatpoint;  \r\nclass Test{  \r\npublic static void main(String[] args){  \r\nStudent s=new Student();  \r\ns.setname("vijay");  \r\nSystem.out.println(s.getName());  \r\n}  \r\n}  ', 10, 0),
(67, 2, 'Object class in Java', 'The Object class is the parent class of all the classes in java bydefault. In other words, it is the topmost class of java.\r\n\r\nThe Object class is beneficial if you want to refer any object whose type you don''t know. Notice that parent class reference variable can refer the child class object, know as upcasting.\r\n\r\nLet''s take an example, there is getObject() method that returns an object but it can be of any type like Employee,Student etc, we can use Object class reference to refer that object. For example:\r\n\r\nObject obj=getObject();//we don''t what object would be returned from this method  \r\nThe Object class provides some common behaviours to all the objects such as object can be compared, object can be cloned, object can be notified etc.', '1. public final ClassgetClass()	\r\n\r\nreturns the Class class object of this object. The Class class can further be used to get the metadata of this class.\r\n\r\n2. public int hashCode()	\r\nreturns the hashcode number for this object.\r\n\r\n3. public boolean equals(Object obj)	compares the given object to this object.\r\n\r\n4. protected Object clone() throws CloneNotSupportedException	\r\ncreates and returns the exact copy (clone) of this object.\r\n\r\n5. public String toString()	\r\nreturns the string representation of this object.\r\n\r\n6. public final void notify()	\r\nwakes up single thread, waiting on this object''s monitor.\r\n\r\n7. public final void notifyAll()	wakes up all the threads, waiting on this object''s monitor.\r\n\r\n8. public final void wait(long timeout)throws InterruptedException	causes the current thread to wait for the specified milliseconds, until another thread notifies (invokes notify() or notifyAll() method).', 10, 0);
INSERT INTO `notesman` (`notesid`, `uid`, `topic`, `content`, `code`, `likes`, `nlevel`) VALUES
(68, 2, 'Object cloning in java', 'The object cloning is a way to create exact copy of an object. For this purpose, clone() method of Object class is used to clone an object.\r\n\r\nThe java.lang.Cloneable interface must be implemented by the class whose object clone we want to create. If we don''t implement Cloneable interface, clone() method generates CloneNotSupportedException.\r\n\r\nThe clone() method is defined in the Object class. Syntax of the clone() method is as follows:\r\n\r\nprotected Object clone() throws CloneNotSupportedException ', 'class Student18 implements Cloneable{  \r\nint rollno;  \r\nString name;  \r\n  \r\nStudent18(int rollno,String name){  \r\nthis.rollno=rollno;  \r\nthis.name=name;  \r\n}  \r\n  \r\npublic Object clone()throws CloneNotSupportedException{  \r\nreturn super.clone();  \r\n}  \r\n  \r\npublic static void main(String args[]){  \r\ntry{  \r\nStudent18 s1=new Student18(101,"amit");  \r\n  \r\nStudent18 s2=(Student18)s1.clone();  \r\n  \r\nSystem.out.println(s1.rollno+" "+s1.name);  \r\nSystem.out.println(s2.rollno+" "+s2.name);  \r\n  \r\n}catch(CloneNotSupportedException c){}  \r\n  \r\n}  \r\n} ', 10, 0),
(69, 2, 'Java Array', 'class Student18 implements Cloneable{  \r\nint rollno;  \r\nString name;  \r\n  \r\nStudent18(int rollno,String name){  \r\nthis.rollno=rollno;  \r\nthis.name=name;  \r\n}  \r\n  \r\npublic Object clone()throws CloneNotSupportedException{  \r\nreturn super.clone();  \r\n}  \r\n  \r\npublic static void main(String args[]){  \r\ntry{  \r\nStudent18 s1=new Student18(101,"amit");  \r\n  \r\nStudent18 s2=(Student18)s1.clone();  \r\n  \r\nSystem.out.println(s1.rollno+" "+s1.name);  \r\nSystem.out.println(s2.rollno+" "+s2.name);  \r\n  \r\n}catch(CloneNotSupportedException c){}  \r\n  \r\n}  \r\n} \r\n\r\nSyntax to Declare an Array in java\r\n\r\ndataType[] arr; (or)  \r\ndataType []arr; (or)  \r\ndataType arr[];  \r\nInstantiation of an Array in java\r\n\r\narrayRefVar=new datatype[size];  ', 'class Testarray{  \r\npublic static void main(String args[]){  \r\n  \r\nint a[]=new int[5];//declaration and instantiation  \r\na[0]=10;//initialization  \r\na[1]=20;  \r\na[2]=70;  \r\na[3]=40;  \r\na[4]=50;  \r\n  \r\n//printing array  \r\nfor(int i=0;i<a.length;i++)//length is the property of array  \r\nSystem.out.println(a[i]);  \r\n  \r\n}} ', 10, 0),
(70, 202, 'Passing array to method in java', 'We can pass the java array to method so that we can reuse the same logic on any array.\r\n\r\nLet''s see the simple example to get minimum number of an array using method.', 'class Testarray2{  \r\nstatic void min(int arr[]){  \r\nint min=arr[0];  \r\nfor(int i=1;i<arr.length;i++)  \r\n if(min>arr[i])  \r\n  min=arr[i];  \r\n  \r\nSystem.out.println(min);  \r\n}  \r\n  \r\npublic static void main(String args[]){  \r\n  \r\nint a[]={33,3,4,5};  \r\nmin(a);//passing array to method  \r\n  \r\n}} ', 15, 1),
(71, 23, 'Multidimensional array in java\r\n', 'In such case, data is stored in row and column based index (also known as matrix form).\r\n\r\nSyntax to Declare Multidimensional Array in java\r\n\r\ndataType[][] arrayRefVar; (or)  \r\ndataType [][]arrayRefVar; (or)  \r\ndataType arrayRefVar[][]; (or)  \r\ndataType []arrayRefVar[];   \r\nExample to instantiate Multidimensional Array in java\r\n\r\nint[][] arr=new int[3][3];//3 row and 3 column  \r\nExample to initialize Multidimensional Array in java\r\n\r\narr[0][0]=1;  \r\narr[0][1]=2;  \r\narr[0][2]=3;  \r\narr[1][0]=4;  \r\narr[1][1]=5;  \r\narr[1][2]=6;  \r\narr[2][0]=7;  \r\narr[2][1]=8;  \r\narr[2][2]=9;  ', 'class Testarray3{  \r\npublic static void main(String args[]){  \r\n  \r\n//declaring and initializing 2D array  \r\nint arr[][]={{1,2,3},{2,4,5},{4,4,5}};  \r\n  \r\n//printing 2D array  \r\nfor(int i=0;i<3;i++){  \r\n for(int j=0;j<3;j++){  \r\n   System.out.print(arr[i][j]+" ");  \r\n }  \r\n System.out.println();  \r\n}  \r\n  \r\n}} ', 15, 1),
(72, 2, 'class name of java array', 'In java, array is an object. For array object, an proxy class is created whose name can be obtained by getClass().getName() method on the object.', 'class Testarray4{  \r\npublic static void main(String args[]){  \r\n  \r\nint arr[]={4,4,5};  \r\n  \r\nClass c=arr.getClass();  \r\nString name=c.getName();  \r\n  \r\nSystem.out.println(name);  \r\n  \r\n}} ', 10, 0),
(73, 2, 'Wrapper class in Java', 'Wrapper class in java provides the mechanism to convert primitive into object and object into primitive.\r\n\r\nSince J2SE 5.0, autoboxing and unboxing feature converts primitive into object and object into primitive automatically. The automatic conversion of primitive into object is known and autoboxing and vice-versa unboxing.', 'Wrapper class Example: Primitive to Wrapper\r\n\r\npublic class WrapperExample1{  \r\npublic static void main(String args[]){  \r\n//Converting int into Integer  \r\nint a=20;  \r\nInteger i=Integer.valueOf(a);//converting int into Integer  \r\nInteger j=a;//autoboxing, now compiler will write Integer.valueOf(a) internally  \r\n  \r\nSystem.out.println(a+" "+i+" "+j);  \r\n}}  \r\nOutput:\r\n\r\n20 20 20\r\nWrapper class Example: Wrapper to Primitive\r\n\r\npublic class WrapperExample2{    \r\npublic static void main(String args[]){    \r\n//Converting Integer to int    \r\nInteger a=new Integer(3);    \r\nint i=a.intValue();//converting Integer to int  \r\nint j=a;//unboxing, now compiler will write a.intValue() internally    \r\n    \r\nSystem.out.println(a+" "+i+" "+j);    \r\n}}    \r\nOutput:\r\n\r\n3 3 3', 10, 0),
(74, 2, 'Call by Value and Call by Reference in Java', 'There is only call by value in java, not call by reference. If we call a method passing a value, it is known as call by value. The changes being done in the called method, is not affected in the calling method.', 'Example of call by value in java\r\n\r\nIn case of call by value original value is not changed. Let''s take a simple example:\r\nclass Operation{  \r\n int data=50;  \r\n  \r\n void change(int data){  \r\n data=data+100;//changes will be in the local variable only  \r\n }  \r\n     \r\n public static void main(String args[]){  \r\n   Operation op=new Operation();  \r\n  \r\n   System.out.println("before change "+op.data);  \r\n   op.change(500);  \r\n   System.out.println("after change "+op.data);  \r\n  \r\n }  \r\n}', 10, 0),
(75, 2, 'Java Strictfp Keyword', 'Java strictfp keyword ensures that you will get the same result on every platform if you perform operations in the floating-point variable. The precision may differ from platform to platform that is why java programming language have provided the strictfp keyword, so that you get same result on every platform. So, now you have better control over the floating-point arithmetic.', 'The strictfp keyword can be applied on methods, classes and interfaces.\r\n\r\nstrictfp class A{}//strictfp applied on class  \r\nstrictfp interface M{}//strictfp applied on interface  \r\nclass A{  \r\nstrictfp void m(){}//strictfp applied on method  \r\n} ', 10, 0),
(76, 2, 'Creating API Document | javadoc tool\r\n', 'We can create document api in java by the help of javadoc tool. In the java file, we must use the documentation comment /**... */ to post information for the class, method, constructor, fields etc.', 'package com.abc;  \r\n/** This class is a user-defined class that contains one methods cube.*/  \r\npublic class M{  \r\n  \r\n/** The cube method prints cube of the given number */  \r\npublic static void  cube(int n){System.out.println(n*n*n);}  \r\n} ', 10, 0),
(77, 0, 'Java Command Line Arguments', 'The java command-line argument is an argument i.e. passed at the time of running the java program.\r\n\r\nThe arguments passed from the console can be received in the java program and it can be used as an input.\r\n\r\nSo, it provides a convenient way to check the behavior of the program for the different values. You can pass N (1,2,3 and so on) numbers of arguments from the command prompt.', 'Simple example of command-line argument in java\r\n\r\nIn this example, we are receiving only one argument and printing it. To run this java program, you must pass at least one argument from the command prompt.\r\nclass CommandLineExample{  \r\npublic static void main(String args[]){  \r\nSystem.out.println("Your first argument is: "+args[0]);  \r\n}  \r\n}  \r\ncompile by > javac CommandLineExample.java  \r\nrun by > java CommandLineExample sonoo  \r\nOutput: Your first argument is: sonoo', 10, 0),
(78, 0, 'Difference between object and class', 'Object:\r\n1)	Object is an instance of a class.\r\n2)	Object is a real world entity such as pen, laptop, mobile, bed, keyboard, mouse, chair etc.\r\n3)	Object is a physical entity.\r\n4)	Object is created through new keyword mainly e.g.\r\nStudent s1=new Student();\r\n5)	Object is created many times as per requirement.\r\n6)	Object allocates memory when it is created.\r\n7)	There are many ways to create object in java such as new keyword, newInstance() method, clone() method, factory method and deserialization.\r\n\r\nClass:\r\n1. Class is a blueprint or template from which objects are created.\r\n2. Class is a group of similar objects.\r\n3. Class is a logical entity.\r\n4. Class is declared using class keyword e.g. class Student{}\r\n5. Class is declared once.\r\n6. Class doesn''t allocated memory when it is created.\r\n7. There is only one way to define class in java using class keyword.\r\n', '', 10, 0),
(79, 0, 'Difference between method overloading and method overriding in java', 'Method overloading:\r\n1)	Method overloading is used to increase the readability of the program.\r\n2)	Method overloading is performed within class.\r\n3)	In case of method overloading, parameter must be different.\r\n4)	Method overloading is the example of compile time polymorphism.\r\n5)	In java, method overloading can''t be performed by changing return type of the method only. Return type can be same or different in method overloading. But you must have to change the parameter.\r\n\r\nMethod overriding:\r\n1. Method overriding is used to provide the specific implementation of the method that is already provided by its super class.\r\n2. Method overriding occurs in two classes that have IS-A (inheritance) relationship.\r\n3. In case of method overriding, parameter must be same.\r\n4. Method overriding is the example of run time polymorphism.\r\n5. Return type must be same or covariant in method overriding.', 'Java Method Overloading example\r\n\r\nclass OverloadingExample{  \r\nstatic int add(int a,int b){return a+b;}  \r\nstatic int add(int a,int b,int c){return a+b+c;}  \r\n}  \r\nJava Method Overriding example\r\n\r\nclass Animal{  \r\nvoid eat(){System.out.println("eating...");}  \r\n}  \r\nclass Dog extends Animal{  \r\nvoid eat(){System.out.println("eating bread...");}  \r\n}  ', 10, 0),
(80, 0, 'Java String', 'ava String provides a lot of concepts that can be performed on a string such as compare, concat, equals, split, length, replace, compareTo, intern, substring etc.\r\n\r\nIn java, string is basically an object that represents sequence of char values.\r\n\r\nAn array of characters works same as java string. For example:\r\n\r\nchar[] ch={''j'',''a'',''v'',''a'',''t'',''p'',''o'',''i'',''n'',''t''};  \r\nString s=new String(ch);  \r\nis same as:\r\n\r\nString s="javatpoint";  \r\nThe java.lang.String class implements Serializable, Comparable and CharSequence interfaces.\r\n\r\nThe java String is immutable i.e. it cannot be changed but a new instance is created. For mutable class, you can use StringBuffer and StringBuilder class.\r\n\r\nWe will discuss about immutable string later. Let''s first understand what is string in java and how to create the string object.', 'public class StringExample{  \r\npublic static void main(String args[]){  \r\nString s1="java";//creating string by java string literal  \r\n  \r\nchar ch[]={''s'',''t'',''r'',''i'',''n'',''g'',''s''};  \r\nString s2=new String(ch);//converting char array to string  \r\n  \r\nString s3=new String("example");//creating java string by new keyword  \r\n  \r\nSystem.out.println(s1);  \r\nSystem.out.println(s2);  \r\nSystem.out.println(s3);  \r\n}}  ', 10, 0),
(81, 202, 'Java String class methods', 'Method:\r\n1	char charAt(int index)\r\nreturns char value for the particular index\r\n\r\n2	int length()	\r\nreturns string length\r\n\r\n3	static String format(String format, Object... args)	\r\nreturns formatted string\r\n\r\n4	static String format(Locale l, String format, Object... args)	\r\nreturns formatted string with given locale\r\n\r\n5	String substring(int beginIndex)	returns substring for given begin index\r\n\r\n6	String substring(int beginIndex, int endIndex)	\r\nreturns substring for given begin index and end index', '', 15, 1),
(82, 2, 'Immutable String in Java', 'In java, string objects are immutable. Immutable simply means unmodifiable or unchangeable.\r\n\r\nOnce string object is created its data or state can''t be changed but a new string object is created.', 'class Testimmutablestring{  \r\n public static void main(String args[]){  \r\n   String s="Sachin";  \r\n   s.concat(" Tendulkar");//concat() method appends the string at the end  \r\n   System.out.println(s);//will print Sachin because strings are immutable objects  \r\n }  \r\n}  ', 10, 0),
(83, 0, 'Java String compare', 'We can compare string in java on the basis of content and reference.\r\n\r\nIt is used in authentication (by equals() method), sorting (by compareTo() method), reference matching (by == operator) etc.\r\n\r\nThere are three ways to compare string in java:\r\n\r\nBy equals() method\r\nBy = = operator\r\nBy compareTo() method', 'class Teststringcomparison1{  \r\n public static void main(String args[]){  \r\n   String s1="Sachin";  \r\n   String s2="Sachin";  \r\n   String s3=new String("Sachin");  \r\n   String s4="Saurav";  \r\n   System.out.println(s1.equals(s2));//true  \r\n   System.out.println(s1.equals(s3));//true  \r\n   System.out.println(s1.equals(s4));//false  \r\n }  \r\n}', 10, 0),
(84, 202, 'String compare by equals() method', 'The String equals() method compares the original content of the string. It compares values of string for equality. String class provides two methods:\r\n\r\npublic boolean equals(Object another) compares this string to the specified object.\r\npublic boolean equalsIgnoreCase(String another) compares this String to another string, ignoring case.', 'class Teststringcomparison1{  \r\n public static void main(String args[]){  \r\n   String s1="Sachin";  \r\n   String s2="Sachin";  \r\n   String s3=new String("Sachin");  \r\n   String s4="Saurav";  \r\n   System.out.println(s1.equals(s2));//true  \r\n   System.out.println(s1.equals(s3));//true  \r\n   System.out.println(s1.equals(s4));//false  \r\n }  \r\n}  ', 15, 1),
(85, 202, 'String compare by == operator', 'The = = operator compares references not values.', 'class Teststringcomparison3{  \r\n public static void main(String args[]){  \r\n   String s1="Sachin";  \r\n   String s2="Sachin";  \r\n   String s3=new String("Sachin");  \r\n   System.out.println(s1==s2);//true (because both refer to same instance)  \r\n   System.out.println(s1==s3);//false(because s3 refers to instance created in nonpool)  \r\n }  \r\n}  ', 25, 1),
(86, 202, 'String compare by compareTo() method', 'The String compareTo() method compares values lexicographically and returns an integer value that describes if first string is less than, equal to or greater than second string.\r\n\r\nSuppose s1 and s2 are two string variables. If:\r\n\r\ns1 == s2 :0\r\ns1 > s2   :positive value\r\ns1 < s2   :negative value', 'class Teststringcomparison4{  \r\n public static void main(String args[]){  \r\n   String s1="Sachin";  \r\n   String s2="Sachin";  \r\n   String s3="Ratan";  \r\n   System.out.println(s1.compareTo(s2));//0  \r\n   System.out.println(s1.compareTo(s3));//1(because s1>s3)  \r\n   System.out.println(s3.compareTo(s1));//-1(because s3 < s1 )  \r\n }  \r\n} ', 5, 1),
(87, 0, 'String Concatenation in Java', 'Java string concatenation operator (+) is used to add strings', 'class TestStringConcatenation1{  \r\n public static void main(String args[]){  \r\n   String s="Sachin"+" Tendulkar";  \r\n   System.out.println(s);//Sachin Tendulkar  \r\n }  \r\n}  ', 10, 0),
(88, 2, 'String Concatenation by concat() method', 'The String concat() method concatenates the specified string to the end of current string. Syntax:\r\n\r\npublic String concat(String another)  ', 'class TestStringConcatenation3{  \r\n public static void main(String args[]){  \r\n   String s1="Sachin ";  \r\n   String s2="Tendulkar";  \r\n   String s3=s1.concat(s2);  \r\n   System.out.println(s3);//Sachin Tendulkar  \r\n  }  \r\n}', 10, 0),
(89, 2, 'Substring in Java', 'A part of string is called substring. In other words, substring is a subset of another string. In case of substring startIndex is inclusive and endIndex is exclusive.\r\n\r\nNote: Index starts from 0.\r\n\r\nYou can get substring from the given string object by one of the two methods:\r\n\r\npublic String substring(int startIndex): This method returns new String object containing the substring of the given string from specified startIndex (inclusive).\r\npublic String substring(int startIndex, int endIndex): This method returns new String object containing the substring of the given string from specified startIndex to endIndex.\r\nIn case of string:\r\n\r\nstartIndex: inclusive\r\nendIndex: exclusive', 'public class TestSubstring{  \r\n public static void main(String args[]){  \r\n   String s="Sachin Tendulkar";  \r\n   System.out.println(s.substring(6));//Tendulkar  \r\n   System.out.println(s.substring(0,6));//Sachin  \r\n }  \r\n}  ', 10, 0),
(90, 2, 'Java String class methods', 'The java.lang.String class provides a lot of methods to work on string. By the help of these methods, we can perform operations on string such as trimming, concatenating, converting, comparing, replacing strings etc.\r\n\r\nJava String is a powerful concept because everything is treated as a string if you submit any form in window based, web based or mobile application.\r\n\r\nLet''s see the important methods of String class.\r\n\r\nJava String toUpperCase() and toLowerCase() method\r\n\r\nThe java string toUpperCase() method converts this string into uppercase letter and string toLowerCase() method into lowercase letter.', 'String s="Sachin";  \r\nSystem.out.println(s.toUpperCase());//SACHIN  \r\nSystem.out.println(s.toLowerCase());//sachin  \r\nSystem.out.println(s);//Sachin(no change in original)  ', 10, 0),
(91, 0, 'Java String trim() method', 'The string trim() method eliminates white spaces before and after string.', 'String s="  Sachin  ";  \r\nSystem.out.println(s);//  Sachin    \r\nSystem.out.println(s.trim());//Sachin  ', 10, 0),
(92, 202, 'Java String charAt() method', 'The string charAt() method returns a character at specified index.', 'String s="Sachin";  \r\nSystem.out.println(s.charAt(0));//S  \r\nSystem.out.println(s.charAt(3));//h  ', 15, 1),
(93, 23, 'Java StringBuffer class', 'Java StringBuffer class is used to created mutable (modifiable) string. The StringBuffer class in java is same as String class except it is mutable i.e. it can be changed.\r\n\r\nImportant Constructors of StringBuffer class\r\n\r\nStringBuffer(): creates an empty string buffer with the initial capacity of 16.\r\nStringBuffer(String str): creates a string buffer with the specified string.\r\nStringBuffer(int capacity): creates an empty string buffer with the specified capacity as length.\r\n\r\n\r\nImportant methods of StringBuffer class\r\n\r\npublic synchronized StringBuffer append(String s): is used to append the specified string with this string. The append() method is overloaded like append(char), append(boolean), append(int), append(float), append(double) etc.\r\npublic synchronized StringBuffer insert(int offset, String s): is used to insert the specified string with this string at the specified position. The insert() method is overloaded like insert(int, char), insert(int, boolean), insert(int, int), insert(int, float), insert(int, double) etc.\r\npublic synchronized StringBuffer replace(int startIndex, int endIndex, String str): is used to replace the string from specified startIndex and endIndex.\r\npublic synchronized StringBuffer delete(int startIndex, int endIndex): is used to delete the string from specified startIndex and endIndex.\r\npublic synchronized StringBuffer reverse(): is used to reverse the string.\r\npublic int capacity(): is used to return the current capacity.\r\npublic void ensureCapacity(int minimumCapacity): is used to ensure the capacity at least equal to the given minimum.\r\npublic char charAt(int index): is used to return the character at the specified position.\r\npublic int length(): is used to return the length of the string i.e. total number of characters.\r\npublic String substring(int beginIndex): is used to return the substring from the specified beginIndex.\r\npublic String substring(int beginIndex, int endIndex): is used to return the substring from the specified beginIndex and endIndex.\r\n\r\n', '', 25, 1),
(94, 2, 'Java StringBuilder class', 'Java StringBuilder class is used to create mutable (modifiable) string. The Java StringBuilder class is same as StringBuffer class except that it is non-synchronized. It is available since JDK 1.5.\r\n\r\nImportant Constructors of StringBuilder class\r\n\r\nStringBuilder(): creates an empty string Builder with the initial capacity of 16.\r\nStringBuilder(String str): creates a string Builder with the specified string.\r\nStringBuilder(int length): creates an empty string Builder with the specified capacity as length.', '1) StringBuilder append() method\r\n\r\nThe StringBuilder append() method concatenates the given argument with this string.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder("Hello ");  \r\nsb.append("Java");//now original string is changed  \r\nSystem.out.println(sb);//prints Hello Java  \r\n}  \r\n}  \r\n2) StringBuilder insert() method\r\n\r\nThe StringBuilder insert() method inserts the given string with this string at the given position.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder("Hello ");  \r\nsb.insert(1,"Java");//now original string is changed  \r\nSystem.out.println(sb);//prints HJavaello  \r\n}  \r\n}  \r\n3) StringBuilder replace() method\r\n\r\nThe StringBuilder replace() method replaces the given string from the specified beginIndex and endIndex.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder("Hello");  \r\nsb.replace(1,3,"Java");  \r\nSystem.out.println(sb);//prints HJavalo  \r\n}  \r\n}  \r\n4) StringBuilder delete() method\r\n\r\nThe delete() method of StringBuilder class deletes the string from the specified beginIndex to endIndex.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder("Hello");  \r\nsb.delete(1,3);  \r\nSystem.out.println(sb);//prints Hlo  \r\n}  \r\n}  \r\n5) StringBuilder reverse() method\r\n\r\nThe reverse() method of StringBuilder class reverses the current string.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder("Hello");  \r\nsb.reverse();  \r\nSystem.out.println(sb);//prints olleH  \r\n}  \r\n}  \r\n6) StringBuilder capacity() method\r\n\r\nThe capacity() method of StringBuilder class returns the current capacity of the Builder. The default capacity of the Builder is 16. If the number of character increases from its current capacity, it increases the capacity by (oldcapacity*2)+2. For example if your current capacity is 16, it will be (16*2)+2=34.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder();  \r\nSystem.out.println(sb.capacity());//default 16  \r\nsb.append("Hello");  \r\nSystem.out.println(sb.capacity());//now 16  \r\nsb.append("java is my favourite language");  \r\nSystem.out.println(sb.capacity());//now (16*2)+2=34 i.e (oldcapacity*2)+2  \r\n}  \r\n}  \r\n7) StringBuilder ensureCapacity() method\r\n\r\nThe ensureCapacity() method of StringBuilder class ensures that the given capacity is the minimum to the current capacity. If it is greater than the current capacity, it increases the capacity by (oldcapacity*2)+2. For example if your current capacity is 16, it will be (16*2)+2=34.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder();  \r\nSystem.out.println(sb.capacity());//default 16  \r\nsb.append("Hello");  \r\nSystem.out.println(sb.capacity());//now 16  \r\nsb.append("java is my favourite language");  \r\nSystem.out.println(sb.capacity());//now (16*2)+2=34 i.e (oldcapacity*2)+2  \r\nsb.ensureCapacity(10);//now no change  \r\nSystem.out.println(sb.capacity());//now 34  \r\nsb.ensureCapacity(50);//now (34*2)+2  \r\nSystem.out.println(sb.capacity());//now 70  \r\n}  \r\n}  ', 10, 0),
(95, 2, 'Performance Test of StringBuffer and StringBuilder', 'Let''s see the code to check the performance of StringBuffer and StringBuilder classes.', 'public class ConcatTest{  \r\n    public static void main(String[] args){  \r\n        long startTime = System.currentTimeMillis();  \r\n        StringBuffer sb = new StringBuffer("Java");  \r\n        for (int i=0; i<10000; i++){  \r\n            sb.append("Tpoint");  \r\n        }  \r\n        System.out.println("Time taken by StringBuffer: " + (System.currentTimeMillis() - startTime) + "ms");  \r\n        startTime = System.currentTimeMillis();  \r\n        StringBuilder sb2 = new StringBuilder("Java");  \r\n        for (int i=0; i<10000; i++){  \r\n            sb2.append("Tpoint");  \r\n        }  \r\n        System.out.println("Time taken by StringBuilder: " + (System.currentTimeMillis() - startTime) + "ms");  \r\n    }  \r\n} \r\n\r\nOutput:\r\nTime taken by StringBuffer: 16ms\r\nTime taken by StringBuilder: 0ms\r\n', 10, 0),
(96, 2, 'Immutable class', 'There are many immutable classes like String, Boolean, Byte, Short, Integer, Long, Float, Double etc. In short, all the wrapper classes and String class is immutable. We can also create immutable class by creating final class that have final data members as the example given below:', 'In this example, we have created a final class named Employee. It have one final datamember, a parameterized constructor and getter method.\r\npublic final class Employee{  \r\nfinal String pancardNumber;  \r\n  \r\npublic Employee(String pancardNumber){  \r\nthis.pancardNumber=pancardNumber;  \r\n}  \r\n  \r\npublic String getPancardNumber(){  \r\nreturn pancardNumber;  \r\n}  \r\n  \r\n}  \r\nThe above class is immutable because:\r\nThe instance variable of the class is final i.e. we cannot change the value of it after creating an object.\r\nThe class is final so we cannot create the subclass.\r\nThere is no setter methods i.e. we have no option to change the value of the instance variable.', 10, 0),
(97, 2, 'StringTokenizer in Java', 'The java.util.StringTokenizer class allows you to break a string into tokens. It is simple way to break string.\r\n\r\nIt doesn''t provide the facility to differentiate numbers, quoted strings, identifiers etc. like StreamTokenizer class. We will discuss about the StreamTokenizer class in I/O chapter.\r\n\r\nConstructors of StringTokenizer class\r\n\r\nThere are 3 constructors defined in the StringTokenizer class.\r\n\r\n1. StringTokenizer(String str)	\r\ncreates StringTokenizer with specified string.\r\n\r\n2. StringTokenizer(String str, String delim)	\r\ncreates StringTokenizer with specified string and delimeter.\r\n\r\n3. StringTokenizer(String str, String delim, boolean returnValue)	\r\ncreates StringTokenizer with specified string, delimeter and returnValue. If return value is true, delimiter characters are considered to be tokens. If it is false, delimiter characters serve to separate tokens.\r\n\r\n', '', 10, 0),
(98, 0, 'Java String charAt', 'The java string charAt() method returns a char value at the given index number. The index number starts from 0.\r\n\r\nSignature\r\n\r\nThe signature of string charAt() method is given below:\r\n\r\npublic char charAt(int index)  \r\nParameter\r\n\r\nindex : index number, starts with 0\r\n\r\nReturns\r\n\r\nchar value\r\n\r\nSpecified by\r\n\r\nCharSequence interface\r\n\r\nThrows\r\n\r\nIndexOutOfBoundsException : if index is negative value or greater than this string length.', 'public class CharAtExample{  \r\npublic static void main(String args[]){  \r\nString name="javatpoint";  \r\nchar ch=name.charAt(4);//returns the char value at the 4th index  \r\nSystem.out.println(ch);  \r\n}} \r\n\r\nOutput:\r\nt', 10, 0),
(99, 2, 'Java String compareTo() method', 'The java string compareTo() method compares the given string with current string lexicographically. It returns positive number, negative number or 0.\r\n\r\nIf first string is greater than second string, it returns positive number (difference of character value). If first string is less than second string, it returns negative number and if first string is equal to second string, it returns 0.\r\n\r\ns1 > s2 => positive number  \r\ns1 < s2 => negative number  \r\ns1 == s2 => 0  \r\nSignature\r\n\r\npublic int compareTo(String anotherString)  \r\nParameters\r\n\r\nanotherString: represents string that is to be compared with current string\r\n\r\nReturns\r\n\r\nan integer value', 'public class LastIndexOfExample{  \r\npublic static void main(String args[]){  \r\nString s1="hello";  \r\nString s2="hello";  \r\nString s3="meklo";  \r\nString s4="hemlo";  \r\nSystem.out.println(s1.compareTo(s2));  \r\nSystem.out.println(s1.compareTo(s3));  \r\nSystem.out.println(s1.compareTo(s4));  \r\n}}  \r\nOutput:\r\n\r\n0\r\n-5\r\n-1', 10, 0),
(100, 0, 'Java String concat', 'The java string concat() method combines specified string at the end of this string. It returns combined string. It is like appending another string.\r\n\r\nSignature\r\n\r\nThe signature of string concat() method is given below:\r\n\r\npublic String concat(String anotherString)  \r\nParameter\r\n\r\nanotherString : another string i.e. to be combined at the end of this string.\r\n\r\nReturns\r\n\r\ncombined string', 'public class ConcatExample{  \r\npublic static void main(String args[]){  \r\nString s1="java string";  \r\ns1.concat("is immutable");  \r\nSystem.out.println(s1);  \r\ns1=s1.concat(" is immutable so assign it explicitly");  \r\nSystem.out.println(s1);  \r\n}} ', 10, 0),
(201, 7, 'private constructor ', 'Used in singleton class. Makes sure that only one object is created for that class.', 'public class SingleTonClass {\r\n   //Static Class Reference\r\n   private static SingleTonClass obj=null;\r\n   private SingleTonClass(){\r\n      /*Private Constructor will prevent \r\n       * the instantiation of this class directly*/\r\n   }\r\n   public static SingleTonClass objectCreationMethod(){\r\n	/*This logic will ensure that no more than\r\n	 * one object can be created at a time */\r\n	if(obj==null){\r\n	    obj= new SingleTonClass();\r\n	}\r\n        return obj;\r\n   }\r\n   public void display(){\r\n	System.out.println("Singleton class Example");\r\n   }\r\n   public static void main(String args[]){\r\n	//Object cannot be created directly due to private constructor \r\n        //This way it is forced to create object via our method where\r\n        //we have logic for only one object creation\r\n	SingleTonClass myobject= SingleTonClass.objectCreationMethod();\r\n	myobject.display();\r\n   }\r\n}', 10, 2),
(202, 80, 'encapsulation', 'hide the private variables from the user and access them using getter and setter methods.', 'public class EncapsulationDemo{\r\n    private int ssn;\r\n    private String empName;\r\n    private int empAge;\r\n\r\n    //Getter and Setter methods\r\n    public int getEmpSSN(){\r\n        return ssn;\r\n    }\r\n\r\n    public String getEmpName(){\r\n        return empName;\r\n    }\r\n}', 12, 0),
(203, 23, 'aggregation', 'instance of one class in another class. Like a Student object having a Has-A relationship with Address object. ', 'class StudentClass\r\n{\r\n   int rollNum;\r\n   String studentName;\r\n   Address studentAddr; \r\n   StudentClass(int roll, String name, Address addr){\r\n       this.rollNum=roll;\r\n       this.studentName=name;\r\n       this.studentAddr = addr;\r\n   }', 10, 1),
(204, 67, 'super', '1) super.<variable_name> refers to the variable of variable of parent class.\r\n2) super() invokes the constructor of immediate parent class.\r\n3) super.<method_name> refers to the method of parent class.', '//Parent class or Superclass\r\nclass Parentclass\r\n{\r\n	int num=100;\r\n}\r\n//Child class or subclass\r\nclass Subclass extends Parentclass\r\n{\r\n    /* I am declaring the same variable \r\n     * num in child class too.\r\n     */\r\n    int num=110;\r\n    void printNumber(){\r\n 	System.out.println(num);\r\n    }\r\n    public static void main(String args[]){\r\n       Subclass obj= new Subclass();\r\n       obj.printNumber();	\r\n    }\r\n}', 5, 2),
(205, 65, 'static variable', 'Static variable’s value is same for all the object(or instances) of the class or in other words you can say that all instances(objects) of the same class share a single copy of static variables.\r\n', 'class VariableDemo\r\n{\r\n   static int count=0;\r\n   public void increment()\r\n   {\r\n       count++;\r\n   }\r\n}', 12, 1),
(206, 44, 'final variable ', 'final variables are nothing but constants. We cannot change the value of a final variable once it is initialized.', ' final int MAX_VALUE=99;', 10, 0),
(207, 30, 'blank final variable', 'Blank final variable\r\n\r\nA final variable that is not initialized at the time of declaration is known as blank final variable. We must initialize the blank final variable in constructor of the class otherwise it will throw a compilation error ', 'class Demo{  \r\n   //Blank final variable\r\n   final int MAX_VALUE;\r\n	 \r\n   Demo(){\r\n      //It must be initialized in constructor\r\n      MAX_VALUE=100;\r\n   }\r\n}', 10, 1),
(208, 23, 'final method\r\n\r\n', 'A final method cannot be overridden. Which means even though a sub class can call the final method of parent class without any issues but it cannot override it.', 'class XYZ{  \r\n   final void demo(){\r\n      System.out.println("XYZ Class Method");\r\n   }  \r\n}  \r\n	     \r\nclass ABC extends XYZ{  \r\n   void demo(){\r\n      System.out.println("ABC Class Method");\r\n   }  \r\n	     \r\n   public static void main(String args[]){  \r\n      ABC obj= new ABC();  \r\n      obj.demo();  \r\n   }  \r\n}', 10, 0),
(209, 77, 'final class\r\n\r\n', 'We cannot extend a final class.', 'final class XYZ{  \r\n}  \r\n	     \r\nclass ABC extends XYZ{  \r\n   void demo(){\r\n      System.out.println("My Method");\r\n   }  \r\n   public static void main(String args[]){  \r\n      ABC obj= new ABC(); \r\n      obj.demo();\r\n   }  \r\n}\r\nOutput:\r\n\r\nThe type ABC cannot subclass the final class XYZ', 12, 1),
(210, 89, 'interfaces', 'Interface looks like class but it is not a class. An interface can have methods and variables just like the class but the methods declared in interface are by default abstract (only method signature, no body). Also, the variables declared in an interface are public, static & final by default.', 'interface MyInterface\r\n{\r\n   /* All the methods are public abstract by default\r\n    * Note down that these methods are not having body\r\n    */\r\n   public void method1();\r\n   public void method2();\r\n}', 12, 2),
(211, 5, 'Multilevel inheritance', 'It’s pretty clear with the diagram that in Multilevel inheritance there is a concept of grand parent class. If we take the example of above diagram then class C inherits class B and class B inherits class A which means B is a parent class of C and A is a parent class of B. So in this case class C is implicitly inheriting the properties and method of class A along with B that’s what is called multilevel inheritance.', 'class Car{\r\n	public Car()\r\n	{\r\n		System.out.println("Class Car");\r\n	}\r\n	public void vehicleType()\r\n	{\r\n		System.out.println("Vehicle Type: Car");\r\n	}\r\n}\r\nclass Maruti extends Car{\r\n	public Maruti()\r\n	{\r\n		System.out.println("Class Maruti");\r\n	}\r\n	public void brand()\r\n	{\r\n		System.out.println("Brand: Maruti");\r\n	}\r\n	public void speed()\r\n	{\r\n		System.out.println("Max: 90Kmph");\r\n	}\r\n}\r\npublic class Maruti800 extends Maruti{\r\n\r\n	 public Maruti800()\r\n	 {\r\n		 System.out.println("Maruti Model: 800");\r\n	 }\r\n	 public void speed()\r\n		{\r\n			System.out.println("Max: 80Kmph");\r\n		}\r\n	 public static void main(String args[])\r\n	 {\r\n		 Maruti800 obj=new Maruti800();\r\n		 obj.vehicleType();\r\n		 obj.brand();\r\n		 obj.speed();\r\n	 }\r\n}\r\nOutput:\r\n\r\nClass Car\r\nClass Maruti\r\nMaruti Model: 800\r\nVehicle Type: Car\r\nBrand: Maruti\r\nMax: 80Kmph', 10, 2),
(212, 78, 'Garbage collection', 'Garbage collection deals with it and its main purpose are to delete all the objects that are either not in use or out of reach. So, all we do through a Java code is that we create objects as per our need and then destroy them when they are no longer in use. This garbage collector is under the control of JVM. Though JVM can be commanded to run the Garbage collector but then there seems no guarantee that actually the Garbage collector will be set out to work. So, the Garbage collector is normally run at the times when the JVM falls short of memory.', '', 12, 2),
(213, 0, 'inner class', 'What is an inner class?\r\n\r\nInner class are defined inside the body of another class (known as outer class). These classes can have access modifier or even can be marked as abstract and final. Inner classes have special relationship with outer class instances. This relationship allows them to have access to outer class members including private members too.', 'class MyOuterClassDemo {\r\n   private int x= 1;\r\n   public void innerInstance()\r\n   {\r\n       MyInnerClassDemo inner = new MyInnerClassDemo();\r\n       inner. seeOuter();\r\n   }\r\n   public static void main(String args[]){\r\n       MyOuterClassDemo obj = new MyOuterClassDemo();\r\n       obj.innerInstance();\r\n   }\r\n   // inner class definition\r\n   class MyInnerClassDemo {\r\n       public void seeOuter () {\r\n          System.out.println("Outer Value of x is :" + x);\r\n       }\r\n   } // close inner class definition	   \r\n} // close Top level class definition\r\nOutput:\r\n\r\nOuter Value of x is :1', 10, 2),
(214, 34, 'oops paradigms', '1)Encapsulation \r\n\r\nBinding the data with the code that manipulates it.\r\nIt keeps the data and the code safe from external interference\r\n\r\n2)Inheritance\r\n\r\nInheritance is the mechanism by which an object acquires the some/all properties of another object.\r\nIt supports the concept of hierarchical classification.\r\n\r\n3)Polymorphism\r\nPolymorphism means to process objects differently based on their data type.\r\nIn other words it means, one method with multiple implementation, for a certain class of action. And which implementation to be used is decided at runtime depending upon the situation (i.e., data type of the object)\r\nThis can be implemented by designing a generic interface, which provides generic methods for a certain class of action and there can be multiple classes, which provides the implementation of these generic methods.\r\n\r\n', '', 10, 0),
(215, 9, ' Static Nested Classes\r\n\r\n', 'A static nested classes are the inner classes marked with static modifier.Because this is static in nature so this type of inner class doesn’t share any special kind of relationship with an instance of outer class.A static nested class cannot access non static members of outer class.', 'class Outer{\r\n   static class Nested{}\r\n}\r\n//A static nested class can be //instantiated like this:\r\n\r\nclass Outer{// outer class\r\n   static class Nested{}// static nested class\r\n}\r\n\r\nclass Demo{\r\n   public static void main(string[] args){\r\n      // use both class names\r\n      Outer.Nested n= new Outer.Nested();\r\n   }\r\n}', 10, 1),
(216, 56, 'Hierarchical inheritance', 'As you can see in the above diagram that when a class has more than one child classes (sub classes) or in other words more than one child classes have the same parent class then such kind of inheritance is known as hierarchical.', 'Class A\r\n{\r\n  public void methodA()\r\n  {\r\n     System.out.println("method of Class A");\r\n  }\r\n}\r\nClass B extends A\r\n{\r\n  public void methodB()\r\n  {\r\n     System.out.println("method of Class B");\r\n  }\r\n}\r\nClass C extends A\r\n{\r\n public void methodC()\r\n {\r\n System.out.println("method of Class C");\r\n }\r\n}\r\nClass D extends A\r\n{\r\n  public void methodD()\r\n  {\r\n     System.out.println("method of Class D");\r\n  }\r\n}\r\nClass MyClass\r\n{\r\n  public void methodB()\r\n  {\r\n     System.out.println("method of Class B");\r\n  }\r\n  public static void main(String args[])\r\n  {\r\n     B obj1 = new B();\r\n     C obj2 = new C();\r\n     D obj3 = new D();\r\n     obj1.methodA();\r\n     obj2.methodA();\r\n     obj3.methodA();\r\n  }\r\n}', 12, 2),
(217, 36, 'packages', 'Packages in Java is a mechanism to encapsulate a group of classes, interfaces and sub packages. Many implementations of Java use a hierarchical file system to manage source and class files. It is easy to organize class files into packages. All we need to do is put related class files in the same directory, give the directory a name that relates to the purpose of the classes, and add a line to the top of each class file that declares the package name, which is the same as the directory name where they reside.', '', 10, 2),
(218, 90, 'Constructor overloading', 'Constructor overloading is way of having more than one constructor which does different-2 tasks. For e.g. Vector class has 4 types of constructors. If you do not want to specify the initial capacity and capacity increment then you can simply use default constructor of Vector class like this Vector v = new Vector(); however if you need to specify the capacity and increment then you call the parameterized constructor with two int args like this: Vector v= new Vector(10, 5);', 'public class StudentData\r\n{\r\n   private int stuID;\r\n   private String stuName;\r\n   private int stuAge;\r\n   StudentData()\r\n   {\r\n       //Default constructor\r\n       stuID = 100;\r\n       stuName = "New Student";\r\n       stuAge = 18;\r\n   }\r\n   StudentData(int num1, String str, int num2)\r\n   {\r\n       //Parameterized constructor\r\n       stuID = num1;\r\n       stuName = str;\r\n       stuAge = num2;\r\n   }\r\n   //Getter and setter methods\r\n   public int getStuID() {\r\n       return stuID;\r\n   }\r\n   public void setStuID(int stuID) {\r\n       this.stuID = stuID;\r\n   }\r\n   public String getStuName() {\r\n       return stuName;\r\n   }\r\n   public void setStuName(String stuName) {\r\n       this.stuName = stuName;\r\n   }\r\n   public int getStuAge() {\r\n       return stuAge;\r\n   }\r\n   public void setStuAge(int stuAge) {\r\n       this.stuAge = stuAge;\r\n   }\r\n}\r\n\r\nclass TestOverloading\r\n{\r\n   public static void main(String args[])\r\n   {\r\n       //This object creation would call the default constructor\r\n       StudentData myobj = new StudentData();\r\n       System.out.println("Student Name is: "+myobj.getStuName());\r\n       System.out.println("Student Age is: "+myobj.getStuAge());\r\n       System.out.println("Student ID is: "+myobj.getStuID());\r\n\r\n       /*This object creation would call the parameterized\r\n        * constructor StudentData(int, String, int)*/\r\n       StudentData myobj2 = new StudentData(555, "Chaitanya", 25);\r\n       System.out.println("Student Name is: "+myobj2.getStuName());\r\n       System.out.println("Student Age is: "+myobj2.getStuAge());\r\n       System.out.println("Student ID is: "+myobj2.getStuID()); \r\n  }\r\n}', 12, 1),
(219, 55, 'Enum', 'An enum is a special type of data type which is basically a collection (set) of constants.', 'public enum Directions{\r\n  EAST, \r\n  WEST, \r\n  NORTH, \r\n  SOUTH\r\n}', 12, 0),
(220, 12, 'HashMap', 'HashMap is a Map based collection class that is used for storing Key & value pairs. This class makes no guarantees as to the order of the map. It is similar to the Hashtable class except that it is unsynchronized and permits nulls(null values and null key)', '  /* This is how to declare HashMap */\r\n      HashMap<Integer, String> hmap = new HashMap<Integer, String>();\r\n\r\n      /*Adding elements to HashMap*/\r\n      hmap.put(12, "Chaitanya");\r\n      hmap.put(2, "Rahul");\r\n      hmap.put(7, "Singh");\r\n      hmap.put(49, "Ajeet");\r\n      hmap.put(3, "Anuj");\r\n\r\n      /* Display content using Iterator*/\r\n      Set set = hmap.entrySet();\r\n      Iterator iterator = set.iterator();\r\n      while(iterator.hasNext()) {\r\n         Map.Entry mentry = (Map.Entry)iterator.next();\r\n         System.out.print("key is: "+ mentry.getKey() + " & Value is: ");\r\n         System.out.println(mentry.getValue());\r\n      }\r\n\r\n      /* Get values based on key*/\r\n      String var= hmap.get(2);\r\n      System.out.println("Value at index 2 is: "+var);\r\n\r\n      /* Remove values based on key*/\r\n      hmap.remove(3);\r\n      System.out.println("Map key and values after removal:");\r\n      Set set2 = hmap.entrySet();\r\n      Iterator iterator2 = set2.iterator();\r\n      while(iterator2.hasNext()) {\r\n          Map.Entry mentry2 = (Map.Entry)iterator2.next();\r\n          System.out.print("Key is: "+mentry2.getKey() + " & Value is: ");\r\n          System.out.println(mentry2.getValue());\r\n       }', 10, 2),
(221, 22, 'creating Vector objects', 'Vector implements List Interface. Like ArrayList it also maintains insertion order but it is rarely used in non-thread environment as it is synchronized and due to which it gives poor performance in searching, adding, delete and update of its elements.', '//Method 1:\r\nVector vec = new Vector();\r\n\r\n\r\n//Method 2:\r\n//Syntax: \r\nVector object= new Vector(int initialCapacity)\r\nVector vec = new Vector(3);\r\n//It will create a Vector of initial capacity of 3.\r\n\r\n//Method 3:\r\n//Syntax:\r\nVector object= new vector(int initialcapacity, capacityIncrement)\r\nVector vec= new Vector(4, 6)\r\n/*Here we have provided two arguments. The initial capacity is 4 and capacityIncrement is 6. It means upon insertion of 5th element the size would be 10 (4+6) and on 11th insertion it would be 16(10+6).\r\n*/', 10, 2),
(222, 12, 'Thread creation using runnable', 'One way of creating a thread is to create a class that implements the Runnable interface. We must need to give the definition of run() method.\r\nThis run method is the entry point for the thread and thread will be alive till run method finishes its execution.\r\nOnce the thread is created it will start running when start() method gets called. Basically start() method calls run() method implicitly.', 'class MultithreadingDemo implements Runnable{  \r\n  public void run(){  \r\n    System.out.println("My thread is in running state.");  \r\n  }   \r\n  public static void main(String args[]){  \r\n     MultithreadingDemo obj=new MultithreadingDemo();  \r\n     Thread tobj =new Thread(obj);  \r\n     tobj.start();  \r\n }  \r\n}', 10, 2),
(223, 12, 'Thread creation by extending Thread class', 'This is the second way of creating a thread. Here we need to create a new class that extends the Thread class.\r\nThe class should override the run() method which is the entry point for the new thread as described above.\r\nCall start() method to start the execution of a thread.', 'class MultithreadingDemo extends Thread{  \r\n  public void run(){  \r\n    System.out.println("My thread is in running state.");  \r\n  }   \r\n  public static void main(String args[]){  \r\n     MultithreadingDemo obj=new MultithreadingDemo();   \r\n     obj.start();  \r\n  }  \r\n}', 10, 2),
(224, 15, 'Synchronized', 'Multithreading introduces asynchronous behavior to the programs. If a thread is writing some data another thread may be reading the same data at that time. This may bring inconsistency.\r\nWhen two or more threads need access to a shared resource there should be some way that the resource will be used only by one resource at a time. The process to achieve this is called synchronization.\r\nTo implement the synchronous behavior java has synchronous method. Once a thread is inside a synchronized method, no other thread can call any other synchronized method on the same object. All the other threads then wait until the first thread come out of the synchronized block.\r\nWhen we want to synchronize access to objects of a class which was not designed for the multithreaded access and the code of the method which needs to be accessed synchronously is not available with us, in this case we cannot add the synchronized to the appropriate methods. In java we have the solution for this, put the calls to the methods (which needs to be synchronized) defined by this class inside a synchronized block in following manner.', 'Synchronized(object)\r\n{\r\n    // statement to be synchronized\r\n}', 10, 2);
INSERT INTO `notesman` (`notesid`, `uid`, `topic`, `content`, `code`, `likes`, `nlevel`) VALUES
(225, 45, 'execution on JVM', '1) JVM executes Java byte codes\r\n2) Other programming language codes if converted to adequate Java byte code can be executed on JVM\r\n3) JVM is different for different platforms and can also act as a platform itself\r\n4) JVM supports automatic  error handling by  intercepting the errors which can be controlled\r\n5) This feature is useful in platform independency and multi user ability of Java.', '', 10, 0),
(226, 33, 'Compilation of java code', '1) The compiler requires to know the TYPE of every CLASS used in the program source code\r\n2) This is done by setting a default user environment variable CLASSPATH\r\n3) The Javac (Java Compiler) reads the program and converts it into byte code files called as class files', '', 10, 0),
(227, 19, 'for loop', 'It executes a block of statements repeatedly until the specified condition returns false.', 'for (initialization; condition; increment/decrement) {\r\n    statement(s) //block of statements\r\n}', 6, 0),
(228, 24, 'Even or odd number', 'Check whether an entered number is even or odd', 'import java.util.Scanner;\r\n\r\nclass CheckEvenOdd\r\n{\r\n  public static void main(String args[])\r\n  {\r\n    int num;\r\n    System.out.println("Enter an Integer number:");\r\n\r\n    //The input provided by user is stored in num\r\n    Scanner input = new Scanner(System.in);\r\n    num = input.nextInt();\r\n\r\n    /* If number is divisible by 2 then it''s an even number\r\n     * else odd number*/\r\n    if ( num % 2 == 0 )\r\n        System.out.println("Entered number is even");\r\n     else\r\n        System.out.println("Entered number is odd");\r\n  }\r\n}', 10, 0),
(229, 67, 'Exception', 'An Exception can be anything which interrupts the normal flow of the program. When an exception occurs program processing gets terminated and doesn’t continue further. In such cases we get a system generated error message. The good thing about exceptions is that they can be handled. We will cover the handling part later in this same tutorial.\r\n\r\nWhen an exception can occur?\r\nException can occur at runtime (known as runtime exceptions) as well as at compile-time (known Compile-time exceptions).\r\n\r\nReasons for Exceptions\r\nThere can be several reasons for an exception. For example, following situations can cause an exception – Opening a non-existing file, Network connection problem, Operands being manipulated are out of prescribed ranges, class file missing which was supposed to be loaded and so on.', '', 12, 1),
(230, 90, 'try-catch ', 'What is Try Block?\r\n\r\nThe try block contains a block of program statements within which an exception might occur. A try block is always followed by a catch block, which handles the exception that occurs in associated try block. A try block must followed by a Catch block or Finally block or both.\r\n\r\nWhat is Catch Block?\r\n\r\nA catch block must be associated with a try block. The corresponding catch block executes if an exception of a particular type occurs within the try block. For example if an arithmetic exception occurs in try block then the statements enclosed in catch block for arithmetic exception executes.', 'try\r\n{\r\n     //statements that may cause an exception\r\n}\r\ncatch (exception(type) e(object))?\r\n{\r\n     //error handling code\r\n}', 12, 1),
(231, 55, 'Multiple catch blocks ', 'Multiple catch blocks in Java\r\n\r\n1. A try block can have any number of catch blocks.\r\n2. A catch block that is written for catching the class Exception can catch all other exceptions\r\n3. If multiple catch blocks are present in a program then the above mentioned catch block should be placed at the last as per the exception handling best practices.\r\n4. If the try block is not throwing any exception, the catch block will be completely ignored and the program continues.\r\n5. If the try block throws an exception, the appropriate catch block (if one exists) will catch it\r\n–catch(ArithmeticException e) is a catch block that can catch ArithmeticException\r\n–catch(NullPointerException e) is a catch block that can catch NullPointerException\r\n6. All the statements in the catch block will be executed and then the program continues.', 'class Example2{\r\n   public static void main(String args[]){\r\n     try{\r\n         int a[]=new int[7];\r\n         a[4]=30/0;\r\n         System.out.println("First print statement in try block");\r\n     }\r\n     catch(ArithmeticException e){\r\n        System.out.println("Warning: ArithmeticException");\r\n     }\r\n     catch(ArrayIndexOutOfBoundsException e){\r\n        System.out.println("Warning: ArrayIndexOutOfBoundsException");\r\n     }\r\n     catch(Exception e){\r\n        System.out.println("Warning: Some Other exception");\r\n     }\r\n   System.out.println("Out of try-catch block...");\r\n  }\r\n}', 12, 2),
(232, 103, 'Nested try catch', 'The try catch blocks can be nested. One try-catch block can be present in the another try’s body. This is called Nesting of try catch blocks. Each time a try block does not have a catch handler for a particular exception, the stack is unwound and the next try block’s catch (i.e., parent try block’s catch) handlers are inspected for a match.\r\n\r\nIf no catch block matches, then the java run-time system will handle the exception.', '....\r\n//Main try block\r\ntry\r\n{\r\n   statement 1;\r\n   statement 2;\r\n   //try-catch block inside another try block\r\n   try\r\n   {\r\n      statement 3;\r\n      statement 4;\r\n   }\r\n   catch(Exception e1)\r\n   {\r\n       //Exception Message\r\n   }\r\n   //try-catch block inside another try block\r\n   try\r\n   {\r\n       statement 5;\r\n       statement 6;\r\n   }\r\n   catch(Exception e2)\r\n   {\r\n       //Exception Message\r\n   }\r\n}\r\ncatch(Exception e3) //Catch of Main(parent) try block\r\n{\r\n      //Exception Message\r\n}\r\n....', 12, 2),
(233, 255, 'Throws clause', '1. The throws keyword is used in method declaration, in order to explicitly specify the exceptions that a particular method might throw. When a method declaration has one or more exceptions defined using throws clause then the method-call must handle all the defined exceptions.\r\n2. When defining a method you must include a throws clause to declare those exceptions that might be thrown but doesn’t get caught in the method.\r\n3. If a method is using throws clause along with few exceptions then this implicitly tells other methods that – “ If you call me, you must handle these exceptions that I throw”.', 'void MethodName() throws ExceptionName{\r\n    Statement1\r\n    ...\r\n    ...\r\n}', 12, 1),
(234, 234, 'User defined exception', 'User defined exceptions in java are also known as Custom exceptions. Most of the times when we are developing an application in java, we often feel a need to create and throw our own exceptions. These exceptions are known as User defined or Custom exceptions. ', 'lass MyException extends Exception{\r\n    String str1;\r\n    MyException(String str2) {\r\n       str1=str2;\r\n    }\r\n    public String toString(){ \r\n       return ("Output String = "+str1) ;\r\n    }\r\n}\r\n\r\nclass CustomException{\r\n    public static void main(String args[]){\r\n       try{\r\n          throw new MyException("Custom");\r\n          // I''m throwing user defined custom exception above\r\n       }\r\n       catch(MyException exp){\r\n          System.out.println("Hi this is my catch block") ;\r\n          System.out.println(exp) ;\r\n       }\r\n    }\r\n}\r\nOutput:\r\n\r\nHi this is my catch block\r\nOutput String = Custom', 12, 2),
(235, 456, 'Hybrid inheritance', ' that it’s a combine form of single and multiple inheritance. Since java doesn’t support multiple inheritance, the hybrid inheritance is also not possible.\r\n\r\nCase 1:  Using classes: If in above figure B and C are classes then this inheritance is not allowed as a single class cannot extend more than one class (Class D is extending both B and C).\r\n\r\nCase 2: Using Interfaces: If B and C are interfaces then the above hybrid inheritance is allowed as a single class can implement any number of interfaces in java.', 'public class A\r\n{\r\n     public void methodA()\r\n     {\r\n           System.out.println("Class A methodA");\r\n      }\r\n}\r\npublic class B extends A\r\n{\r\n      public void methodA()\r\n      {\r\n           System.out.println("Child class B is overriding inherited method A");\r\n      }\r\n      public void methodB()\r\n      {\r\n           System.out.println("Class B methodB");\r\n       }\r\n}\r\npublic class C extends A\r\n{\r\n      public void methodA()\r\n      {\r\n           System.out.println("Child class C is overriding the methodA");\r\n       }\r\n      public void methodC()\r\n      {\r\n           System.out.println("Class C methodC");\r\n       }\r\n}\r\npublic class D extends B, C\r\n{\r\n      public void methodD()\r\n      {\r\n           System.out.println("Class D methodD");\r\n       }\r\n       public static void main(String args[])\r\n       {\r\n              D obj1= new D();\r\n              obj1.methodD();\r\n              obj1.methodA();\r\n       }\r\n}', 17, 1),
(236, 80, 'abstraction, encapsulation, data hiding', ' Through the process of abstraction, a programmer hides all but the relevant data about an object in order to reduce complexity and increase efficiency. In the same way that abstraction sometimes works in art, the object that remains is a representation of the original, with unwanted detail omitted. The resulting object itself can be referred to as an abstraction, meaning a named entity made up of selected attributes and behavior specific to a particular usage of the originating entity. Abstraction is related to both encapsulation and data hiding.', 'abstract class <class-name>{}\r\n\r\nabstract return_type method_name ();\r\n\r\n//An abstract method in Java doesn''t have body, it’s just a declaration. In order to use abstract method you need to override that method in Subclass.', 12, 0),
(237, 0, 'nested classes, static, dynamic', 'Nested classes are divided into two categories: static and non-static. Nested classes that are declared static are called static nested classes. Non-static nested classes are called inner classes.', 'class OuterClass {\r\n    ...\r\n    static class StaticNestedClass {\r\n        ...\r\n    }\r\n    class InnerClass {\r\n        ...\r\n    }\r\n}\r\n\r\n', 10, 1),
(238, 0, 'Shadowing', 'If a declaration of a type (such as a member variable or a parameter name) in a particular scope (such as an inner class or a method definition) has the same name as another declaration in the enclosing scope, then the declaration shadows the declaration of the enclosing scope. You cannot refer to a shadowed declaration by its name alone.', 'public class ShadowTest {\r\n\r\n    public int x = 0;\r\n\r\n    class FirstLevel {\r\n\r\n        public int x = 1;\r\n\r\n        void methodInFirstLevel(int x) {\r\n            System.out.println("x = " + x);\r\n            System.out.println("this.x = " + this.x);\r\n            System.out.println("ShadowTest.this.x = " + ShadowTest.this.x);\r\n        }\r\n    }\r\n\r\n    public static void main(String... args) {\r\n        ShadowTest st = new ShadowTest();\r\n        ShadowTest.FirstLevel fl = st.new FirstLevel();\r\n        fl.methodInFirstLevel(23);\r\n    }\r\n}\r\n/*The following is the output of this example:\r\n\r\nx = 23\r\nthis.x = 1\r\nShadowTest.this.x = 0\r\n\r\n*/', 10, 1),
(239, 5, 'Single inheritance', 'Single inheritance is damn easy to understand. When a class extends another one class only then we  call it a single inheritance. The below flow diagram shows that class B extends only one class which is A. Here A is a parent class of B and B would be  a child class of A.', 'Class A\r\n{\r\n   public void methodA()\r\n   {\r\n     System.out.println("Base class method");\r\n   }\r\n}\r\n\r\nClass B extends A\r\n{\r\n   public void methodB()\r\n   {\r\n     System.out.println("Child class method");\r\n   }\r\n   public static void main(String args[])\r\n   {\r\n     B obj = new B();\r\n     obj.methodA(); //calling super class method\r\n     obj.methodB(); //calling local method\r\n  }\r\n}', 10, 2),
(240, 5, 'Multiple inheritance', 'Multiple Inheritance” refers to the concept of one class extending (Or inherits) more than one base class. The inheritance we learnt earlier had the concept of one base class or parent. The problem with “multiple inheritance” is that the derived class will have to manage the dependency on two base classes.\r\n\r\nNote 1: Multiple Inheritance is very rarely used in software projects. Using Multiple inheritance often leads to problems in the hierarchy. This results in unwanted complexity when further extending the class.\r\n\r\nNote 2: Most of the new OO languages like Small Talk, Java, C# do not support Multiple inheritance. Multiple Inheritance is supported in C++.', '', 10, 2),
(241, 7, 'Default constructor ', 'A constructor that have no parameter is known as default constructor.', 'class Bike1{  \r\nBike1(){System.out.println("Bike is created");}  \r\npublic static void main(String args[]){  \r\nBike1 b=new Bike1();  \r\n}  \r\n}  ', 10, 0),
(242, 7, 'Parameterized constructor', '\r\nParameterized constructor is used to provide different values to the distinct objects.\r\n', 'class Student4{  \r\n    int id;  \r\n    String name;  \r\n      \r\n    Student4(int i,String n){  \r\n    id = i;  \r\n    name = n;  \r\n    }  \r\n    void display(){System.out.println(id+" "+name);}  \r\n   \r\n    public static void main(String args[]){  \r\n    Student4 s1 = new Student4(111,"Karan");  \r\n    Student4 s2 = new Student4(222,"Aryan");  \r\n    s1.display();  \r\n    s2.display();  \r\n   }  \r\n}  ', 10, 0),
(243, 79, 'parameterized constructor', 'allow users to pass multiple parameters to the constructor when an object is created\r\n', 'class Rectangle {\r\n  int length;\r\n  int breadth;\r\n\r\n  Rectangle(int len,int bre)\r\n  {\r\n  length  = len;\r\n  breadth = bre;\r\n  }\r\n}\r\n\r\nclass RectangleDemo {\r\n  public static void main(String args[]) {\r\n\r\n  Rectangle r1 = new Rectangle(20,10);\r\n\r\n  System.out.println("Length of Rectangle : " + r1.length);\r\n  System.out.println("Breadth of Rectangle : " + r1.breadth);\r\n\r\n  }\r\n}', 12, 0),
(244, 9, 'Anonymous inner classes', 'An inner class declared without a class name is known as an anonymous inner class. In case of anonymous inner classes, we declare and instantiate them at the same time. Generally they are used whenever you need to override the method of a class or an interface. The syntax of an anonymous inner class is as follows:\r\n\r\nAnonymousInner an_inner = new AnonymousInner(){\r\n   public void my_method(){\r\n   ........\r\n   ........\r\n   }	    \r\n};', 'abstract class AnonymousInner{\r\n   public abstract void mymethod();\r\n}\r\n\r\npublic class Outer_class {\r\n   public static void main(String args[]){\r\n      AnonymousInner inner = new AnonymousInner(){\r\n         public void mymethod(){\r\n            System.out.println("This is an example of anonymous inner class");    	  \r\n         }	    \r\n      };\r\n      inner.mymethod();	\r\n   }\r\n}', 10, 2),
(245, 9, 'extends keyword', 'extends is the keyword used to inherit the properties of a class', 'class Calculation{ \r\n   int z;\r\n	\r\n   public void addition(int x, int y){\r\n      z = x+y;\r\n      System.out.println("The sum of the given numbers:"+z);\r\n   }\r\n	\r\n   public void Substraction(int x,int y){\r\n      z = x-y;\r\n      System.out.println("The difference between the given numbers:"+z);\r\n   }\r\n   \r\n}\r\n\r\npublic class My_Calculation extends Calculation{    \r\n  \r\n   public void multiplication(int x, int y){\r\n      z = x*y;\r\n      System.out.println("The product of the given numbers:"+z);\r\n   }\r\n	\r\n   public static void main(String args[]){\r\n      int a = 20, b = 10;\r\n      My_Calculation demo = new My_Calculation();\r\n      demo.addition(a, b);\r\n      demo.Substraction(a, b);\r\n      demo.multiplication(a, b);      \r\n   }\r\n\r\n}', 10, 0),
(246, 12, 'multithreading', 'Multithreading in java is a process of executing multiple threads simultaneously.\r\n\r\nThread is basically a lightweight sub-process, a smallest unit of processing. Multiprocessing and multithreading, both are used to achieve multitasking.\r\n\r\nBut we use multithreading than multiprocessing because threads share a common memory area. They don''t allocate separate memory area so saves memory, and context-switching between the threads takes less time than process.\r\n\r\nJava Multithreading is mostly used in games, animation etc.', '', 10, 1),
(247, 12, 'Inter thread communication', 'Inter-thread communication or Co-operation is all about allowing synchronized threads to communicate with each other.\r\n\r\nCooperation (Inter-thread communication) is a mechanism in which a thread is paused running in its critical section and another thread is allowed to enter (or lock) in the same critical section to be executed.It is implemented by following methods of Object class:\r\n\r\nwait()\r\nnotify()\r\nnotifyAll()', 'class Customer{  \r\nint amount=10000;  \r\n  \r\nsynchronized void withdraw(int amount){  \r\nSystem.out.println("going to withdraw...");  \r\n  \r\nif(this.amount<amount){  \r\nSystem.out.println("Less balance; waiting for deposit...");  \r\ntry{wait();}catch(Exception e){}  \r\n}  \r\nthis.amount-=amount;  \r\nSystem.out.println("withdraw completed...");  \r\n}  \r\n  \r\nsynchronized void deposit(int amount){  \r\nSystem.out.println("going to deposit...");  \r\nthis.amount+=amount;  \r\nSystem.out.println("deposit completed... ");  \r\nnotify();  \r\n}  \r\n}  \r\n  \r\nclass Test{  \r\npublic static void main(String args[]){  \r\nfinal Customer c=new Customer();  \r\nnew Thread(){  \r\npublic void run(){c.withdraw(15000);}  \r\n}.start();  \r\nnew Thread(){  \r\npublic void run(){c.deposit(10000);}  \r\n}.start();  \r\n  \r\n}}  \r\n/*\r\nOutput: going to withdraw...\r\n       Less balance; waiting for deposit...\r\n       going to deposit...\r\n       deposit completed...\r\n       withdraw completed\r\n\r\n*/', 10, 2),
(248, 15, 'Inter process communication', 'Threads enter to acquire lock.\r\nLock is acquired by on thread.\r\nNow thread goes to waiting state if you call wait() method on the object. Otherwise it releases the lock and exits.\r\nIf you call notify() or notifyAll() method, thread moves to the notified state (runnable state).\r\nNow thread is available to acquire lock.\r\nAfter completion of the task, thread releases the lock and exits the monitor state of the object.', '  public synchronized void Question(String msg) {\r\n        if (flag) {\r\n            try {\r\n                wait();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        System.out.println(msg);\r\n        flag = true;\r\n        notify();\r\n    }', 10, 2),
(249, 15, 'Applet life cycle ', 'Four methods in the Applet class give you the framework on which you build any serious applet:\r\n\r\ninit: This method is intended for whatever initialization is needed for your applet. It is called after the param tags inside the applet tag have been processed.\r\n\r\nstart: This method is automatically called after the browser calls the init method. It is also called whenever the user returns to the page containing the applet after having gone off to other pages.\r\n\r\nstop: This method is automatically called when the user moves off the page on which the applet sits. It can, therefore, be called repeatedly in the same applet.\r\n\r\ndestroy: This method is only called when the browser shuts down normally. Because applets are meant to live on an HTML page, you should not normally leave resources behind after a user leaves the page that contains the applet.\r\n\r\npaint: Invoked immediately after the start() method, and also any time the applet needs to repaint itself in the browser. The paint() method is actually inherited from the java.awt.', 'import java.applet.*;\r\nimport java.awt.*;\r\n\r\npublic class HelloWorldApplet extends Applet\r\n{\r\n   public void paint (Graphics g)\r\n   {\r\n      g.drawString ("Hello World", 25, 50);\r\n   }\r\n}', 10, 1),
(250, 19, 'if statement ', 'Executing code when one thing happens rather than something else is so common in programming that that the IF Statement has been developed. The structure of the IF Statement in Java is this:', 'if ( user < 18 ) {\r\n\r\n//DISPLAY MESSAGE\r\n\r\n}', 10, 0),
(251, 67, 'Thread scheduler in java', 'Thread scheduler in java is the part of the JVM that decides which thread should run.\r\n\r\nThere is no guarantee that which runnable thread will be chosen to run by the thread scheduler.\r\n\r\nOnly one thread at a time can run in a single process.\r\n\r\nThe thread scheduler mainly uses preemptive or time slicing scheduling to schedule the threads.', 'Difference between preemptive scheduling and time slicing\r\n\r\nUnder preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence. Under time slicing, a task executes for a predefined slice of time and then reenters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors.', 4, 2),
(252, 19, 'Switch statement ', 'Another way to control the flow of your programs is with something called a switch statement. A switch statement gives you the option to test for a range of values for your variables. They can be used instead of long, complex if … else if statements.', 'switch ( variable_to_test ) {\r\ncase value: \r\ncode_here;\r\nbreak;\r\ncase value: \r\ncode_here;\r\nbreak;\r\ndefault:\r\nvalues_not_caught_above;\r\n\r\n}', 10, 1),
(253, 22, 'Initialize a vector ', ' Initializing the vector data structure without any parameters creates a new vector structure with an initial capacity of ten:\r\nvector();\r\n\r\n2. You can initialize a vector and specify the initial capacity of the vector:\r\n\r\nvector(int size)\r\n\r\n3. You can also specify the increment of the vector. This means you can specify how many elements are added to the vector each time it increases in size.\r\n\r\nvector(int size, int incr);\r\n\r\n4. You can initialize a vector which contains the elements of a collection c:\r\n\r\nvector(collection c);', 'DataClass[] data = new DataClass[10];\r\nArrays.setAll(data, i -> new DataClass());', 10, 2),
(254, 22, 'Arraylist common methods', 'Adding elements to the list\r\nboolean add(Element e)\r\nAdds the specified element to the end of this list.\r\nvoid add(int index, Element e)\r\nAdds the specified element at the specified position in the list.\r\nRemoving elements from the list\r\nvoid clear()\r\nRemoves all the elements from the list.\r\nE remove(int index)\r\nRemoves the element at the specified position in the list.\r\nprotected void removeRange(int start, int end)\r\nRemoves from the list all the elements starting from index start (included) until index end (not included).\r\nGetting elements from the list\r\nE get(int index)\r\nReturns the element at the specified position.\r\nObject[] toArray()\r\nReturns an array containing all the elements of the list in proper sequence.\r\nSetting an element\r\nE set(int index, E element)\r\nReplaces the element at the specified position with the specified element.\r\nSearching elements\r\nboolean contains(Object o)\r\nReturns true if the specified element is found in the list.\r\nint indexOf(Object o)\r\nReturns the index of the first occurrence of the specified element in the list. If this element is not in the list, the method returns -1.\r\nint lastIndexOf(Object o)\r\nReturns the index of the last occurrence of the specified element in the list. If this element is not in the list, the method returns -1.', '', 10, 2),
(255, 22, 'More on arraylist', 'Iterating the arraylist\r\nIterator iterator()\r\nReturns an iterator over the elements in the list.\r\nListIterator listIterator()\r\nReturns a list iterator over the elements in this list.\r\nChecking if the list is empty\r\nboolean isEmpty()\r\nReturns true if the list does not contain any element.\r\nGetting the size of the list\r\nint size()\r\nReturns the length of the list (the number of elements contained in the list).', '', 10, 0),
(256, 103, 'Exceptions', 'Exceptions are events that occur during the execution of programs that disrupt the normal flow of instructions (e.g. divide by zero, array access out of bound, etc.).\r\nIn Java, an exception is an object that wraps an error event that occurred within a method and contains:\r\nInformation about the error including its type\r\nThe state of the program when the error occurred\r\nOptionally, other custom information\r\nException objects can be thrown and caught.', 'public class ExceptionDemo {\r\n\r\n    public static void main (String[] args) {\r\n        System.out.println(divideArray(args));\r\n    }\r\n\r\n    private static int divideArray(String[] array) {\r\n        String s1 = array[0];\r\n        String s2 = array[1];\r\n        return divideStrings(s1, s2);\r\n    }\r\n\r\n    private static int divideStrings(String s1, String s2) {\r\n        int i1 = Integer.parseInt(s1);\r\n        int i2 = Integer.parseInt(s2);\r\n        return divideInts(i1, i2);\r\n    }\r\n\r\n    private static int divideInts(int i1, int i2) {\r\n        return i1 / i2;\r\n    }\r\n}', 12, 2),
(257, 0, 'Shadowing of static functions', 'In Java, if name of a derived class static function is same as base class static function then the derived class static function shadows (or conceals) the base class static function', '// file name: Main.java\r\nclass A {\r\n   static void fun() {\r\n      System.out.println("A.fun()");\r\n   }\r\n}\r\n \r\nclass B extends A { \r\n   static void fun() {   \r\n      System.out.println("B.fun()");\r\n   }\r\n}\r\n \r\npublic class Main {\r\n   public static void main(String args[]) {\r\n      A a = new B();\r\n      a.fun();  // prints A.fun()\r\n   }\r\n}', 10, 2),
(258, 0, 'Returning multiple values in java', 'Java doesn’t support multi-value returns. We can use following solutions to return multiple values.\r\n\r\n \r\n\r\nIf all returned elements are of same type\r\n\r\nWe can return an array in Java. Below is a Java program to demonstrate the same.', '// A Java program to demonstrate that a method\r\n// can return multiple values of same type by\r\n// returning an array\r\nclass Test\r\n{\r\n    // Returns an array such that first element\r\n    // of array is a+b, and second element is a-b\r\n    static int[] getSumAndSub(int a, int b)\r\n    {\r\n        int[] ans = new int[2];\r\n        ans[0] = a + b;\r\n        ans[1] = a - b;\r\n \r\n        // returning array of elements\r\n        return ans;\r\n    }\r\n \r\n    // Driver method\r\n    public static void main(String[] args)\r\n    {\r\n        int[] ans = getSumAndSub(100,50);\r\n        System.out.println("Sum = " + ans[0]);\r\n        System.out.println("Sub = " + ans[1]);\r\n    }\r\n}', 10, 1),
(259, 5, 'Reflection in java', 'Reflection is an API which is used to examine or modify the behavior of methods, classes, interfaces at runtime.\r\n\r\nThe required classes for reflection are provided under java.lang.reflect package.\r\nReflection gives us information about the class to which an object belongs and also the methods of that class which can be executed by using the object.\r\nThrough reflection we can invoke methods at runtime irrespective of the access specifier used with them.\r\nReflection can be used to get information about –\r\n\r\nClass The getClass() method is used to get the name of the class to which an object belongs.\r\nConstructors The getConstructors() method is used to get the public constructors of the class to which an object belongs.\r\nMethods The getMethods() method is used to get the public methods of the class to which an objects belongs.', 'class Demo\r\n{\r\n    public static void main(String args[]) throws Exception\r\n    {\r\n        // Creating object whose property is to be checked\r\n        Test obj = new Test();\r\n \r\n        // Creating class object from the object using\r\n        // getclass method\r\n        Class cls = obj.getClass();\r\n        System.out.println("The name of class is " +\r\n                            cls.getName());\r\n \r\n        // Getting the constructor of the class through the\r\n        // object of the class\r\n        Constructor constructor = cls.getConstructor();\r\n        System.out.println("The name of constructor is " +\r\n                            constructor.getName());\r\n \r\n        System.out.println("The public methods of class are : ");\r\n \r\n        // Getting methods of the class through the object\r\n        // of the class by using getMethods\r\n        Method[] methods = cls.getMethods();\r\n \r\n        // Printing method names\r\n        for (Method method:methods)\r\n            System.out.println(method.getName());\r\n \r\n        // creates object of desired method by providing the\r\n        // method name and parameter class as arguments to\r\n        // the getDeclaredMethod\r\n        Method methodcall1 = cls.getDeclaredMethod("method2",\r\n                                                 int.class);\r\n \r\n        // invokes the method at runtime\r\n        methodcall1.invoke(obj, 19);\r\n \r\n        // creates object of the desired field by providing\r\n        // the name of field as argument to the \r\n        // getDeclaredField method\r\n        Field field = cls.getDeclaredField("s");\r\n \r\n        // allows the object to access the field irrespective\r\n        // of the access specifier used with the field\r\n        field.setAccessible(true);\r\n \r\n        // takes object and the new value to be assigned\r\n        // to the field as arguments\r\n        field.set(obj, "JAVA");\r\n \r\n        // Creates object of desired method by providing the\r\n        // method name as argument to the getDeclaredMethod\r\n        Method methodcall2 = cls.getDeclaredMethod("method1");\r\n \r\n        // invokes the method at runtime\r\n        methodcall2.invoke(obj);\r\n \r\n        // Creates object of the desired method by providing\r\n        // the name of method as argument to the \r\n        // getDeclaredMethod method\r\n        Method methodcall3 = cls.getDeclaredMethod("method3");\r\n \r\n        // allows the object to access the method irrespective \r\n        // of the access specifier used with the method\r\n        methodcall3.setAccessible(true);\r\n \r\n        // invokes the method at runtime\r\n        methodcall3.invoke(obj);\r\n    }\r\n}', 10, 2),
(260, 23, 'this keyword', '‘this’ is a reference variable that refers to the current object.\r\n', '//Java code for using ''this'' keyword to\r\n//refer current class instance variables\r\nclass Test\r\n{\r\n    int a;\r\n    int b;\r\n     \r\n    // Parameterized constructor\r\n    Test(int a, int b)\r\n    {\r\n        this.a = a;\r\n        this.b = b;\r\n    }\r\n \r\n    void display()\r\n    {\r\n        //Displaying value of variables a and b\r\n        System.out.println("a = " + a + "  b = " + b);\r\n    }\r\n \r\n    public static void main(String[] args)\r\n    {\r\n        Test object = new Test(10, 20);\r\n        object.display();\r\n    }\r\n}\r\n\r\n/*\r\na = 10  b = 20\r\n*/', 10, 1),
(261, 23, 'serialization in java', 'Serialization is a mechanism of converting the state of an object into a byte stream. Deserialization is the reverse process where the byte stream is used to recreate the actual Java object in memory. This mechanism is used to persist the object.\r\n\r\nThe byte stream created is platform independent. So, the object serialized on one platform can be deserialized on a different platform.\r\n\r\n \r\nTo make a Java object serializable we implement the java.io.Serializable interface.\r\n\r\nThe ObjectOutputStream class contains writeObject() method for serializing an Object.\r\nprivate void writeObject(ObjectOutputStream stream)\r\n                      throws IOException;\r\nThe ObjectInputStream class contains readObject() method for deserializing an object.\r\nprivate void readObject(ObjectInputStream stream)\r\n                      throws IOException, ClassNotFoundException;\r\n', 'class Test\r\n{\r\n    public static void main(String[] args)\r\n    {   \r\n        Demo object = new Demo(1, "geeksforgeeks");\r\n        String filename = "file.ser";\r\n         \r\n        // Serialization \r\n        try\r\n        {   \r\n            //Saving of object in a file\r\n            FileOutputStream file = new FileOutputStream(filename);\r\n            ObjectOutputStream out = new ObjectOutputStream(file);\r\n             \r\n            // Method for serialization of object\r\n            out.writeObject(object);\r\n             \r\n            out.close();\r\n            file.close();\r\n             \r\n            System.out.println("Object has been serialized");\r\n \r\n        }\r\n         \r\n        catch(IOException ex)\r\n        {\r\n            System.out.println("IOException is caught");\r\n        }\r\n \r\n \r\n        Demo object1 = null;\r\n \r\n        // Deserialization\r\n        try\r\n        {   \r\n            // Reading the object from a file\r\n            FileInputStream file = new FileInputStream(filename);\r\n            ObjectInputStream in = new ObjectInputStream(file);\r\n             \r\n            // Method for deserialization of object\r\n            object1 = (Demo)in.readObject();\r\n             \r\n            in.close();\r\n            file.close();\r\n             \r\n            System.out.println("Object has been deserialized ");\r\n            System.out.println("a = " + object1.a);\r\n            System.out.println("b = " + object1.b);\r\n        }\r\n         \r\n        catch(IOException ex)\r\n        {\r\n            System.out.println("IOException is caught");\r\n        }\r\n         \r\n        catch(ClassNotFoundException ex)\r\n        {\r\n            System.out.println("ClassNotFoundException is caught");\r\n        }\r\n \r\n    }\r\n}', 10, 2),
(262, 7, 'overloading constructor', 'Constructor overloading is way of having more than one constructor which does different-2 tasks. For e.g. Vector class has 4 types of constructors. If you do not want to specify the initial capacity and capacity increment then you can simply use default constructor of Vector class like this Vector v = new Vector(); however if you need to specify the capacity and increment then you call the parameterized constructor with two int args like this: Vector v= new Vector(10, 5);', '', 10, 1),
(263, 9, 'Constructor chaining', 'In the below example the class “ChainingDemo” has 4 constructors and we are calling one constructor from another using this() statement. For e.g. in order to call a constructor with single string argument we have supplied a string in this() statement like this(“hello”).\r\n\r\nNote: this() should always be the first statement in constructor', 'public class ChainingDemo {\r\n   //default constructor of the class\r\n   public ChainingDemo(){\r\n         System.out.println("Default constructor");\r\n   }\r\n   public ChainingDemo(String str){\r\n         this();\r\n    	 System.out.println("Parametrized constructor with single param");\r\n   }\r\n   public ChainingDemo(String str, int num){\r\n         //It will call the constructor with String argument\r\n    	 this("Hello"); \r\n    	 System.out.println("Parametrized constructor with double args");\r\n   }\r\n   public ChainingDemo(int num1, int num2, int num3){\r\n   	// It will call the constructor with (String, integer) arguments\r\n        this("Hello", 2);\r\n        System.out.println("Parametrized constructor with three args");\r\n   }\r\n   public static void main(String args[]){\r\n        //Creating an object using Constructor with 3 int arguments\r\n        ChainingDemo obj = new ChainingDemo(5,5,15);\r\n   }\r\n}', 10, 1),
(264, 15, 'paint method', '1. paint() invokes paintComponent().\r\n2. If the ui property is non-null, paintComponent() invokes ui.update().\r\n3. If the component''s opaque property is true, ui.update() fills the component''s background with the background color and invokes ui.paint().\r\n4. ui.paint() renders the content of the component.', 'public void paintComponent(Graphics g) {\r\n    // Let UI Delegate paint first, which \r\n    // includes background filling since \r\n    // this component is opaque.\r\n\r\n    super.paintComponent(g);       \r\n    g.drawString("This is my custom Panel!",10,20);\r\n    redSquare.paintSquare(g);\r\n}  ', 10, 2),
(265, 78, 'String methods', 'int length(): Returns the number of characters in the String.\r\n"GeeksforGeeks".length();  // returns 13\r\nChar charAt(int i): Returns the character at ith index.\r\n"GeeksforGeeks".charAt(3); // returns  ‘k’\r\nString substring (int i): Return the substring from the ith  index character to end.\r\n"GeeksforGeeks".substring(3); // returns “ksforGeeks”\r\nString substring (int i, int j): Returns the substring from i to j-1 index.\r\n "GeeksforGeeks".substring(2, 5); // returns “eks”\r\n String concat( String str): Concatenates specified string to the end of this string.\r\n String s1 = ”Geeks”;\r\n String s2 = ”forGeeks”;\r\n String output = s1.concat(s2); // returns “GeeksforGeeks”\r\nint indexOf (String s): Returns the index within the string of the first occurrence of the specified string.\r\n String s = ”Learn Share Learn”;\r\n int output = s.indexOf(“Share”); // returns 6', '', 12, 2),
(266, 255, 'string functions', 'int indexOf (String s): Returns the index within the string of the first occurrence of the specified string.\r\n String s = ”Learn Share Learn”;\r\n int output = s.indexOf(“Share”); // returns 6\r\nint indexOf (String s, int i): Returns the index within the string of the first occurrence of the specified string, starting at the specified index.\r\n String s = ”Learn Share Learn”;\r\n int output = s.indexOf(‘a’,3);// returns 8\r\nInt lastindexOf( int ch): Returns the index within the string of the last occurrence of the specified string.\r\n String s = ”Learn Share Learn”;\r\n int output = s.lastindexOf(‘a’); // returns 14\r\nboolean equals( Object otherObj): Compares this string to the specified object.\r\n Boolean out = “Geeks”.equals(“Geeks”); // returns true\r\n Boolean out = “Geeks”.equals(“geeks”); // returns false\r\nboolean  equalsIgnoreCase (String anotherString): Compares string to another string, ignoring case considerations.\r\n Boolean out= “Geeks”.equalsIgnoreCase(“Geeks”); // returns true\r\n Boolean out = “Geeks”.equalsIgnoreCase(“geeks”); // returns true\r\n int compareTo( String anotherString): Compares two string lexicographically.\r\n int out = s1.compareTo(s2);  // where s1 ans s2 are\r\n                             // strings to be compared\r\n\r\n This returns difference s1-s2. If :\r\n out < 0  // s1 comes before s2\r\n out = 0  // s1 and s2 are equal.\r\n out >0   // s1 comes after s2.', '', 12, 2),
(267, 19, 'primitive data types', '1. byte: The byte data type is an 8-bit signed two''s complement integer. It has a minimum value of -128 and a maximum value of 127 (inclusive).\r\n\r\n2. short: The short data type is a 16-bit signed two''s complement integer. It has a minimum value of -32,768 and a maximum value of 32,767 (inclusive). \r\n\r\n3.  int: By default, the int data type is a 32-bit signed two''s complement integer, which has a minimum value of -231 and a maximum value of 231-1. \r\n\r\n4.long: The long data type is a 64-bit two''s complement integer. The signed long has a minimum value of -263 and a maximum value of 263-1\r\n\r\n5. float: The float data type is a single-precision 32-bit IEEE 754 floating point. \r\n\r\n6. double: The double data type is a double-precision 64-bit IEEE 754 floating point.\r\n\r\n7. boolean: The boolean data type has only two possible values: true and false.\r\n\r\n8. char: The char data type is a single 16-bit Unicode character. It has a minimum value of ''\\u0000'' (or 0) and a maximum value of ''\\uffff'' (or 65,535 inclusive).\r\n', '', 10, 0),
(268, 24, 'compound assignment operators', 'You can also combine the arithmetic operators with the simple assignment operator to create compound assignments. For example, x+=1; and x=x+1; both increment the value of x by 1.\r\n', '', 10, 0),
(269, 24, 'String concatenation', 'The + operator can also be used for concatenating (joining) two strings together', 'class ConcatDemo {\r\n    public static void main(String[] args){\r\n        String firstString = "This is";\r\n        String secondString = " a concatenated string.";\r\n        String thirdString = firstString+secondString;\r\n        System.out.println(thirdString);\r\n    }\r\n}', 10, 1),
(270, 24, 'Unary operator', '+	Unary plus operator; indicates positive value (numbers are positive without this, however)\r\n-	Unary minus operator; negates an expression\r\n++	Increment operator; increments a value by 1\r\n--	Decrement operator; decrements a value by 1\r\n!	Logical complement operator; inverts the value of a boolean', 'class UnaryDemo {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        int result = +1;\r\n        // result is now 1\r\n        System.out.println(result);\r\n\r\n        result--;\r\n        // result is now 0\r\n        System.out.println(result);\r\n\r\n        result++;\r\n        // result is now 1\r\n        System.out.println(result);\r\n\r\n        result = -result;\r\n        // result is now -1\r\n        System.out.println(result);\r\n\r\n        boolean success = false;\r\n        // false\r\n        System.out.println(success);\r\n        // true\r\n        System.out.println(!success);\r\n    }\r\n}', 10, 0),
(271, 30, 'break and continue statements', 'The continue statement lets you jump out of the current iteration of a loop and then continue with the next iteration.\r\n\r\nThe break statement breaks out of a loop. It jumps out of the current iteration and ends the immediate loop.', 'System.out.println("continue when i is 2:");\r\n	for (int i = 1; i <= 3; i++) {\r\n		if (i == 2) {\r\n			System.out.print("[continue]");\r\n			continue;\r\n		}\r\n		System.out.print("[i:" + i + "]");\r\n	}\r\n/*\r\ncontinue when i is 2:\r\n[i:1][continue][i:3]\r\n*/\r\n\r\n\r\nSystem.out.println("\\nbreak when i is 2:");\r\n	for (int i = 1; i <= 3; i++) {\r\n		if (i == 2) {\r\n			System.out.print("[break]");\r\n			break;\r\n		}\r\n		System.out.print("[i:" + i + "]");\r\n	}\r\n\r\n', 10, 1),
(272, 30, 'Scanner class', 'To create an object of Scanner class, we usually pass the predefined object System.in, which represents the standard input stream. We may pass an object of class File if we want to read input from a file.\r\nTo read numerical values of a certain data type XYZ, the function to use is nextXYZ(). For example, to read a value of type short, we can use nextShort()\r\nTo read strings, we use nextLine().\r\nTo read a single character, we use next().charAt(0). next() function returns the next token/word in the input as a string and charAt(0) funtion returns the first character in that string.', '// Java program to read data of various types using Scanner class.\r\nimport java.util.Scanner;\r\npublic class ScannerDemo1\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        // Declare the object and initialize with\r\n        // predefined standard input object\r\n        Scanner sc = new Scanner(System.in);\r\n \r\n        // String input\r\n        String name = sc.nextLine();\r\n \r\n        // Character input\r\n        char gender = sc.next().charAt(0);\r\n \r\n        // Numerical data input\r\n        // byte, short and float can be read\r\n        // using similar-named functions.\r\n        int age = sc.nextInt();\r\n        long mobileNo = sc.nextLong();\r\n        double cgpa = sc.nextDouble();\r\n \r\n        // Print the values to check if input was correctly obtained.\r\n        System.out.println("Name: "+name);\r\n        System.out.println("Gender: "+gender);\r\n        System.out.println("Age: "+age);\r\n        System.out.println("Mobile Number: "+mobileNo);\r\n        System.out.println("CGPA: "+cgpa);\r\n    }\r\n}', 10, 0),
(273, 30, 'Redirect Sopln output to file', 'System.out.println()  is used mostly to print messages to the console. However very few of us are actually aware of  its working mechanism.\r\n\r\nSystem is a class defined in the java.lang package.\r\nout is an instance of PrintStream  , which is a public and static member of the class System.\r\nAs all instances of PrintStream class have a public method println(), hence we can invoke the same on out as well. We can assume System.out  represents the standard Output Stream .\r\nOne interesting fact related to the above topic is, we can use System.out.println() to print messages to other sources too (and not just console) . However before doing so , we must reassign the standard output by using the following method of System class:\r\n\r\nSystem.setOut(PrintStream p);\r\nPrintStream can be used for character output to a text file. Below program creates the file A.txt and writes to the file using System.out.println(', '// Java program to demonstrate redirection in System.out.println()\r\nimport java.io.*;\r\n \r\npublic class SystemFact\r\n{\r\n    public static void main(String arr[]) throws FileNotFoundException\r\n    {\r\n        // Creating a File object that represents the disk file.\r\n        PrintStream o = new PrintStream(new File("A.txt"));\r\n \r\n        // Store current System.out before assigning a new value\r\n        PrintStream console = System.out;\r\n \r\n        // Assign o to output stream\r\n        System.setOut(o);\r\n        System.out.println("This will be written to the text file");\r\n \r\n        // Use stored value for output stream\r\n        System.setOut(console);\r\n        System.out.println("This will be written on the console!");\r\n    }\r\n}', 10, 1),
(274, 34, 'Jagged array', 'Jagged array is array of arrays such that member arrays can be of different sizes, i.e., we can create a 2-D arrays but with variable number of columns in each row. These type of arrays are also known as ragged arrays.', '// Program to demonstrate 2-D jagged array in Java\r\nclass Main\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        // Declaring 2-D array with 2 rows\r\n        int arr[][] = new int[2][];\r\n \r\n        // Making the above array Jagged\r\n \r\n        // First row has 3 columns\r\n        arr[0] = new int[3];\r\n \r\n        // Second row has 2 columns\r\n        arr[1] = new int[2];\r\n \r\n        // Initializing array\r\n        int count = 0;\r\n        for (int i=0; i<arr.length; i++)\r\n            for(int j=0; j<arr[i].length; j++)\r\n                arr[i][j] = count++;\r\n \r\n        // Displaying the values of 2D Jagged array\r\n        System.out.println("Contents of 2D Jagged Array");\r\n        for (int i=0; i<arr.length; i++)\r\n        {\r\n            for (int j=0; j<arr[i].length; j++)\r\n                System.out.print(arr[i][j] + " ");\r\n            System.out.println();\r\n        }\r\n    }\r\n}\r\n\r\n/* \r\nOutput:\r\nContents of 2D Jagged Array\r\n0 1 2 \r\n3 4\r\n\r\n*/', 10, 2),
(275, 34, 'instanceof operator', 'The instanceof operator allows you determine the type of an object. It takes an object on the left side of the operator and a type on the right side of the operator and returns a boolean value indicating whether the object belongs to that type or not. ', 'import java.util.Date;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\npublic class InstanceofTest {\r\n\r\n	public static void main(String[] args) {\r\n		Map m = new HashMap();\r\n		System.out.println("m instanceof Map: " + (m instanceof Map));\r\n		System.out.println("m instanceof HashMap: " + (m instanceof HashMap));\r\n		System.out.println("m instanceof Object: " + (m instanceof Object));\r\n		System.out.println("m instanceof Date: " + (m instanceof Date));\r\n		m = null;\r\n		System.out.println("m = null, m instanceof HashMap: " + (m instanceof HashMap));\r\n	}\r\n}\r\n\r\nOutput:\r\nm instanceof Map: true\r\nm instanceof HashMap: true\r\nm instanceof Object: true\r\nm instanceof Date: false\r\nm = null, m instanceof HashMap: false', 10, 1),
(276, 33, 'Overriding', 'Overriding : Overriding is a feature of OOP languages like Java that is related to run-time polymorphism. A subclass (or derived class) provides a specific implementation of a method in superclass (or base class).\r\nThe implementation to be executed is decided at run-time and decision is made according to the object used for call. Note that signatures of both methods must be same.', '// filename Test.java\r\npublic class Test {\r\n    public static void foo() {\r\n        System.out.println("Test.foo() called ");\r\n    }\r\n    public static void foo(int a) { \r\n        System.out.println("Test.foo(int) called ");\r\n    }\r\n    public static void main(String args[])\r\n    { \r\n        Test.foo();\r\n        Test.foo(10);\r\n    }\r\n}', 10, 1);
INSERT INTO `notesman` (`notesid`, `uid`, `topic`, `content`, `code`, `likes`, `nlevel`) VALUES
(277, 33, 'Overloading', 'Overloading is also a feature of OOP languages like Java that is related to compile time (or static) polymorphism. This feature allows different methods to have same name, but different signatures, especially number of input parameters and type of input paramaters. Note that in both C++ and Java, methods cannot be overloaded according to return type.', '// filename Test.java\r\npublic class Test {\r\n    public static void foo() {\r\n        System.out.println("Test.foo() called ");\r\n    }\r\n    public static void foo(int a) { \r\n        System.out.println("Test.foo(int) called ");\r\n    }\r\n    public static void main(String args[])\r\n    { \r\n        Test.foo();\r\n        Test.foo(10);\r\n    }\r\n}', 10, 1),
(278, 36, 'escape sequences', '\\b	backspace\r\n\\f	formfeed\r\n\\n	linefeed\r\n\\r	carriage return\r\n\\t	horizontal tab\r\n\\''	single quote\r\n\\"	double quote\r\n\\\\	backslash', '', 10, 0),
(279, 36, 'sort array of objects with comparator', 'The AvailableLocalesUnsortedAndSorted class gives an example of how an array of objects can be sorted with a Comparator. Comparator is an interface that requires the implementation of the compare() method. The compare method lets us write sorting code to compare two objects and determine which object should go first. If we have the compare method return a negative int, the first argument is less than the second. If it returns 0, the objects are equal in terms of sort order. If it returns a positive in, the first argument is greater than the second.\r\n\r\nThe AvailableLocalesUnsortedAndSorted class gets an array of the available locales and displays them in the default order. It then creates a localComparator object that implements the Comparator interface to allow us to sort on the Locale objects'' toString() values. The Arrays.sort(locales, localeComparator) call specifies to sort the array of Locale objects using the sort logic in localeComparator, which sorts according to the Local objects'' toString() values. It then displays the available locales in their newly sorted order.', 'import java.util.Arrays;\r\nimport java.util.Comparator;\r\nimport java.util.Locale;\r\n\r\npublic class AvailableLocalesUnsortedAndSorted {\r\n\r\n	public static void main(String[] args) throws Exception {\r\n\r\n		Locale locales[] = Locale.getAvailableLocales();\r\n\r\n		System.out.println("Unsorted:");\r\n		displayLocales(locales);\r\n\r\n		Comparator<Locale> localeComparator = new Comparator<Locale>() {\r\n			public int compare(Locale locale1, Locale locale2) {\r\n				return locale1.toString().compareTo(locale2.toString());\r\n			}\r\n		};\r\n		Arrays.sort(locales, localeComparator);\r\n\r\n		System.out.println("Sorted:");\r\n		displayLocales(locales);\r\n	}\r\n\r\n	public static void displayLocales(Locale[] locales) {\r\n		for (Locale locale : locales) {\r\n			System.out.print(locale.toString());\r\n			if (locale != locales[locales.length - 1]) {\r\n				System.out.print(", ");\r\n			}\r\n		}\r\n		System.out.println("\\n");\r\n	}\r\n}', 10, 2),
(280, 36, 'Bit shift operators', 'The bitshift operators take two arguments, and looks like:\r\n\r\n  x << n\r\n  x >> n\r\nwhere x can be any kind of int variable or char variable, and n can be any kind of int variable.\r\nThink of x as a bitstring (since it is), and n as the number of bits to shift left or write. You should be familiar with shifting, because it''s a fundamental operation in, say, insertion sort.', '', 10, 0),
(281, 44, 'static keyword', 'The static keyword denotes that a member variable, or method, can be accessed without requiring an instantiation of the class to which it belongs.\r\n\r\nIn simple terms, it means that you can call a method, even if you''ve never created the object to which it belongs! Every time you run a stand-alone application (which requires a static main method), the virtual machine can call the main method without creating a new application object. Of course, unless the application''s methods are all static, you will need to create an instance of it at some point.\r\n\r\nWith regard to member variables, it means that they can be read from, and written to, without creating an object. You may have noticed that many classes create constants that can be read, without creating an object.\r\n\r\nstatic final int VERSION = 2;\r\n\r\nStatic member variables are shared by all instances of the class to which they belong. When writing classes, this can be a handy feature. Consider the following example, where a counter is used to track how many myObject instantiations have taken place.', 'public class myObject\r\n{\r\n	static int objectCount = 0;\r\n\r\n	public myObject()\r\n	{\r\n		objectCount++;\r\n	}\r\n\r\n	public String toString()\r\n	{\r\n		return new String ("There are " + objectCount + " objects");\r\n	}\r\n}\r\n\r\n/*\r\nAs each new myObject is created, the counter increments. If you were writing an Internet server application, you could track how many concurrent connections existed (remembering that you''d have to include in the destructor or at the end of the connection code a decrement to your count). When used correctly, static member variables and methods can be quite useful!\r\n*/', 10, 0),
(282, 44, 'Increment/decrement operators', '5	% (Modulus)\r\nDivides left hand operand by right hand operand and returns remainder\r\n\r\nExample: B % A will give 0\r\n\r\n6	++ (Increment)\r\nIncreases the value of operand by 1\r\n\r\nExample: B++ gives 21\r\n7	-- ( Decrement )\r\nDecreases the value of operand by 1\r\n\r\nExample: B-- gives 19', '', 10, 0),
(283, 44, 'Conditional operator', 'Conditional operator is also known as the ternary operator. This operator consists of three operands and is used to evaluate Boolean expressions. The goal of the operator is to decide which value should be assigned to the variable. The operator is written as:\r\n\r\nvariable x = (expression) ? value if true : value if false', 'public class Test {\r\n\r\n   public static void main(String args[]){\r\n      int a, b;\r\n      a = 10;\r\n      b = (a == 1) ? 20: 30;\r\n      System.out.println( "Value of b is : " +  b );\r\n\r\n      b = (a == 10) ? 20: 30;\r\n      System.out.println( "Value of b is : " + b );\r\n   }\r\n}', 10, 0),
(284, 45, 'Reference datatypes', 'reference types are any instantiable class as well as arrays\r\nString, Scanner, Random, Die, int[], String[], etc.\r\nreference variables store addresses', '', 10, 0),
(285, 45, 'Access control modifiers', 'Java provides a number of access modifiers to set access levels for classes, variables, methods and constructors. The four access levels are:\r\n\r\nVisible to the package, the default. No modifiers are needed.\r\n\r\nVisible to the class only (private).\r\n\r\nVisible to the world (public).\r\n\r\nVisible to the package and all subclasses (protected).', '', 10, 0),
(286, 45, 'non access modifiers', 'Java provides a number of non-access modifiers to achieve many other functionality.\r\n\r\nThe static modifier for creating class methods and variables\r\n\r\nThe final modifier for finalizing the implementations of classes, methods, and variables.\r\n\r\nThe abstract modifier for creating abstract classes and methods.\r\n\r\nThe synchronized and volatile modifiers, which are used for threads.', '', 10, 0),
(287, 55, 'Interface', 'You cannot instantiate an interface.\r\n\r\nAn interface does not contain any constructors.\r\n\r\nAll of the methods in an interface are abstract.\r\n\r\nAn interface cannot contain instance fields. The only fields that can appear in an interface must be declared both static and final.\r\n\r\nAn interface is not extended by a class; it is implemented by a class.\r\n\r\nAn interface can extend multiple interfaces.', '/* File name : NameOfInterface.java */\r\nimport java.lang.*;\r\n//Any number of import statements\r\n\r\npublic interface NameOfInterface\r\n{\r\n   //Any number of final, static fields\r\n   //Any number of abstract method declarations\\\r\n}', 12, 1),
(288, 55, 'Methods of an interface', 'An interface is implicitly abstract. You do not need to use the abstract keyword while declaring an interface.\r\n\r\nEach method in an interface is also implicitly abstract, so the abstract keyword is not needed.\r\n\r\nMethods in an interface are implicitly public.', '/* File name : Animal.java */\r\ninterface Animal {\r\n\r\n   public void eat();\r\n   public void travel();\r\n}', 12, 1),
(289, 56, 'Overriding', 'The benefit of overriding is: ability to define a behaviour that''s specific to the subclass type which means a subclass can implement a parent class method based on its requirement.\r\n\r\nIn object-oriented terms, overriding means to override the functionality of an existing method.', 'class Animal{\r\n\r\n   public void move(){\r\n      System.out.println("Animals can move");\r\n   }\r\n}\r\n\r\nclass Dog extends Animal{\r\n\r\n   public void move(){\r\n      System.out.println("Dogs can walk and run");\r\n   }\r\n}\r\n\r\npublic class TestDog{\r\n\r\n   public static void main(String args[]){\r\n      Animal a = new Animal(); // Animal reference and object\r\n      Animal b = new Dog(); // Animal reference but Dog object\r\n\r\n      a.move();// runs the method in Animal class\r\n\r\n      b.move();//Runs the method in Dog class\r\n   }\r\n}\r\n\r\n/*\r\n\r\nAnimals can move\r\nDogs can walk and run\r\n\r\n*/', 12, 1),
(290, 56, 'Super keyword', 'Super keyword in java is a reference variable that is used to refer parent class object. Super is an implicit keyword create by JVM and supply each and every java program for performing important role in three places.\r\n\r\nAt variable level\r\nAt method level\r\nAt constructor level', 'class Employee\r\n{\r\nfloat salary=10000;\r\n}\r\nclass HR extends Employee\r\n{\r\nfloat salary=20000;\r\nvoid display()\r\n{\r\nSystem.out.println("Salary: "+super.salary);//print base class salary\r\n}\r\n}\r\nclass Supervarible\r\n{\r\npublic static void main(String[] args)\r\n{\r\nHR obj=new HR();\r\nobj.display();\r\n}\r\n}\r\n\r\n/*\r\n\r\nSalary: 10000.0\r\n\r\n*/', 12, 1),
(291, 56, 'this', 'this keyword is used to refer to current object.\r\nthis is always a reference to the object on which method was invoked.\r\nthis can be used to invoke current class constructor.\r\nthis can be passed as an argument to another method.', 'class Box\r\n {\r\n  Double width, weight, dept; \r\n  Box (double w, double h, double d)\r\n  {\r\n   this.width = w;\r\n   this.height = h;\r\n   this.depth = d;\r\n  }\r\n}\r\nHere the this is used to initialize member of current object.', 12, 1),
(292, 65, 'switch statement', 'A switch statement allows a variable to be tested for equality against a list of values. Each value is called a case, and the variable being switched on is checked for each case.', 'switch(expression){\r\n    case value :\r\n       //Statements\r\n       break; //optional\r\n    case value :\r\n       //Statements\r\n       break; //optional\r\n    //You can have any number of case statements.\r\n    default : //Optional\r\n       //Statements\r\n}', 12, 0),
(293, 65, 'declare array', 'To use an array in a program, you must declare a variable to reference the array, and you must specify the type of array the variable can reference. Here is the syntax for declaring an array variable:\r\n\r\ndataType[] arrayRefVar;   // preferred way.\r\n\r\nor\r\n\r\ndataType arrayRefVar[];  //  works but not preferred way.', '', 12, 0),
(294, 65, 'do while loop', 'Like a while statement, except that it tests the condition at the end of the loop body', 'do\r\n{\r\n   //Statements\r\n}while(Boolean_expression);', 12, 0),
(295, 67, 'FileInputStream  ', 'Java byte streams are used to perform input and output of 8-bit bytes. Though there are many classes related to byte streams but the most frequently used classes are , FileInputStream and FileOutputStream. ', 'Following is an example which makes use of these two classes to copy an input file into an output file:\r\n\r\nimport java.io.*;\r\n\r\npublic class CopyFile {\r\n   public static void main(String args[]) throws IOException\r\n   {\r\n      FileInputStream in = null;\r\n      FileOutputStream out = null;\r\n\r\n      try {\r\n         in = new FileInputStream("input.txt");\r\n         out = new FileOutputStream("output.txt");\r\n         \r\n         int c;\r\n         while ((c = in.read()) != -1) {\r\n            out.write(c);\r\n         }\r\n      }finally {\r\n         if (in != null) {\r\n            in.close();\r\n         }\r\n         if (out != null) {\r\n            out.close();\r\n         }\r\n      }\r\n   }\r\n}', 12, 2),
(296, 67, 'try catch', 'A try statement is used to catch exceptions that might be thrown as your program executes. You should use a try statement whenever you use a statement that might throw an exception That way, your program won’t crash if the exception occurs.', 'try\r\n{\r\n    statements that can throw exceptions\r\n}\r\ncatch (exception-type identifier)\r\n{\r\n    statements executed when exception is thrown\r\n}\r\nfinally\r\n{\r\n    statements that are executed whether or not\r\n    exceptions occur', 12, 2),
(297, 103, 'Types of exception, good for debugging', 'ArithmeticException	You are trying to use your computer to solve a mathematical problem that you cannot solve yourself. Read up on your arithmetics and try again.\r\n\r\nArrayIndexOutOfBoundsException	See IndexOutOfBoundsException. The difference is that this exception refers to more than one finger.\r\n\r\nClassNotFoundException	You seem to have invented your own class\r\n\r\nNumberFormatException	You are using outdated units of measurement, for example inches or pints. Convert to SI. There is a known bug that causes this exception to be thrown if you are very short or tall.', '', 12, 1),
(298, 79, 'static and dynamic binding\r\n', 'Association of method definition to the method call is known as binding. There are two types of binding: Static binding and dynamic binding. Lets discuss them one by one.\r\n\r\nStatic: The binding which can be resolved at compile time by compiler is known as static or early binding. \r\n\r\ndynamic:When compiler is not able to resolve the call/binding at compile time, such binding is known as Dynamic or late Binding. Overriding is a perfect example of dynamic binding as in overriding both parent and child classes have same method.\r\n', '', 12, 1),
(299, 103, 'Aggregation', 'Aggregation is a special form of association. It is also a relationship between two classes like association, however its a directional association, which means it is strictly a one way association. It represents a Has-A relationship.', 'public class Subject {    private String name;    public void setName(String name)   {     this.name = name;   }    public String getName()   {     return name;   } }  public class Student {    private Subject[] studyAreas = new Subject[10];    //the rest of the Student class }', 13, 2),
(300, 234, 'arraylist and vector difference', '1) Synchronization: ArrayList is non-synchronized which means multiple threads can work on ArrayList at the same time. For e.g. if one thread is performing an add operation on ArrayList, there can be an another thread performing remove operation on ArrayList at the same time in a multithreaded environment\r\n\r\nwhile Vector is synchronized. This means if one thread is working on Vector, no other thread can get a hold of it. Unlike ArrayList, only one thread can perform an operation on vector at a time.\r\n\r\n2) Resize: Both ArrayList and Vector can grow and shrink dynamically to maintain the optimal use of storage, however the way they resized is different. ArrayList grow by half of its size when resized while Vector doubles the size of itself by default when grows.\r\n\r\n3) Performance: ArrayList gives better performance as it is non-synchronized. Vector operations gives poor performance as they are thread-safe, the thread which works on Vector gets a lock on it which makes other thread wait till the lock is released.\r\n\r\n4) fail-fast: First let me explain what is fail-fast: If the collection (ArrayList, vector etc) gets structurally modified by any means, except the add or remove methods of iterator, after creation of iterator then the iterator will throw ConcurrentModificationException. Structural modification refers to the addition or deletion of elements from the collection.', '', 12, 1),
(301, 234, 'sort a hashmap', 'We can ignore the generic type and make the methods work for any types like the following.', 'import java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.TreeMap;\r\n \r\npublic class Solution {\r\n	public static void main(String[] args) {\r\n		HashMap<String, Integer> map = new HashMap<String, Integer>();\r\n		map.put("a", 10);\r\n		map.put("b", 30);\r\n		map.put("c", 50);\r\n		map.put("d", 40);\r\n		map.put("e", 20);\r\n		System.out.println(map);\r\n \r\n		Map sortedMap = sortByValue(map);\r\n		System.out.println(sortedMap);\r\n	}\r\n \r\n	public static Map sortByValue(Map unsortedMap) {\r\n		Map sortedMap = new TreeMap(new ValueComparator(unsortedMap));\r\n		sortedMap.putAll(unsortedMap);\r\n		return sortedMap;\r\n	}\r\n \r\n}\r\n \r\nclass ValueComparator implements Comparator {\r\n	Map map;\r\n \r\n	public ValueComparator(Map map) {\r\n		this.map = map;\r\n	}\r\n \r\n	public int compare(Object keyA, Object keyB) {\r\n		Comparable valueA = (Comparable) map.get(keyA);\r\n		Comparable valueB = (Comparable) map.get(keyB);\r\n		return valueB.compareTo(valueA);\r\n	}\r\n}', 12, 2),
(302, 78, 'Regex', 'Regular expressions are a language of string patterns built in to most modern programming languages, including Java 1.4 onward; they can be used for: searching, extracting, and modifying text. ', 'public class ValidateDemo {\r\n	public static void main(String[] args) {\r\n		List<String> input = new ArrayList<String>();\r\n		input.add("123-45-6789");\r\n		input.add("9876-5-4321");\r\n		input.add("987-65-4321 (attack)");\r\n		input.add("987-65-4321 ");\r\n		input.add("192-83-7465");\r\n\r\n\r\n		for (String ssn : input) {\r\n			if (ssn.matches("^(\\\\d{3}-?\\\\d{2}-?\\\\d{4})$")) {\r\n				System.out.println("Found good SSN: " + ssn);\r\n			}\r\n		}\r\n	}\r\n}', 56, 2),
(303, 78, 'Exceptions', 'In Java, exceptions are objects. When you throw an exception, you throw an object. You can''t throw just any object as an exception, however -- only those objects whose classes descend from Throwable. Throwable serves as the base class for an entire family of classes, declared in java.lang, that your program can instantiate and throw. ', 'class VirtualPerson {\r\n    private static final int tooCold = 65;\r\n    private static final int tooHot = 85;\r\n    public void drinkCoffee(CoffeeCup cup) throws\r\n        TooColdException, TooHotException {\r\n        int temperature = cup.getTemperature();\r\n        if (temperature <= tooCold) {\r\n            throw new TooColdException();\r\n        }\r\n        else if (temperature >= tooHot) {\r\n            throw new TooHotException();\r\n        }\r\n        //...\r\n    }\r\n    //...\r\n}\r\n// In Source Packet in file except/ex1/CoffeeCup.java\r\nclass CoffeeCup {\r\n    // 75 degrees Celsius: the best temperature for coffee\r\n    private int temperature = 75;\r\n    public void setTemperature(int val) {\r\n        temperature = val;\r\n    }\r\n    public int getTemperature() {\r\n        return temperature;\r\n    }\r\n    //...\r\n}', 67, 2),
(304, 78, 'packages', 'The package keyword is used to create a package in java.', '//save as Simple.java  \r\npackage mypack;  \r\npublic class Simple{  \r\n public static void main(String args[]){  \r\n    System.out.println("Welcome to package");  \r\n   }  \r\n}  ', 4, 1),
(305, 89, 'exception handling', 'Exception Handling is a mechanism to handle runtime errors such as ClassNotFound, IO, SQL, Remote etc.\r\n\r\nAdvantage of Exception Handling\r\n\r\nThe core advantage of exception handling is to maintain the normal flow of the application. Exception normally disrupts the normal flow of the application that is why we use exception handling.', 'public class Testtrycatch2{  \r\n  public static void main(String args[]){  \r\n   try{  \r\n      int data=50/0;  \r\n   }catch(ArithmeticException e){System.out.println(e);}  \r\n   System.out.println("rest of the code...");  \r\n}  \r\n}  ', 3, 2),
(306, 89, 'Customized Exception ', 'Create customized exceptions by extending the exceptions class', 'class InvalidAgeException extends Exception{  \r\n InvalidAgeException(String s){  \r\n  super(s);  \r\n }  \r\n}  ', 2, 2),
(307, 89, 'delete an arraylist ', 'use the clear() function', 'import java.util.ArrayList;\r\n\r\npublic class ArrayListDemo {\r\n   public static void main(String[] args) {\r\n     \r\n   // create an empty array list with an initial capacity\r\n   ArrayList<Integer> arrlist = new ArrayList<Integer>(5);\r\n\r\n   // use add() method to add elements in the list\r\n   arrlist.add(20);\r\n   arrlist.add(30);\r\n   arrlist.add(10);\r\n   arrlist.add(50);\r\n\r\n   // let us print all the elements available in list\r\n   for (Integer number : arrlist) {\r\n   System.out.println("Number = " + number);\r\n   }      \r\n\r\n   // finding size of this list\r\n   int retval = arrlist.size();\r\n   System.out.println("List consists of "+ retval +" elements");\r\n      \r\n   System.out.println("Performing clear operation !!");\r\n   arrlist.clear();\r\n   retval = arrlist.size();\r\n   System.out.println("Now, list consists of "+ retval +" elements");\r\n   }\r\n}   ', 45, 2),
(308, 89, 'Hashmap create', '\r\n9\r\ndown vote\r\nThose are the options you have:\r\n\r\nJ2SE <5.0 style:\r\n\r\n Map map = new HashMap();\r\nJ2SE 5.0+ style (use of generics):\r\n\r\n Map<KeyType, ValueType> map = new HashMap<KeyType, ValueType>();\r\nGoogle Guava style (shorter and more flexible):\r\n\r\n Map<KeyType, ValueType> map = Maps.newHashMap();', '', 10, 2),
(309, 234, 'manipulate hashmaps', '', 'Set<B> set = map.get(a);\r\nif (set == null)\r\n{\r\n    set = new HashSet<B>();\r\n    map.put(a, set);\r\n}\r\nset.put(b);', 30, 2),
(310, 19, 'sorting an array', 'Using bubble sort. See code', 'public void bubbleSort(int[] array) {\r\n    boolean swapped = true;\r\n    int j = 0;\r\n    int tmp;\r\n    while (swapped) {\r\n        swapped = false;\r\n        j++;\r\n        for (int i = 0; i < array.length - j; i++) {\r\n            if (array[i] > array[i + 1]) {\r\n                tmp = array[i];\r\n                array[i] = array[i + 1];\r\n                array[i + 1] = tmp;\r\n                swapped = true;\r\n            }\r\n        }\r\n    }\r\n}', 15, 0),
(311, 19, 'do-while ', 'To print numbers using do-while loop', 'class DoWhile {\r\n  public static void main(String args[]) {\r\n    int n = 5;\r\n    do\r\n     {\r\n     System.out.println("Sample : " + n);\r\n     n--;\r\n     }while(n > 0);\r\n}', 8, 0),
(312, 24, 'enhanced for loop', 'You can read the line as "iterate on elements from the collection named squares. "The current element will be referenced by the int i."\r\n\r\nYou don''t need to determine how many elements are in the array before looping. There is also no need to specify how to increment the current position. "Under the covers," the enhanced for loop for an array is equivalent to the for loop presented earlier.', 'public class NewForArray {\r\n \r\n   public static void main(String[] args) {\r\n     int j = 0;\r\n     int[] squares = {0, 1, 4, 9, 16, 25};\r\n     for (int i : squares) {\r\n       System.out.printf("%d squared is %d.\\n", j++, i);\r\n     }\r\n   }\r\n }', 10, 0),
(313, 24, 'while loop', 'The while statement continually executes a block of statements while a particular condition is true.', 'class WhileDemo {\r\n    public static void main(String[] args){\r\n        int count = 1;\r\n        while (count < 11) {\r\n            System.out.println("Count is: " + count);\r\n            count++;\r\n        }\r\n    }\r\n}\r\n', 4, 0),
(314, 33, 'jdk - java development kit', 'A Java Development Kit (JDK) is a program development environment for writing Java applets and applications. It consists of a runtime environment that "sits on top" of the operating system layer as well as the tools and programming that developers need to compile, debug, and run applets and applications written in the Java language.', '', 2, 0),
(315, 0, '', '', '', 10, 0),
(316, 33, 'operators in java', 'Simple Assignment Operator\r\n\r\n=       Simple assignment operator\r\nArithmetic Operators\r\n\r\n+       Additive operator (also used\r\n        for String concatenation)\r\n-       Subtraction operator\r\n*       Multiplication operator\r\n/       Division operator\r\n%       Remainder operator\r\nUnary Operators\r\n\r\n+       Unary plus operator; indicates\r\n        positive value (numbers are \r\n        positive without this, however)\r\n-       Unary minus operator; negates\r\n        an expression\r\n++      Increment operator; increments\r\n        a value by 1\r\n--      Decrement operator; decrements\r\n        a value by 1\r\n!       Logical complement operator;\r\n        inverts the value of a boolean\r\nEquality and Relational Operators\r\n\r\n==      Equal to\r\n!=      Not equal to\r\n>       Greater than\r\n>=      Greater than or equal to\r\n<       Less than\r\n<=      Less than or equal to\r\nConditional Operators\r\n\r\n&&      Conditional-AND\r\n||      Conditional-OR\r\n?:      Ternary (shorthand for \r\n        if-then-else statement)\r\n', '', 17, 0),
(317, 34, 'operators in java ', 'Equality and Relational Operators\r\n\r\n==      Equal to\r\n!=      Not equal to\r\n>       Greater than\r\n>=      Greater than or equal to\r\n<       Less than\r\n<=      Less than or equal to\r\nConditional Operators\r\n\r\n&&      Conditional-AND\r\n||      Conditional-OR\r\n?:      Ternary (shorthand for \r\n        if-then-else statement)\r\nType Comparison Operator\r\n\r\ninstanceof      Compares an object to \r\n                a specified type \r\nBitwise and Bit Shift Operators\r\n\r\n~       Unary bitwise complement\r\n<<      Signed left shift\r\n>>      Signed right shift\r\n>>>     Unsigned right shift\r\n&       Bitwise AND\r\n^       Bitwise exclusive OR\r\n|       Bitwise inclusive OR', '', 6, 0),
(318, 34, 'sorting ', 'using insertion sort', 'for i = 2 to length(A)\r\n    x = A[i]\r\n    j = i - 1\r\n    while j > 0 and A[j] > x\r\n        A[j+1] = A[j]\r\n        j = j - 1\r\n    end while\r\n    A[j+1] = x[3]\r\n end for', 10, 0),
(319, 80, 'The JVM', 'At runtime, the JVM reads and interprets .class files and executes the program''s instructions on the native hardware platform for which the JVM was written. The JVM interprets the bytecode just as a CPU would interpret assembly-language instructions. The difference is that the JVM is a piece of software written specifically for a particular platform. The JVM is the heart of the Java language''s "write-once, run-anywhere" principle. Your code can run on any chipset for which a suitable JVM implementation is available. JVMs are available for major platforms like Linux and Windows, and subsets of the Java language have been implemented in JVMs for mobile phones and hobbyist chips.', '', 5, 0),
(320, 80, 'What is an object?', 'Structured programming languages like C and COBOL follow a different programming paradigm from object-oriented ones. The structured-programming paradigm is highly data oriented: You have data structures, and then program instructions act on that data. Object-oriented languages such as the Java language combine data and program instructions into objects.\r\nAn object is a self-contained entity that contains attributes and behavior, and nothing more. Instead of having a data structure with fields (attributes) and passing that structure around to all of the program logic that acts on it (behavior), in an object-oriented language, data and program logic are combined. This combination can occur at vastly different levels of granularity, from fine-grained objects such as a Number, to coarse-grained objects, such as a FundsTransfer service in a large banking application.\r\nParent and child objects\r\nA parent object is one that serves as the structural basis for deriving more-complex child objects. A child object looks like its parent but is more specialized. With the object-oriented paradigm, you can reuse the common attributes and behavior of the parent object, adding to its child objects attributes and behavior that differ. (You learn more about inheritance in the next section of this tutorial.)', '', 15, 0),
(321, 80, 'Key words', 'Like any programming language, the Java language designates certain words that the compiler recognizes as special. For that reason, you''re not allowed to use them for naming your Java constructs. The list of reserved words is surprisingly short:\r\nabstract\r\nassert\r\nboolean\r\nbreak\r\nbyte\r\ncase\r\ncatch\r\nchar\r\nclass\r\nconst\r\ncontinue\r\ndefault\r\ndo\r\ndouble\r\nelse\r\nenum\r\nextends\r\nfinal\r\nfinally\r\nfloat\r\nfor\r\ngoto\r\nif\r\nimplements\r\nimport\r\ninstanceof\r\nint\r\ninterface\r\nlong\r\nnative\r\nnew\r\npackage\r\nprivate\r\nprotected\r\npublic\r\nreturn\r\nshort\r\nstatic\r\nstrictfp\r\nsuper\r\nswitch\r\nsynchronized\r\nthis\r\nthrow\r\nthrows\r\ntransient\r\ntry\r\nvoid\r\nvolatile\r\nwhile', '', 5, 0),
(322, 80, 'Java class', 'A class is a blueprint for a discrete entity (object) that contains attributes and behavior. The class defines the object''s basic structure, and at runtime, your application creates an instance of the object. An object has a crisp boundary and a state, and it can do things when correctly asked. Every object-oriented language has rules about how to define a class.', 'package packageName;\r\nimport ClassNameToImport; accessSpecifier class ClassName {\r\n  accessSpecifier dataType variableName [= initialValue];\r\n  accessSpecifier ClassName([argumentList]) {\r\n    constructorStatement(s)\r\n  }\r\n  accessSpecifier returnType methodName ([argumentList]) {\r\n    methodStatement(s)\r\n  }\r\n  // This is a comment\r\n  /* This is a comment too */\r\n  /* This is a\r\n   multiline\r\n     comment */\r\n}', 20, 0),
(323, 12, 'Packaging classes', 'With the Java language, you can choose the names for your classes, such as Account, Person, or LizardMan. At times, you might end up using the same name to express two slightly different concepts. This situation is called a name collision, and it happens frequently. The Java language uses packages to resolve these conflicts.\r\nA Java package is a mechanism for providing a namespace— an area inside of which names are unique, but outside of which they might not be. To identify a construct uniquely, you must fully qualify it by including its namespace.\r\nPackages also give you a nice way to build more-complex applications with discrete units of functionality.', 'package orgType.orgName.appName.compName;\r\n\r\norgType is the organization type, such as com, org, or net.\r\norgName is the name of the organization''s domain, such as makotojava, oracle, or ibm.\r\nappName is the name of the application, abbreviated.\r\ncompName is the name of the component.', 15, 2),
(324, 12, 'REGEX', 'A regular expression defines a search pattern for strings. The abbreviation for regular expression is regex. The search pattern can be anything from a simple character, a fixed string or a complex expression containing special characters describing the pattern. The pattern defined by the regex may match one or several times or not at all for a given string.\r\n\r\nRegular expressions can be used to search, edit and manipulate text.\r\n\r\nThe process of analyzing or modifying a text with a regex is called: The regular expression is applied to the text (string) . The pattern defined by the regex is applied on the text from left to right. Once a source character has been used in a match, it cannot be reused. For example, the regex aba will match ababababa only two times (aba_aba__).\r\n', 'this is text----Matches exactly "this is text"\r\nthis\\s+is\\s+text----Matches the word "this" followed by one or more whitespace characters followed by the word "is" followed by one or more whitespace characters followed by the word "text".\r\n^\\d+(\\.\\d+)?----^ defines that the patter must start at beginning of a new line. \\d+ matches one or several digits. The ? makes the statement in brackets optional. \\. matches ".", parentheses are used for grouping. Matches for example "5", "1.5" and "2.21".', 15, 2),
(325, 12, 'Using regular expressions with String methods\r\n', 'Strings in Java have built-in support for regular expressions. Strings have four built-in methods for regular expressions, i.e., the matches(), split()), replaceFirst() and replaceAll() methods. The replace() method does NOT support regular expressions.\r\n\r\nThese methods are not optimized for performance. We will later use classes which are optimized for performance.', 's.matches("regex")----Evaluates if "regex" matches s. Returns only true if the WHOLE string can be matched.\r\ns.split("regex")----Creates an array with substrings of s divided at occurrence of "regex". "regex" is not included in the result.\r\ns.replaceFirst("regex"), "replacement"---	Replaces first occurance of "regex" with "replacement.\r\ns.replaceAll("regex"), "replacement"---	Replaces all occurances of "regex" with "replacement.', 15, 2),
(326, 56, 'Regex pattern matcher', 'For advanced regular expressions the java.util.regex.Pattern and java.util.regex.Matcher classes are used.\r\n\r\nYou first create a Pattern object which defines the regular expression. This Pattern object allows you to create a Matcher object for a given string. This Matcher object then allows you to do regex operations on a String.', 'package de.vogella.regex.test;\r\n\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\npublic class RegexTestPatternMatcher {\r\n  public static final String EXAMPLE_TEST = "This is my small example string which I''m going to use for pattern matching.";\r\n\r\n  public static void main(String[] args) {\r\n    Pattern pattern = Pattern.compile("\\\\w+");\r\n    // in case you would like to ignore case sensitivity,\r\n    // you could use this statement:\r\n    // Pattern pattern = Pattern.compile("\\\\s+", Pattern.CASE_INSENSITIVE);\r\n    Matcher matcher = pattern.matcher(EXAMPLE_TEST);\r\n    // check all occurance\r\n    while (matcher.find()) {\r\n      System.out.print("Start index: " + matcher.start());\r\n      System.out.print(" End index: " + matcher.end() + " ");\r\n      System.out.println(matcher.group());\r\n    }\r\n    // now create a new pattern and matcher to replace whitespace with tabs\r\n    Pattern replace = Pattern.compile("\\\\s+");\r\n    Matcher matcher2 = replace.matcher(EXAMPLE_TEST);\r\n    System.out.println(matcher2.replaceAll("\\t"));\r\n  }\r\n} ', 15, 2),
(327, 56, 'JAVA swing', 'Swing is a GUI widget toolkit for Java. It is part of Oracle''s Java Foundation Classes (JFC) – an API for providing a graphical user interface (GUI) for Java programs.\r\n\r\nSwing was developed to provide a more sophisticated set of GUI components than the earlier Abstract Window Toolkit (AWT). Swing provides a native look and feel that emulates the look and feel of several platforms, and also supports a pluggable look and feel that allows applications to have a look and feel unrelated to the underlying platform. It has more powerful and flexible components than AWT. In addition to familiar components such as buttons, check boxes and labels, Swing provides several advanced components such as tabbed panel, scroll panes, trees, tables, and lists.\r\n\r\nUnlike AWT components, Swing components are not implemented by platform-specific code. Instead, they are written entirely in Java and therefore are platform-independent. The term "lightweight" is used to describe such an element.[1]\r\n\r\nSwing is currently in the process of being replaced by JavaFX.\r\n', '', 10, 2),
(328, 56, 'JFC and Swing', 'Swing GUI Components-----Includes everything from buttons to split panes to tables. Many components are capable of sorting, printing, and drag and drop, to name a few of the supported features.\r\nPluggable Look-and-Feel Support	The look and feel of Swing applications is pluggable, allowing a choice of look and feel. For example, the same program can use either the Java or the Windows look and feel. Additionally, the Java platform supports the GTK+ look and feel, which makes hundreds of existing look and feels available to Swing programs. Many more look-and-feel packages are available from various sources.\r\nAccessibility API----Enables assistive technologies, such as screen readers and Braille displays, to get information from the user interface.\r\nJava 2D API-----Enables developers to easily incorporate high-quality 2D graphics, text, and images in applications and applets. Java 2D includes extensive APIs for generating and sending high-quality output to printing devices.\r\nInternationalization----Allows developers to build applications that can interact with users worldwide in their own languages and cultural conventions. With the input method framework developers can build applications that accept text in languages that use thousands of different characters, such as Japanese, Chinese, or Korean.', '', 15, 2),
(329, 56, 'SWING PACKAGES', 'The Swing API is powerful, flexible — and immense. The Swing API has 18 public packages:\r\n\r\njavax.accessibility	\r\njavax.swing.plaf	\r\njavax.swing.text\r\njavax.swing	\r\njavax.swing.plaf.basic	javax.swing.text.html\r\njavax.swing.border	javax.swing.plaf.metal	javax.swing.text.html.parser\r\njavax.swing.colorchooser	javax.swing.plaf.multi	javax.swing.text.rtf\r\njavax.swing.event	javax.swing.plaf.synth	\r\njavax.swing.tree\r\njavax.swing.filechooser	javax.swing.table	\r\njavax.swing.undo\r\nFortunately, most programs use only a small subset of the API. This trail sorts out the API for you, giving you examples of common code and pointing you to methods and classes you''re likely to need. Most of the code in this trail uses only one or two Swing packages:\r\n\r\njavax.swing\r\njavax.swing.event (not always required)', '', 10, 2),
(330, 22, 'Packages in java and how to use them?', 'Packages in Java is a mechanism to encapsulate a group of classes, interfaces and sub packages. Many implementations of Java use a hierarchical file system to manage source and class files. It is easy to organize class files into packages. All we need to do is put related class files in the same directory, give the directory a name that relates to the purpose of the classes, and add a line to the top of each class file that declares the package name, which is the same as the directory name where they reside.\r\n\r\nIn java there are already many predefined packages that we use while programming.', 'For example: java.lang, java.io, java.util etc.\r\nHowever one of the most useful feature of java is that we can define our own packages', 15, 2),
(331, 22, 'Multithreading ', 'Java was one of the first languages to make multithreading easily available to developers. Java had multithreading capabilities from the very beginning. Therefore, Java developers often face the problems described above. That is the reason I am writing this trail on Java concurrency. As notes to myself, and any fellow Java developer whom may benefit from it.\r\n\r\nThe trail will primarily be concerned with multithreading in Java, but some of the problems occurring in multithreading are similar to problems occurring in multitasking and in distributed systems. References to multitasking and distributed systems may therefore occur in this trail too. Hence the word "concurrency" rather than "multithreading".', '', 10, 2),
(332, 22, 'Creating and Starting Threads', 'Creating a thread in Java is done like this:\r\n\r\n  Thread thread = new Thread();\r\n\r\n\r\nTo start the Java thread you will call its start() method, like this:\r\n\r\n  thread.start();', ' public class MyThread extends Thread {\r\n\r\n    public void run(){\r\n       System.out.println("MyThread running");\r\n    }\r\n  }\r\n\r\n\r\nTo create and start the above thread you can do like this:\r\n\r\n  MyThread myThread = new MyThread();\r\n  myTread.start();', 25, 2),
(333, 22, 'Runnable Interface Implementation', 'A way to specify what code a thread should run is by creating a class that implements java.lang.Runnable. The Runnable object can be executed by a Thread', 'public class MyRunnable implements Runnable {\r\n\r\n    public void run(){\r\n       System.out.println("MyRunnable running");\r\n    }\r\n  }\r\n\r\nThread thread = new Thread(new MyRunnable());\r\n   thread.start();\r\n', 10, 2),
(334, 22, 'Thread.currentThread()', 'The Thread.currentThread() method returns a reference to the Thread instance executing currentThread() . This way you can get access to the Java Thread object representing the thread executing a given block of code. Here is an example of how to use Thread.currentThread() :\r\n\r\nString threadName = Thread.currentThread().getName();', '', 15, 2),
(335, 15, 'Exception classes', 'In Java, exceptions are objects. When you throw an exception, you throw an object. You can''t throw just any object as an exception, however -- only those objects whose classes descend from Throwable. Throwable serves as the base class for an entire family of classes, declared in java.lang, that your program can instantiate and throw. A small part of this family is shown in Figure 1.\r\n\r\nAs you can see in Figure 1, Throwable has two direct subclasses, Exception and Error. Exceptions (members of the Exception family) are thrown to signal abnormal conditions that can often be handled by some catcher, though it''s possible they may not be caught and therefore could result in a dead thread. Errors (members of the Error family) are usually thrown for more serious problems, such as OutOfMemoryError, that may not be so easy to handle. In general, code you write should throw only exceptions, not errors. Errors are usually thrown by the methods of the Java API, or by the Java virtual machine itself.', '// In source packet in file except/ex9/Example9a.java\r\nimport java.io.*;\r\nclass Example9a {\r\n    public static void main(String[] args)\r\n        throws IOException {\r\n        if (args.length == 0) {\r\n            System.out.println("Must give filename as first arg.");\r\n            return;\r\n        }\r\n        FileInputStream in;\r\n        try {\r\n            in = new FileInputStream(args[0]);\r\n        }\r\n        catch (FileNotFoundException e) {\r\n            System.out.println("Can''t find file: " + args[0]);\r\n            return;\r\n        }\r\n        int ch;\r\n        while ((ch = in.read()) != -1) {\r\n            System.out.print((char) ch);\r\n        }\r\n        System.out.println();\r\n        in.close();\r\n    }\r\n}', 20, 2),
(336, 15, 'Checked vs Unchecked exceptions', 'The big question, then, is whether to throw a "checked" or an "unchecked" exception. A checked exception is some subclass of Exception (or Exception itself), excluding class RuntimeException and its subclasses. Unchecked exceptions are RuntimeException and any of its subclasses. Class Error and its subclasses also are unchecked, but as you should be focusing on throwing exceptions only, your decision should be whether to throw a subclass of RuntimeException (an unchecked exception) or some other subclass of Exception (a checked exception).\r\n\r\nIf you throw a checked exception (and don''t catch it), you will need to declare the exception in your method''s throws clause. Client programmers who wish to call your method will then need to either catch and handle the exception within the body of their methods, or declare the exception in the throws clause of their methods. Making an exception checked forces client programmers to deal with the possibility that the exception will be thrown.', '', 15, 2),
(337, 15, 'What is thread safety?', 'Thread safety simply means that the fields of an object or class always maintain a valid state, as observed by other objects and classes, even when used concurrently by multiple threads.\r\n\r\nThere are two big reasons you need to think about thread safety when you design classes and objects in Java:\r\n\r\nSupport for multiple threads is built into the Java language and API\r\nAll threads inside a Java virtual machine (JVM) share the same heap and method area\r\nBecause multithreading is built into Java, it is possible that any class you design eventually may be used concurrently by multiple threads. You needn''t (and shouldn''t) make every class you design thread-safe, because thread safety doesn''t come for free. But you should at least think about thread safety every time you design a Java class. You''ll find a discussion of the costs of thread safety and guidelines concerning when to make classes thread-safe later in this article.\r\n\r\n', '', 10, 2),
(338, 36, 'HashMAp', 'A HashMap contains values based on the key. It implements the Map interface and extends AbstractMap class.\r\nIt contains only unique elements.\r\nIt may have one null key and multiple null values.\r\nIt maintains no order.', 'import java.util.*;  \r\nclass TestCollection13{  \r\n public static void main(String args[]){  \r\n   \r\n  HashMap<Integer,String> hm=new HashMap<Integer,String>();  \r\n  \r\n  hm.put(100,"Amit");  \r\n  hm.put(101,"Vijay");  \r\n  hm.put(102,"Rahul");  \r\n  \r\n  for(Map.Entry m:hm.entrySet()){  \r\n   System.out.println(m.getKey()+" "+m.getValue());  \r\n  }  \r\n }  \r\n}  ', 25, 2),
(339, 5, 'LinkedHashMap class', 'A LinkedHashMap contains values based on the key. It implements the Map interface and extends HashMap class.\r\nIt contains only unique elements.\r\nIt may have one null key and multiple null values.\r\nIt is same as HashMap instead maintains insertion order.', 'import java.util.*;  \r\nclass TestCollection14{  \r\n public static void main(String args[]){  \r\n   \r\n  LinkedHashMap<Integer,String> hm=new LinkedHashMap<Integer,String>();  \r\n  \r\n  hm.put(100,"Amit");  \r\n  hm.put(101,"Vijay");  \r\n  hm.put(102,"Rahul");  \r\n  \r\nfor(Map.Entry m:hm.entrySet()){  \r\n   System.out.println(m.getKey()+" "+m.getValue());  \r\n  }  \r\n }  \r\n}  ', 25, 2),
(340, 5, 'HashMap (TreeMap class)', 'A TreeMap contains values based on the key. It implements the NavigableMap interface and extends AbstractMap class.\r\nIt contains only unique elements.\r\nIt cannot have null key but can have multiple null values.\r\nIt is same as HashMap instead maintains ascending order.', 'import java.util.*;  \r\nclass TestCollection15{  \r\n public static void main(String args[]){  \r\n   \r\n  TreeMap<Integer,String> hm=new TreeMap<Integer,String>();  \r\n  \r\n  hm.put(100,"Amit");  \r\n  hm.put(102,"Ravi");  \r\n  hm.put(101,"Vijay");  \r\n  hm.put(103,"Rahul");  \r\n  \r\n  for(Map.Entry m:hm.entrySet()){  \r\n   System.out.println(m.getKey()+" "+m.getValue());  \r\n  }  \r\n }  \r\n}  ', 15, 2),
(341, 77, 'How final keyword works?', 'In Java we use final keyword to variables to make its values not to be changed. But I see that you can change the value in the constructor / methods of the class. Again, if the variable is static then it is a compilation error.', 'private final List foo;\r\n\r\npublic Test()\r\n{\r\n    foo = new ArrayList();\r\n    foo.add("foo"); // Modification-1\r\n}\r\npublic static void main(String[] args) \r\n{\r\n    Test t = new Test();\r\n    t.foo.add("bar"); // Modification-2\r\n    System.out.println("print - " + t.foo);\r\n}', 25, 1),
(342, 33, 'Stacks and queues in java', 'we introduce two closely-related data types for manipulating arbitrarily large collections of objects: the stack and the queue. Each is defined by two basic operations: insert a new item, and remove an item. When we insert an item, our intent is clear. But when we remove an item, which one do we choose? The rule used for a queue is to always remove the item that has been in the collection the most amount of time. This policy is known as first-in-first-out or FIFO. The rule used for a stack is to always remove the item that has been in the collection the least amount of time. This policy is known as last-in first-out or LIFO.', '', 10, 1),
(343, 77, 'linkedlist in java', 'For classes such as stacks that implement collections of objects, an important objective is to ensure that the amount of space used is always proportional to the number of items in the collection. Now we consider the use of a fundamental data structure known as a linked list that can provide implementations of collections (and, in particular, stacks) that achieves this important objective.\r\nA linked list is a recursive data structure defined as follows: a linked list is either empty (null) or a reference to a node having a reference to a linked list. The node in this definition is an abstract entity that might hold any kind of data in addition to the node reference that characterizes its role in building linked lists. With object-oriented programming, implementing linked lists is not difficult. We start with a simple example of a class for the node abstraction:', 'class Node { \r\n   String item; \r\n   Node next; \r\n}\r\n\r\n\r\nNode first  = new Node(); \r\nNode second = new Node(); \r\nNode third  = new Node(); \r\n\r\nfirst.item  = "to"; \r\nsecond.item = "be"; \r\nthird.item  = "or";\r\n\r\nfirst.next  = second; \r\nsecond.next = third; \r\nthird.next  = null;', 15, 1);
INSERT INTO `notesman` (`notesid`, `uid`, `topic`, `content`, `code`, `likes`, `nlevel`) VALUES
(344, 79, 'Stack in Java', 'A stack is a LIFO sequence. Addition and removal takes place only at one end, called the top.\r\n\r\nOperations\r\n\r\npush(x): add an item on the top\r\npop: remove the item at the top\r\npeek: return the item at the top (without removing it)\r\nsize: return the number of items in the stack\r\nisEmpty: return whether the stack has no items', 'package edu.lmu.cs.collections;\r\n\r\n/**\r\n * A small stack interface.  You can query the size of the stack and\r\n * ask whether it is empty, push items, pop items, and peek at the top\r\n * item.\r\n */\r\npublic interface Stack {\r\n\r\n    /**\r\n     * Adds the given item to the top of the stack.\r\n     */\r\n    void push(Object item);\r\n\r\n    /**\r\n     * Removes the top item from the stack and returns it.\r\n     * @exception java.util.NoSuchElementException if the stack is empty.\r\n     */\r\n    Object pop();\r\n\r\n    /**\r\n     * Returns the top item from the stack without popping it.\r\n     * @exception java.util.NoSuchElementException if the stack is empty.\r\n     */\r\n    Object peek();\r\n\r\n    /**\r\n     * Returns the number of items currently in the stack.\r\n     */\r\n    int size();\r\n\r\n    /**\r\n     * Returns whether the stack is empty or not.\r\n     */\r\n    boolean isEmpty();\r\n}', 20, 1),
(345, 77, 'Linked implementation of stack', '', 'package edu.lmu.cs.collections;\r\n\r\nimport java.util.NoSuchElementException;\r\n\r\n/**\r\n * An implementation of the stack interface using singly-linked\r\n * nodes.\r\n */\r\npublic class LinkedStack implements Stack {\r\n    private class Node {\r\n        public Object data;\r\n        public Node next;\r\n        public Node(Object data, Node next) {\r\n            this.data = data;\r\n            this.next = next;\r\n        }\r\n    }\r\n\r\n    private Node top = null;\r\n\r\n    public void push(Object item) {\r\n        top = new Node(item, top);\r\n    }\r\n\r\n    public Object pop() {\r\n        Object item = peek();\r\n        top = top.next;\r\n        return item;\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return top == null;\r\n    }\r\n\r\n    public Object peek() {\r\n        if (top == null) {\r\n            throw new NoSuchElementException();\r\n        }\r\n        return top.data;\r\n    }\r\n\r\n    public int size() {\r\n        int count = 0;\r\n        for (Node node = top; node != null; node = node.next) {\r\n            count++;\r\n        }\r\n        return count;\r\n    }\r\n}', 20, 1),
(346, 90, 'Stack ADT', 'ctions we have seen include arrays and lists.\r\n\r\nAs I said, an ADT is defined by the operations you can perform on it. Stacks can perform only the following operations:\r\n\r\nconstructor\r\nCreate a new, empty stack.\r\npush\r\nAdd a new item to the stack.\r\npop\r\nRemove and return an item from the stack. The item that is returned is always the last one that was added.\r\nempty\r\nCheck whether the stack is empty.\r\nA stack is sometimes called a "last in, first out," or LIFO data structure, because the last item added is the first to be removed.', '', 15, 1),
(347, 90, 'Java stack object', 'Java provides a built-in object type called Stack that implements the Stack ADT. You should make some effort to keep these two things---the ADT and the Java implementation---straight. Before using the Stack class, we have to import it from java.util.\r\n\r\nThen the syntax for constructing a new Stack is\r\n\r\n    Stack stack = new Stack (); \r\nInitially the stack is empty, as we can confirm with the empty method, which returns a boolean:\r\n\r\n    System.out.println (stack.empty ()); \r\nA stack is a generic data structure, which means that we can add any type of item to it. In the Java implementation, though, we can only add object types. For our first example, we''ll use Node objects, as defined in the previous chapter. Let''s start by creating and printing a short list.\r\n\r\n    LinkedList list = new LinkedList (); \r\n    list.addFirst (3); \r\n    list.addFirst (2); \r\n    list.addFirst (1); \r\n    list.print (); \r\nThe output is (1, 2, 3). To put a Node object onto the stack, use the push method:\r\n\r\n    stack.push (list.head); \r\nThe following loop traverses the list and pushes all the nodes onto the stack:\r\n\r\n    for (Node node = list.head; node != null; node = node.next) { \r\n        stack.push (node); \r\n    } \r\nWe can remove an element from the stack with the pop method.\r\n\r\n    Object obj = stack.pop (); \r\nThe return type from pop is Object! That''s because the stack implementation doesn''t really know the type of the objects it contains. When we pushed the Node objects, they were automatically converted to Objects. When we get them back from the stack, we have to cast them back to Nodes.\r\n\r\nNode node = (Node) obj; \r\nSystem.out.println (node); \r\nUnfortunately, the burden falls on the programmer to keep track of the objects in the stack and cast them back to the right type when they are removed. If you try to cast an object to the wrong type, you get a ClassCastException.\r\n\r\nThe following loop is a common idiom for popping all the elements from a stack, stopping when it is empty:\r\n\r\n    while (!stack.empty ()) { \r\n        Node node = (Node) stack.pop (); \r\n        System.out.print (node + " "); \r\n    } \r\n\r\nThe output is 3 2 1. In other words, we just used a stack to print the elements of a list backwards! Granted, it''s not the standard format for printing a list, but using a stack it was remarkably easy to do.\r\n\r\nYou should compare this code to the implementations of printBackward in the previous chapter. There is a natural parallel between the recursive version of printBackward and the stack algorithm here. The difference is that printBackward uses the run-time stack to keep track of the nodes while it traverses the list, and then prints them on the way back from the recursion. The stack algorithm does the same thing, just using a Stack object instead of the run-time stack.', '', 20, 1),
(348, 77, 'Queue Implementations in java', 'Being a Collection subtype all methods in the Collection interface are also available in the Queue interface.\r\n\r\nSince Queue is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following Queue implementations in the Java Collections API:\r\n\r\njava.util.LinkedList\r\njava.util.PriorityQueue\r\nLinkedList is a pretty standard queue implementation.\r\n\r\nPriorityQueue stores its elements internally according to their natural order (if they implement Comparable), or according to a Comparator passed to the PriorityQueue.\r\n\r\nThere are also Queue implementations in the java.util.concurrent package, but I will leave the concurrency utilities out of this tutorial.', 'Here are a few examples of how to create a Queue instance:\r\n\r\nQueue queueA = new LinkedList();\r\nQueue queueB = new PriorityQueue();', 20, 1),
(349, 100, 'Adding and accessing elements in queue', 'To add elements to a Queue you call its add() method. This method is inherited from the Collection interface. Here are a few examples:\r\n\r\nQueue queueA = new LinkedList();\r\n\r\nqueueA.add("element 1");\r\nqueueA.add("element 2");\r\nqueueA.add("element 3");\r\nThe order in which the elements added to the Queue are stored internally, depends on the implementation. The same is true for the order in which elements are retrieved from the queue. You should consult the JavaDoc''s for more information about the specific Queue implementations.\r\n\r\nYou can peek at the element at the head of the queue without taking the element out of the queue. This is done via the element() method. Here is how that looks:\r\n\r\nObject firstElement = queueA.element();', 'Queue queueA = new LinkedList();\r\n\r\nqueueA.add("element 0");\r\nqueueA.add("element 1");\r\nqueueA.add("element 2");\r\n\r\n//access via Iterator\r\nIterator iterator = queueA.iterator();\r\nwhile(iterator.hasNext(){\r\n  String element = (String) iterator.next();\r\n}\r\n\r\n//access via new for-loop\r\nfor(Object object : queueA) {\r\n    String element = (String) object;\r\n}', 20, 1),
(350, 456, 'Generic queue', 'By default you can put any Object into a Queue, but from Java 5, Java Generics makes it possible to limit the types of object you can insert into a Queue. Here is an example:\r\n\r\nQueue<MyObject> queue = new LinkedList<MyObject>();\r\nThis Queue can now only have MyObject instances inserted into it. You can then access and iterate its elements without casting them. Here is how it looks:\r\n\r\nMyObject myObject = queue.remove();\r\n\r\nfor(MyObject anObject : queue){\r\n   //do someting to anObject...   \r\n}', '', 20, 1),
(351, 456, 'Java dequeue implementation', 'Being a Queue subtype all methods in the Queue and Collection interfaces are also available in the Deque interface.\r\n\r\nSince Deque is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following Deque implementations in the Java Collections API:\r\n\r\njava.util.ArrayDeque\r\njava.util.LinkedList\r\nLinkedList is a pretty standard deque / queue implementation.\r\n\r\nArrayDeque stores its elements internally in an array. If the number of elements exceeds the space in the array, a new array is allocated, and all elements moved over. In other words, the ArrayDeque grows as needed, even if it stores its elements in an array.', 'Here are a few examples of how to create a Deque instance:\r\n\r\nDeque dequeA = new LinkedList();\r\nDeque dequeB = new ArrayDeque();', 20, 1),
(352, 100, 'Method overloading and overriding', 'The difference between overriding and overloading in Java is a common source of confusion – but it is fairly easy to understand with the examples we present below. Let’s start the discussion by talking more about method overloading first. Method overloading in Java occurs when two or more methods in the same class have the exact same name but different parameters (remember that method parameters accept values passed into the method). Now, two or more methods with the same name in the same class sounds simple enough to understand. But, what do we mean exactly by different parameters? Well, let’s consider a very simple example.\r\n\r\nSuppose we have a class called TestClass which has two methods, and both methods have the same name. Let’s say that name is “someMethod”. Those two methods would be considered to be “overloaded” if if one or both of these conditions is true:', '//compiler error - can''t overload based on the   \r\n//type returned -\r\n//(one method returns int, the other returns a float):    \r\n\r\nint changeDate(int Year) ;  \r\nfloat changeDate (int Year);    \r\n\r\n//compiler error - can''t overload by changing just \r\n//the name of the parameter (from Year to Month):    \r\n\r\nint changeDate(int Year);   \r\nint changeDate(int Month) ;  \r\n \r\n//valid case of overloading, since the methods\r\n//have different number of parameters:        \r\n\r\nint changeDate(int Year, int Month) ;  \r\nint changeDate(int Year);    \r\n\r\n//also a valid case of overloading, since the   \r\n//parameters are of different types:    \r\n\r\nint changeDate(float Year) ;  \r\nint changeDate(int Year);  \r\n', 20, 1),
(353, 456, 'stack in java', 'A stack consists of a sequence of items, which should be thought of as piled one on top of the other like a physical stack of boxes or cafeteria trays. Only the top item on the stack is accessible at any given time. It can be removed from the stack with an operation called pop. An item lower down on the stack can only be removed after all the items on top of it have been popped off the stack. A new item can be added to the top of the stack with an operation called push. We can make a stack of any type of items. If, for example, the items are values of type int, then the push and pop operations can be implemented as instance methods\r\n\r\nvoid push (int newItem) -- Add newItem to top of stack.\r\nint pop() -- Remove the top int from the stack and return it.\r\nIt is an error to try to pop an item from an empty stack, so it is important to be able to tell whether a stack is empty. We need another stack operation to do the test, implemented as an instance method\r\n\r\nboolean isEmpty() -- Returns true if the stack is empty.\r\nThis defines a "stack of ints" as an abstract data type. This ADT can be implemented in several ways, but however it is implemented, its behavior must correspond to the abstract mental image of a stack.', 'public class StackOfInts {\r\n\r\n   /**\r\n    * An object of type Node holds one of the items in the linked list \r\n    * that represents the stack.\r\n    */\r\n   private static class Node {\r\n      int item;\r\n      Node next;\r\n   }\r\n   \r\n   private Node top;  // Pointer to the Node that is at the top of\r\n                      //   of the stack.  If top == null, then the\r\n                      //   stack is empty.\r\n   \r\n   /**\r\n    * Add N to the top of the stack.\r\n    */\r\n   public void push( int N ) {\r\n      Node newTop;         // A Node to hold the new item.\r\n      newTop = new Node();\r\n      newTop.item = N;     // Store N in the new Node.\r\n      newTop.next = top;   // The new Node points to the old top.\r\n      top = newTop;        // The new item is now on top.\r\n   }\r\n   \r\n   /**\r\n    * Remove the top item from the stack, and return it.\r\n    * Throws an IllegalStateException if the stack is empty when\r\n    * this method is called.\r\n    */\r\n   public int pop() {\r\n      if ( top == null )\r\n         throw new IllegalStateException("Can''t pop from an empty stack.");\r\n      int topItem = top.item;  // The item that is being popped.\r\n      top = top.next;          // The previous second item is now on top.\r\n      return topItem;\r\n   }\r\n   \r\n   /**\r\n    * Returns true if the stack is empty.  Returns false\r\n    * if there are one or more items on the stack.\r\n    */\r\n   public boolean isEmpty() {\r\n      return (top == null);\r\n   }\r\n\r\n} // end class StackOfInts', 18, 1),
(354, 100, 'postfix expression evaluation using stack in java', 'Algrithm:\r\nStart with an empty stack\r\nfor each item in the expression:\r\n    if the item is a number:\r\n       Push the number onto the stack\r\n    else if the item is an operator:\r\n       Pop the operands from the stack  // Can generate an error\r\n       Apply the operator to the operands\r\n       Push the result onto the stack\r\n    else\r\n       There is an error in the expression\r\nPop a number from the stack  // Can generate an error\r\nif the stack is not empty:\r\n   There is an error in the expression\r\nelse:\r\n   The last number that was popped is the value of the expression', '', 30, 1);

-- --------------------------------------------------------

--
-- Table structure for table `notessal`
--

CREATE TABLE `notessal` (
  `notesid` int(11) NOT NULL,
  `uid` int(11) NOT NULL,
  `topic` varchar(500) NOT NULL,
  `content` text NOT NULL,
  `code` text NOT NULL,
  `likes` int(11) NOT NULL,
  `nlevel` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `notessal`
--

INSERT INTO `notessal` (`notesid`, `uid`, `topic`, `content`, `code`, `likes`, `nlevel`) VALUES
(1, 0, 'Loop', 'To write a while-loop, we think about three parts... test -- a boolean test of what should be true before each iteration. Or put another way, the test is the "green light" condition that says that each iteration can go ahead. (The phrase "green light" is a good mnemonic for what the test does.) Eventually, the test should become false and the loop can exit. Think about the precondition that describes the state before each iteration runs -- how are things arranged, what is true? (Also known as an', 'Here''s a while loop example that uses a loop to see how man times you can divide a number by 2: // Given a num, returns how many times can we divide it by 2 to get down to 1. int count2Div(int num) {   int count = 0;   // count how many divisions we''ve done   while (num >= 1) {     num = num / 2;     count++;   }   return count; }', 10, 0),
(2, 0, 'For loop', 'It executes a block of statements repeatedly until the specified condition returns false. or (initialization; condition; increment/decrement) {     statement(s) //block of statements } Mind the semicolon (;) after initialization and condition in the above syntax.  Initialization expression executes only once during the beginning of loop Condition(Boolean Expression) gets evaluated each time the loop iterates. Loop executes the block of statement repeatedly until this condition returns false. Inc', 'class ForLoopExample {     public static void main(String args[]){          for(int i=10; i>1; i--){               System.out.println("The value of i is: "+i);          }     } }', 10, 0),
(3, 0, 'Do-while loop', 'do-while loop is similar to while loop, however there is a single difference between these two. Unlike while loop, do-while guarantees at-least one execution of block of statements. This happens because the do-while loop evaluates the boolean expression at the end of the loopâ€™s body. Therefore the set of statements gets executed at-least once before the check of boolean expression.  Syntax of while loop:  do{     statement(s) //block of statements }while (Boolean expression);', 'class DoWhileLoopExample {     public static void main(String args[]){          int i=10;          do{               System.out.println(i);               i--;          }while(i>1);     } }', 10, 0),
(4, 0, 'Constructor', 'Constructor is a block of code, which runs when you use new keyword in order to instantiate an object. It looks like a method, however it is not a method. Methods have return type but constructors donâ€™t have any return type.  How to call a constructor? The constructor gets called when we create an object of a class (i.e. new keyword followed by class name). For e.g. Demo obj =  new Demo(); (here Demo() is a default constructor of Demo class).  How does it look?  Default constructor: It is also', 'class Demo {      public Demo()      {          System.out.println("This is a default constructor");      } }', 10, 0),
(5, 0, 'Parameterized Constructor', 'Parameterized constructor: Constructor with argument list is known as parameterized constructor.', 'class Demo {       public Demo(int num, String str)       {            System.out.println("This is a parameterized constructor");       } }', 10, 0),
(6, 0, 'Constructor chaining', 'Constructor chaining is nothing but a scenario where in one constructor calls the constructor of its super class implicitly or explicitly. Suppose there is a class which inherits another class, in this case if you create the object of child class then first super class(or parent class) constructor will be invoked and then child class constructor will be invoked.', 'class Human {         String s1, s2;         public Human()         {               s1 ="Super class";               s2 ="Parent class";         }         public Human(String str)         {                s1= str;                s2= str;         } } class Boy extends Human {         public Boy()         {               s2 ="Child class";         }         public void disp()         {                System.out.println("String 1 is: "+s1);                System.out.println("String 2 is: "+s2);    ', 10, 0),
(7, 1, 'Private Constuctor', 'The use of private constructor is to serve singleton classes. A singleton class is one which limits the number of objects creation to one. Using private constructor we can ensure that no more than one object can be created at a time. We will see in the below example how to use private constructor for limiting the number of objects for a singleton class.', 'package beginnersbook.com; public class SingleTonClass {    //Static Class Reference    private static SingleTonClass obj=null;    private SingleTonClass(){       /*Private Constructor will prevent         * the instantiation of this class directly*/    }    public static SingleTonClass objectCreationMethod(){ 	/*This logic will ensure that no more than 	 * one object can be created at a time */ 	if(obj==null){ 	    obj= new SingleTonClass(); 	}         return obj;    }    public void display(){', 15, 0),
(8, 0, 'Static constructor', 'Have you heard of static constructor in Java? I guess yes but the fact is that they are not allowed in Java. A constructor can not be static in Java.  Before I explain the reason letâ€™s have a look at the below piece of code:', 'public class StaticTest {      /* See below - I have marked the constructor as static */      public static StaticTest()      {          System.out.println("Static Constructor of the class");      }      public static void main(String args[])      {          /*Below: I''m trying to create an object of the class          which would intern call the constructor*/          StaticTest obj = new StaticTest();      } }', 10, 0),
(9, 1, 'Constructors no allowed in interface', 'why constructors are not allowed in interface?  As we know that all the methods in interface are public abstract by default which means the method implementation cannot be provided in the interface itself. It has to be provided by the implementing class. Consider the below piece of code.....All the methods of interface doesnâ€™t have body so there is no need to call the methods in the interface itself. In order to call any method we need an object since there is no need to have object of interfa', 'public interface SumInterface{      public int mymethod(int num1, int num2); } public class SumClass implements SumInterface{      public int mymethod(int num1, int num2){            int op= num1+num2;            return op;     }     public static void main(Sring args[])     {            SumClass obj= new SumClass();            System.out.println(obj.mymethod(2, 3)); }', 15, 0),
(10, 1, 'Constructor overloading', 'Constructor overloading is way of having more than one constructor which does different-2 tasks. For e.g. Vector class has 4 types of constructors. If you do not want to specify the initial capacity and capacity increment then you can simply use default constructor of Vector class like this Vector v = new Vector(); however if you need to specify the capacity and increment then you call the parameterized constructor with two int args like this: Vector v= new Vector(10, 5);', 'package beginnersbook.com; public class StudentData {    private int stuID;    private String stuName;    private int stuAge;    StudentData()    {        //Default constructor        stuID = 100;        stuName = "New Student";        stuAge = 18;    }    StudentData(int num1, String str, int num2)    {        //Parameterized constructor        stuID = num1;        stuName = str;        stuAge = num2;    }    //Getter and setter methods    public int getStuID() {        return stuID;    }    pu', 10, 0),
(11, 1, 'Java features', 'There is given many features of java. They are also known as java buzzwords. The Java Features given below are simple and easy to understand.\r\n\r\nSimple\r\nObject-Oriented\r\nPlatform independent\r\nSecured\r\nRobust\r\nArchitecture neutral\r\nPortable\r\nDynamic\r\nInterpreted\r\nHigh Performance', '', 10, 0),
(12, 1, 'object oriented features of java', 'Basic concepts of OOPs are:\r\nObject\r\nClass\r\nInheritance\r\nPolymorphism\r\nAbstraction\r\nEncapsulation\r\n', '', 10, 0),
(13, 1, 'java world program', 'Let''s see what is the meaning of class, public, static, void, main, String[], System.out.println().\r\n\r\nclass keyword is used to declare a class in java.\r\npublic keyword is an access modifier which represents visibility, it means it is visible to all.\r\nstatic is a keyword, if we declare any method as static, it is known as static method. The core advantage of static method is that there is no need to create object to invoke the static method. The main method is executed by the JVM, so it doesn''t require to create object to invoke the main method. So it saves memory.\r\nvoid is the return type of the method, it means it doesn''t return any value.\r\nmain represents startup of the program.\r\nString[] args is used for command line argument. We will learn it later.\r\nSystem.out.println() is used print statement. We will learn about the internal working of System.out.println statement later.', 'class Simple{  \r\n    public static void main(String args[]){  \r\n     System.out.println("Hello Java");  \r\n    }  \r\n}  ', 10, 0),
(14, 1, 'Valid main methods', '', 'public static void main(String[] args)  \r\npublic static void main(String []args)  \r\npublic static void main(String args[])  \r\npublic static void main(String... args)  \r\nstatic public void main(String[] args)  \r\npublic static final void main(String[] args)  \r\nfinal public static void main(String[] args)  \r\nfinal strictfp public static void main(String[] args) ', 10, 0),
(15, 1, 'Setting path in java', 'To set the temporary path of JDK, you need to follow following steps:\r\n\r\nOpen command prompt\r\ncopy the path of jdk/bin directory\r\nwrite in command prompt: set path=copied_path\r\nFor Example:\r\n\r\nset path=C:\\Program Files\\Java\\jdk1.6.0_23\\bin', '', 10, 0),
(16, 1, 'JVM', 'JVM (Java Virtual Machine) is an abstract machine. It is a specification that provides runtime environment in which java bytecode can be executed.\r\nJVMs are available for many hardware and software platforms. JVM, JRE and JDK are platform dependent because configuration of each OS differs. But, Java is platform independent.\r\nThe JVM performs following main tasks:\r\nLoads code\r\nVerifies code\r\nExecutes code\r\nProvides runtime environment', '', 10, 0),
(17, 0, 'JRE', 'JRE\r\n\r\nJRE is an acronym for Java Runtime Environment.It is used to provide runtime environment.It is the implementation of JVM.It physically exists.It contains set of libraries + other files that JVM uses at runtime.\r\nImplementation of JVMs are also actively released by other companies besides Sun Micro Systems.', '', 12, 0),
(18, 0, 'JDK', 'JDK is an acronym for Java Development Kit.It physically exists.It contains JRE + development tools.\r\n', '', 10, 0),
(19, 0, 'Variables', 'Variable is name of reserved area allocated in memory. There are three types of variables in java\r\nlocal variable\r\ninstance variable\r\nstatic variable\r\n\r\nLocal Variable\r\n\r\nA variable that is declared inside the method is called local variable.\r\nInstance Variable\r\n\r\nA variable that is declared inside the class but outside the method is called instance variable . It is not declared as static.\r\nStatic variable\r\n\r\nA variable that is declared as static is called static variable. It cannot be local.\r\n\r\n\r\n', 'class A{  \r\nint data=50;//instance variable  \r\nstatic int m=100;//static variable  \r\nvoid method(){  \r\nint n=90;//local variable  \r\n}  \r\n}//end of class  ', 15, 0),
(20, 0, 'data types', 'Data Types in Java\r\n\r\nIn java, there are two types of data types\r\n1. primitive data types\r\n2. non-primitive data type', '', 10, 0),
(21, 1, 'java operators', 'Operator in java is a symbol that is used to perform operations. There are many types of operators in java such as unary operator, arithmetic operator, relational operator, shift operator, bitwise operator, ternary operator and assignment operator.\r\n\r\nOperator,Precedence\r\npostfix, expr++ expr--\r\nunary, ++expr --expr +expr -expr ~ !\r\nmultiplicative,	* / %\r\nadditive,	+ -\r\nshift,	<< >> >>>\r\nrelational,	< > <= >= instanceof\r\nequality,	== !=\r\nbitwise AND,	&\r\nbitwise exclusive OR,	^\r\nbitwise inclusive OR,	|\r\nlogical AND,	&&\r\nlogical OR,	||\r\nternary	? :,\r\nassignment,	= += -= *= /= %= &= ^= |= <<= >>= >>>=', '', 10, 0),
(22, 1, 'Fibonacci series', 'Input: 10\r\n\r\nOutput: 0 1 1 2 3 5 8 13 21 34', 'class FibonacciExample1{  \r\npublic static void main(String args[])  \r\n{    \r\n int n1=0,n2=1,n3,i,count=10;    \r\n System.out.print(n1+" "+n2);//printing 0 and 1    \r\n    \r\n for(i=2;i<count;++i)//loop starts from 2 because 0 and 1 are already printed    \r\n {    \r\n  n3=n1+n2;    \r\n  System.out.print(" "+n3);    \r\n  n1=n2;    \r\n  n2=n3;    \r\n }    \r\n  \r\n}}  ', 10, 0),
(23, 1, 'Check whether number is prime or not?\r\n', 'Input: 44\r\n\r\nOutput: not prime number\r\n\r\nInput: 7\r\n\r\nOutput: prime number', 'class PrimeExample{  \r\n public static void main(String args[]){  \r\n  int i,m=0,flag=0;    \r\n  int n=17;//it is the number to be checked  \r\n  m=n/2;    \r\n  for(i=2;i<=m;i++){    \r\n   if(n%i==0){    \r\n   System.out.println("Number is not prime");    \r\n   flag=1;    \r\n   break;    \r\n   }    \r\n  }    \r\n  if(flag==0)    \r\n  System.out.println("Number is prime");    \r\n}  \r\n}  ', 10, 0),
(24, 1, 'Palindrome number program', 'Palindrome number algorithm\r\n\r\nGet the number to check for palindrome\r\nHold the number in temporary variable\r\nReverse the number\r\nCompare the temporary number with reversed number\r\nIf both numbers are same, print "palindrome number"\r\nElse print "not palindrome number"\r\n\r\nInput: 329\r\n\r\nOutput: not palindrome number\r\n\r\nInput: 12321\r\n\r\nOutput: palindrome number', 'class PalindromeExample{  \r\n public static void main(String args[]){  \r\n  int r,sum=0,temp;    \r\n  int n=454;//It is the number variable to be checked for palindrome  \r\n  \r\n  temp=n;    \r\n  while(n>0){    \r\n   r=n%10;  //getting remainder  \r\n   sum=(sum*10)+r;    \r\n   n=n/10;    \r\n  }    \r\n  if(temp==sum)    \r\n   System.out.println("palindrome number ");    \r\n  else    \r\n   System.out.println("not palindrome");    \r\n}  \r\n}  ', 10, 0),
(25, 1, 'print factorial of a number.', 'Input: 5\r\n\r\nOutput: 120\r\n\r\nInput: 6\r\n\r\nOutput: 720', 'class FactorialExample{  \r\n public static void main(String args[]){  \r\n  int i,fact=1;  \r\n  int number=5;//It is the number to calculate factorial    \r\n  for(i=1;i<=number;i++){    \r\n      fact=fact*i;    \r\n  }    \r\n  System.out.println("Factorial of "+number+" is: "+fact);    \r\n }  \r\n}  ', 10, 0),
(26, 0, 'Armstrong Number in Java', '153 = (1*1*1)+(5*5*5)+(3*3*3)  \r\nwhere:  \r\n(1*1*1)=1  \r\n(5*5*5)=125  \r\n(3*3*3)=27  \r\nSo:  \r\n1+125+27=153 ', 'class ArmstrongExample{  \r\n  public static void main(String[] args)  {  \r\n    int c=0,a,temp;  \r\n    int n=153;//It is the number to check armstrong  \r\n    temp=n;  \r\n    while(n>0)  \r\n    {  \r\n    a=n%10;  \r\n    n=n/10;  \r\n    c=c+(a*a*a);  \r\n    }  \r\n    if(temp==c)  \r\n    System.out.println("armstrong number");   \r\n    else  \r\n        System.out.println("Not armstrong number");   \r\n   }  \r\n}  ', 15, 0),
(27, 1, 'Bubble sort', 'In bubble sort algorithm, array is traversed from first element to last element. Here, current element is compared with the next element. If current element is greater than the next element, it is swapped.', 'public class BubbleSortExample {  \r\n    static void bubbleSort(int[] arr) {  \r\n        int n = arr.length;  \r\n        int temp = 0;  \r\n         for(int i=0; i < n; i++){  \r\n                 for(int j=1; j < (n-i); j++){  \r\n                          if(arr[j-1] > arr[j]){  \r\n                                 //swap elements  \r\n                                 temp = arr[j-1];  \r\n                                 arr[j-1] = arr[j];  \r\n                                 arr[j] = temp;  \r\n                         }  \r\n                          \r\n                 }  \r\n         }  \r\n  \r\n    }  \r\n    public static void main(String[] args) {  \r\n                int arr[] ={3,60,35,2,45,320,5};  \r\n                 \r\n                System.out.println("Array Before Bubble Sort");  \r\n                for(int i=0; i < arr.length; i++){  \r\n                        System.out.print(arr[i] + " ");  \r\n                }  \r\n                System.out.println();  \r\n                  \r\n                bubbleSort(arr);//sorting array elements using bubble sort  \r\n                 \r\n                System.out.println("Array After Bubble Sort");  \r\n                for(int i=0; i < arr.length; i++){  \r\n                        System.out.print(arr[i] + " ");  \r\n                }  \r\n   \r\n        }  \r\n}  ', 10, 0),
(29, 1, 'objects in java', 'An entity that has state and behavior is known as an object e.g. chair, bike, marker, pen, table, car etc. It can be physical or logical (tengible and intengible). The example of integible object is banking system.\r\n\r\nAn object has three characteristics:\r\n\r\nstate: represents data (value) of an object.\r\nbehavior: represents the behavior (functionality) of an object such as deposit, withdraw etc.\r\nidentity: Object identity is typically implemented via a unique ID. The value of the ID is not visible to the external user. But,it is used internally by the JVM to identify each object uniquely.\r\nFor Example: Pen is an object. Its name is Reynolds, color is white etc. known as its state. It is used to write, so writing is its behavior.\r\nObject is an instance of a class. Class is a template or blueprint from which objects are created. So object is the instance(result) of a class.', 'class Student1{  \r\n int id;//data member (also instance variable)  \r\n String name;//data member(also instance variable)  \r\n  \r\n public static void main(String args[]){  \r\n  Student1 s1=new Student1();//creating an object of Student  \r\n  System.out.println(s1.id);  \r\n  System.out.println(s1.name);  \r\n }  \r\n}  ', 10, 0),
(30, 1, 'Class in java', 'A class is a group of objects that has common properties. It is a template or blueprint from which objects are created.\r\nA class in java can contain:\r\n\r\ndata member\r\nmethod\r\nconstructor\r\nblock\r\nclass and interface\r\n\r\nSyntax to declare a class:\r\n\r\nclass <class_name>{  \r\n    data member;  \r\n    method;  \r\n}  ', 'class Student1{  \r\n int id;//data member (also instance variable)  \r\n String name;//data member(also instance variable)  \r\n  \r\n public static void main(String args[]){  \r\n  Student1 s1=new Student1();//creating an object of Student  \r\n  System.out.println(s1.id);  \r\n  System.out.println(s1.name);  \r\n }  \r\n} ', 10, 0),
(31, 0, 'method overloading (By changing number of arguments)', 'If a class have multiple methods by same name but different parameters, it is known as Method Overloading.\r\n\r\nIf we have to perform only one operation, having same name of the methods increases the readability of the program.\r\n\r\nSuppose you have to perform addition of the given numbers but there can be any number of arguments, if you write the method such as a(int,int) for two parameters, and b(int,int,int) for three parameters then it may be difficult for you as well as other programmers to understand the behaviour of the method because its name differs. So, we perform method overloading to figure out the program quickly.\r\n\r\n', 'class Calculation{  \r\n  void sum(int a,int b){System.out.println(a+b);}  \r\n  void sum(int a,int b,int c){System.out.println(a+b+c);}  \r\n  \r\n  public static void main(String args[]){  \r\n  Calculation obj=new Calculation();  \r\n  obj.sum(10,10,10);  \r\n  obj.sum(20,20);  \r\n  \r\n  }  \r\n}  ', 20, 0),
(32, 1, 'Method Overloading by changing data type of argument', 'In this example, we have created two overloaded methods that differs in data type. The first sum method receives two integer arguments and second sum method receives two double arguments.', 'class Calculation2{  \r\n  void sum(int a,int b){System.out.println(a+b);}  \r\n  void sum(double a,double b){System.out.println(a+b);}  \r\n  \r\n  public static void main(String args[]){  \r\n  Calculation2 obj=new Calculation2();  \r\n  obj.sum(10.5,10.5);  \r\n  obj.sum(20,20);  \r\n  \r\n  }  \r\n}  ', 10, 0),
(34, 1, 'Can we overload main() method?', 'Yes, by method overloading. You can have any number of main methods in a class by method overloading. Let''s see the simple example:', 'class Overloading1{  \r\n  public static void main(int a){  \r\n  System.out.println(a);  \r\n  }  \r\n    \r\n  public static void main(String args[]){  \r\n  System.out.println("main() method invoked");  \r\n  main(10);  \r\n  }  \r\n} ', 10, 0),
(35, 101, 'constructors in java', 'Constructor in java is a special type of method that is used to initialize the object.\r\n\r\nJava constructor is invoked at the time of object creation. It constructs the values i.e. provides data for the object that is why it is known as constructor.\r\n\r\nRules for creating java constructor\r\n\r\nThere are basically two rules defined for the constructor.\r\n\r\nConstructor name must be same as its class name\r\nConstructor must have no explicit return type\r\n\r\nTypes of java constructors\r\n\r\nThere are two types of constructors:\r\n\r\n1. Default constructor (no-arg constructor)\r\n2. Parameterized constructor\r\n\r\nJava Default Constructor\r\n\r\nA constructor that have no parameter is known as default constructor.\r\nSyntax of default constructor:\r\n\r\n<class_name>(){} \r\n\r\n \r\n\r\n', 'Example of default constructor\r\n\r\nIn this example, we are creating the no-arg constructor in the Bike class. It will be invoked at the time of object creation.\r\nclass Bike1{  \r\nBike1(){System.out.println("Bike is created");}  \r\npublic static void main(String args[]){  \r\nBike1 b=new Bike1();  \r\n}  \r\n}  ', 10, 0),
(36, 101, 'parameterized constructor', 'Java parameterized constructor\r\n\r\nA constructor that have parameters is known as parameterized constructor.\r\nWhy use parameterized constructor?\r\n\r\nParameterized constructor is used to provide different values to the distinct objects.', 'Example of parameterized constructor\r\n\r\nIn this example, we have created the constructor of Student class that have two parameters. We can have any number of parameters in the constructor.\r\nclass Student4{  \r\n    int id;  \r\n    String name;  \r\n      \r\n    Student4(int i,String n){  \r\n    id = i;  \r\n    name = n;  \r\n    }  \r\n    void display(){System.out.println(id+" "+name);}  \r\n   \r\n    public static void main(String args[]){  \r\n    Student4 s1 = new Student4(111,"Karan");  \r\n    Student4 s2 = new Student4(222,"Aryan");  \r\n    s1.display();  \r\n    s2.display();  \r\n   }  \r\n}  ', 20, 0),
(37, 101, 'constructor overloading', 'Constructor overloading is a technique in Java in which a class can have any number of constructors that differ in parameter lists.The compiler differentiates these constructors by taking into account the number of parameters in the list and their type.', 'class Student5{  \r\n    int id;  \r\n    String name;  \r\n    int age;  \r\n    Student5(int i,String n){  \r\n    id = i;  \r\n    name = n;  \r\n    }  \r\n    Student5(int i,String n,int a){  \r\n    id = i;  \r\n    name = n;  \r\n    age=a;  \r\n    }  \r\n    void display(){System.out.println(id+" "+name+" "+age);}  \r\n   \r\n    public static void main(String args[]){  \r\n    Student5 s1 = new Student5(111,"Karan");  \r\n    Student5 s2 = new Student5(222,"Aryan",25);  \r\n    s1.display();  \r\n    s2.display();  \r\n   }  \r\n} ', 20, 0),
(38, 1, 'copy constructor', 'There is no copy constructor in java. But, we can copy the values of one object to another like copy constructor in C++.\r\n\r\nThere are many ways to copy the values of one object into another in java. They are:\r\n\r\nBy constructor\r\nBy assigning the values of one object into another\r\nBy clone() method of Object class\r\nIn this example, we are going to copy the values of one object into another using java constructor.', 'class Student6{  \r\n    int id;  \r\n    String name;  \r\n    Student6(int i,String n){  \r\n    id = i;  \r\n    name = n;  \r\n    }  \r\n      \r\n    Student6(Student6 s){  \r\n    id = s.id;  \r\n    name =s.name;  \r\n    }  \r\n    void display(){System.out.println(id+" "+name);}  \r\n   \r\n    public static void main(String args[]){  \r\n    Student6 s1 = new Student6(111,"Karan");  \r\n    Student6 s2 = new Student6(s1);  \r\n    s1.display();  \r\n    s2.display();  \r\n   }  \r\n}  ', 10, 0),
(39, 101, 'static variable', 'If you declare any variable as static, it is known static variable.\r\n\r\nThe static variable can be used to refer the common property of all objects (that is not unique for each object) e.g. company name of employees,college name of students etc.\r\nThe static variable gets memory only once in class area at the time of class loading.\r\nAdvantage of static variable\r\n\r\nIt makes your program memory efficient (i.e it saves memory).', '/Program of static variable  \r\n  \r\nclass Student8{  \r\n   int rollno;  \r\n   String name;  \r\n   static String college ="ITS";  \r\n     \r\n   Student8(int r,String n){  \r\n   rollno = r;  \r\n   name = n;  \r\n   }  \r\n void display (){System.out.println(rollno+" "+name+" "+college);}  \r\n  \r\n public static void main(String args[]){  \r\n Student8 s1 = new Student8(111,"Karan");  \r\n Student8 s2 = new Student8(222,"Aryan");  \r\n   \r\n s1.display();  \r\n s2.display();  \r\n }  \r\n} ', 10, 0),
(40, 101, 'static method', 'If you apply static keyword with any method, it is known as static method.\r\n\r\nA static method belongs to the class rather than object of a class.\r\nA static method can be invoked without the need for creating an instance of a class.\r\nstatic method can access static data member and can change the value of it.', '//Program of changing the common property of all objects(static field).  \r\n  \r\nclass Student9{  \r\n     int rollno;  \r\n     String name;  \r\n     static String college = "ITS";  \r\n       \r\n     static void change(){  \r\n     college = "BBDIT";  \r\n     }  \r\n  \r\n     Student9(int r, String n){  \r\n     rollno = r;  \r\n     name = n;  \r\n     }  \r\n  \r\n     void display (){System.out.println(rollno+" "+name+" "+college);}  \r\n  \r\n    public static void main(String args[]){  \r\n    Student9.change();  \r\n  \r\n    Student9 s1 = new Student9 (111,"Karan");  \r\n    Student9 s2 = new Student9 (222,"Aryan");  \r\n    Student9 s3 = new Student9 (333,"Sonoo");  \r\n  \r\n    s1.display();  \r\n    s2.display();  \r\n    s3.display();  \r\n    }  \r\n}  ', 20, 0),
(41, 1, 'static block', 'Is used to initialize the static data member.\r\nIt is executed before main method at the time of classloading.', 'class A2{  \r\n  static{System.out.println("static block is invoked");}  \r\n  public static void main(String args[]){  \r\n   System.out.println("Hello main");  \r\n  }  \r\n}', 10, 0),
(42, 1, 'this keyword', 'this keyword can be used to refer current class instance variable.\r\nthis() can be used to invoke current class constructor.\r\nthis keyword can be used to invoke current class method (implicitly)\r\nthis can be passed as an argument in the method call.\r\nthis can be passed as argument in the constructor call.\r\nthis keyword can also be used to return the current class instance.', '//example of this keyword  \r\nclass Student11{  \r\n    int id;  \r\n    String name;  \r\n      \r\n    Student11(int id,String name){  \r\n    this.id = id;  \r\n    this.name = name;  \r\n    }  \r\n    void display(){System.out.println(id+" "+name);}  \r\n    public static void main(String args[]){  \r\n    Student11 s1 = new Student11(111,"Karan");  \r\n    Student11 s2 = new Student11(222,"Aryan");  \r\n    s1.display();  \r\n    s2.display();  \r\n}  \r\n}  ', 10, 0),
(43, 101, 'inheritance', 'Inheritance in java is a mechanism in which one object acquires all the properties and behaviors of parent object.\r\n\r\nThe idea behind inheritance in java is that you can create new classes that are built upon existing classes. When you inherit from an existing class, you can reuse methods and fields of parent class, and you can add new methods and fields also.\r\n\r\nInheritance represents the IS-A relationship, also known as parent-child relationship.\r\n\r\nSyntax of Java Inheritance\r\n\r\nclass Subclass-name extends Superclass-name  \r\n{  \r\n   //methods and fields  \r\n}  \r\nThe extends keyword indicates that you are making a new class that derives from an existing class.\r\n\r\nIn the terminology of Java, a class that is inherited is called a super class. The new class is called a subclass.', 'class Employee{  \r\n float salary=40000;  \r\n}  \r\nclass Programmer extends Employee{  \r\n int bonus=10000;  \r\n public static void main(String args[]){  \r\n   Programmer p=new Programmer();  \r\n   System.out.println("Programmer salary is:"+p.salary);  \r\n   System.out.println("Bonus of Programmer is:"+p.bonus);  \r\n}  \r\n}  \r\n\r\nProgrammer is the subclass and Employee is the superclass. Relationship between two classes is Programmer IS-A Employee.It means that Programmer is a type of Employee.', 20, 0),
(44, 1, 'types of inheritance', 'On the basis of class, there can be three types of inheritance in java: single, multilevel and hierarchical.\r\n\r\nIn java programming, multiple and hybrid inheritance is supported through interface only. We will learn about interfaces later.\r\n\r\nNote: Multiple inheritance is not supported in java through class.\r\n\r\nWhen a class extends multiple classes i.e. known as multiple inheritance.', '', 10, 0),
(45, 1, 'Why multiple inheritance not supported in java?', 'To reduce the complexity and simplify the language, multiple inheritance is not supported in java.\r\n\r\nConsider a scenario where A, B and C are three classes. The C class inherits A and B classes. If A and B classes have same method and you call it from child class object, there will be ambiguity to call method of A or B class.\r\n\r\nSince compile time errors are better than runtime errors, java renders compile time error if you inherit 2 classes. So whether you have same method or different, there will be compile time error now.', 'class A{  \r\nvoid msg(){System.out.println("Hello");}  \r\n}  \r\nclass B{  \r\nvoid msg(){System.out.println("Welcome");}  \r\n}  \r\nclass C extends A,B{//suppose if it were  \r\n   \r\n Public Static void main(String args[]){  \r\n   C obj=new C();  \r\n   obj.msg();//Now which msg() method would be invoked?  \r\n}  \r\n} ', 10, 0),
(46, 1, 'Aggregation in java', 'If a class have an entity reference, it is known as Aggregation. Aggregation represents HAS-A relationship.\r\n\r\nConsider a situation, Employee object contains many informations such as id, name, emailId etc. It contains one more object named address, which contains its own informations such as city, state, country, zipcode etc. as given below.\r\n\r\nclass Employee{  \r\nint id;  \r\nString name;  \r\nAddress address;//Address is a class  \r\n...  \r\n} ', 'class Operation{  \r\n int square(int n){  \r\n  return n*n;  \r\n }  \r\n}  \r\n  \r\nclass Circle{  \r\n Operation op;//aggregation  \r\n double pi=3.14;  \r\n    \r\n double area(int radius){  \r\n   op=new Operation();  \r\n   int rsquare=op.square(radius);//code reusability (i.e. delegates the method call).  \r\n   return pi*rsquare;  \r\n }  \r\n  \r\n     \r\n    \r\n public static void main(String args[]){  \r\n   Circle c=new Circle();  \r\n   double result=c.area(5);  \r\n   System.out.println(result);  \r\n }  \r\n} ', 10, 0),
(47, 101, 'Method overriding', 'f subclass (child class) has the same method as declared in the parent class, it is known as method overriding in java.\r\n\r\nIn other words, If subclass provides the specific implementation of the method that has been provided by one of its parent class, it is known as method overriding.\r\n\r\nUsage of Java Method Overriding\r\n\r\nMethod overriding is used to provide specific implementation of a method that is already provided by its super class.\r\nMethod overriding is used for runtime polymorphism\r\nRules for Java Method Overriding\r\n\r\nmethod must have same name as in the parent class\r\nmethod must have same parameter as in the parent class.\r\nmust be IS-A relationship (inheritance).', 'In this example, we have defined the run method in the subclass as defined in the parent class but it has some specific implementation. The name and parameter of the method is same and there is IS-A relationship between the classes, so there is method overriding.\r\n\r\nclass Vehicle{  \r\nvoid run(){System.out.println("Vehicle is running");}  \r\n}  \r\nclass Bike2 extends Vehicle{  \r\nvoid run(){System.out.println("Bike is running safely");}  \r\n  \r\npublic static void main(String args[]){  \r\nBike2 obj = new Bike2();  \r\nobj.run();  \r\n}', 10, 0),
(48, 1, 'covariant return type', 'The covariant return type specifies that the return type may vary in the same direction as the subclass.\r\n\r\nBefore Java5, it was not possible to override any method by changing the return type. But now, since Java5, it is possible to override method by changing the return type if subclass overrides any method whose return type is Non-Primitive but it changes its return type to subclass type. Let''s take a simple example', 'class A{  \r\nA get(){return this;}  \r\n}  \r\n  \r\nclass B1 extends A{  \r\nB1 get(){return this;}  \r\nvoid message(){System.out.println("welcome to covariant return type");}  \r\n  \r\npublic static void main(String args[]){  \r\nnew B1().get().message();  \r\n}  \r\n}  ', 10, 0),
(49, 1, 'super keyword', 'The super keyword in java is a reference variable that is used to refer immediate parent class object.\r\n\r\nWhenever you create the instance of subclass, an instance of parent class is created implicitly i.e. referred by super reference variable.\r\n\r\nUsage of java super Keyword\r\n\r\nsuper is used to refer immediate parent class instance variable.\r\nsuper() is used to invoke immediate parent class constructor.\r\nsuper is used to invoke immediate parent class method.', '/example of super keyword  \r\n  \r\nclass Vehicle{  \r\n  int speed=50;  \r\n}  \r\n  \r\nclass Bike4 extends Vehicle{  \r\n  int speed=100;  \r\n      \r\n  void display(){  \r\n   System.out.println(super.speed);//will print speed of Vehicle now  \r\n  }  \r\n  public static void main(String args[]){  \r\n   Bike4 b=new Bike4();  \r\n   b.display();  \r\n     \r\n}  \r\n}  ', 10, 0),
(50, 101, 'Final variable', 'If you make any variable as final, you cannot change the value of final variable(It will be constant).', 'There is a final variable speedlimit, we are going to change the value of this variable, but It can''t be changed because final variable once assigned a value can never be changed.\r\n\r\nclass Bike9{  \r\n final int speedlimit=90;//final variable  \r\n void run(){  \r\n  speedlimit=400;  \r\n }  \r\n public static void main(String args[]){  \r\n Bike9 obj=new  Bike9();  \r\n obj.run();  \r\n }  \r\n}//end of class  ', 15, 0),
(51, 1, 'Final Method', 'If you make any method as final, you cannot override it.', 'class Bike{  \r\n  final void run(){System.out.println("running");}  \r\n}  \r\n     \r\nclass Honda extends Bike{  \r\n   void run(){System.out.println("running safely with 100kmph");}  \r\n     \r\n   public static void main(String args[]){  \r\n   Honda honda= new Honda();  \r\n   honda.run();  \r\n   }  \r\n} ', 10, 0),
(52, 1, 'Final class', 'If you make any class as final, you cannot extend it.', 'final class Bike{}  \r\n  \r\nclass Honda1 extends Bike{  \r\n  void run(){System.out.println("running safely with 100kmph");}  \r\n    \r\n  public static void main(String args[]){  \r\n  Honda1 honda= new Honda();  \r\n  honda.run();  \r\n  }  \r\n}  ', 10, 0),
(53, 1, 'What is blank or uninitialized final variable?', 'A final variable that is not initialized at the time of declaration is known as blank final variable.\r\n\r\nIf you want to create a variable that is initialized at the time of creating object and once initialized may not be changed, it is useful. For example PAN CARD number of an employee.\r\n\r\nIt can be initialized only in constructor.', 'class Student{  \r\nint id;  \r\nString name;  \r\nfinal String PAN_CARD_NUMBER;  \r\n...  \r\n}', 10, 0),
(54, 1, 'Polymorphism in Java', 'Polymorphism in java is a concept by which we can perform a single action by different ways. Polymorphism is derived from 2 greek words: poly and morphs. The word "poly" means many and "morphs" means forms. So polymorphism means many forms.\r\n\r\nThere are two types of polymorphism in java: compile time polymorphism and runtime polymorphism. We can perform polymorphism in java by method overloading and method overriding.\r\n\r\nIf you overload static method in java, it is the example of compile time polymorphism\r\n\r\nRuntime Polymorphism in Java\r\n\r\nRuntime polymorphism or Dynamic Method Dispatch is a process in which a call to an overridden method is resolved at runtime rather than compile-time.\r\n\r\nIn this process, an overridden method is called through the reference variable of a superclass. The determination of the method to be called is based on the object being referred to by the reference variable.\r\n\r\nLet''s first understand the upcasting before Runtime Polymorphism.\r\n\r\nUpcasting\r\n\r\nWhen reference variable of Parent class refers to the object of Child class, it is known as upcasting. \r\n\r\nclass A{}  \r\nclass B extends A{}  \r\nA a=new B();//upcasting  \r\n\r\n\r\n', 'class Bike{  \r\n  void run(){System.out.println("running");}  \r\n}  \r\nclass Splender extends Bike{  \r\n  void run(){System.out.println("running safely with 60km");}  \r\n  \r\n  public static void main(String args[]){  \r\n    Bike b = new Splender();//upcasting  \r\n    b.run();  \r\n  }  \r\n} ', 10, 0),
(55, 1, 'Static Binding and Dynamic Binding', 'Connecting a method call to the method body is known as binding.\r\n\r\nThere are two types of binding\r\n\r\nstatic binding (also known as early binding).\r\ndynamic binding (also known as late binding).\r\n\r\nstatic binding\r\n\r\nWhen type of the object is determined at compiled time(by the compiler), it is known as static binding.\r\n\r\nIf there is any private, final or static method in a class, there is static binding.\r\n\r\nDynamic binding\r\n\r\nWhen type of the object is determined at run-time, it is known as dynamic binding.\r\n', 'Example of static binding\r\n\r\nclass Dog{  \r\n private void eat(){System.out.println("dog is eating...");}  \r\n  \r\n public static void main(String args[]){  \r\n  Dog d1=new Dog();  \r\n  d1.eat();  \r\n }  \r\n} \r\n\r\nExample of dynamic binding\r\n\r\nclass Animal{  \r\n void eat(){System.out.println("animal is eating...");}  \r\n}  \r\n  \r\nclass Dog extends Animal{  \r\n void eat(){System.out.println("dog is eating...");}  \r\n  \r\n public static void main(String args[]){  \r\n  Animal a=new Dog();  \r\n  a.eat();  \r\n }  \r\n}  \r\n\r\n', 10, 0),
(56, 1, 'Java instanceof', 'The java instanceof operator is used to test whether the object is an instance of the specified type (class or subclass or interface).\r\n\r\nThe instanceof in java is also known as type comparison operator because it compares the instance with type. It returns either true or false. If we apply the instanceof operator with any variable that has null value, it returns false.', 'class Simple1{  \r\n public static void main(String args[]){  \r\n Simple1 s=new Simple1();  \r\n System.out.println(s instanceof Simple1);//true  \r\n }  \r\n}', 10, 0),
(57, 1, 'Abstract class in Java', 'A class that is declared as abstract is known as abstract class. It needs to be extended and its method implemented. It cannot be instantiated.\r\n\r\nExample abstract class\r\n\r\nabstract class A{}  ', 'abstract class Bike{  \r\n  abstract void run();  \r\n}  \r\n  \r\nclass Honda4 extends Bike{  \r\nvoid run(){System.out.println("running safely..");}  \r\n  \r\npublic static void main(String args[]){  \r\n Bike obj = new Honda4();  \r\n obj.run();  \r\n}  \r\n} ', 10, 0),
(58, 1, 'Interface in Java', 'An interface in java is a blueprint of a class. It has static constants and abstract methods only.\r\n\r\nThe interface in java is a mechanism to achieve fully abstraction. There can be only abstract methods in the java interface not method body. It is used to achieve fully abstraction and multiple inheritance in Java.\r\n\r\nJava Interface also represents IS-A relationship.\r\n\r\nIt cannot be instantiated just like abstract class.\r\n', 'interface printable{  \r\nvoid print();  \r\n}  \r\n  \r\nclass A6 implements printable{  \r\npublic void print(){System.out.println("Hello");}  \r\n  \r\npublic static void main(String args[]){  \r\nA6 obj = new A6();  \r\nobj.print();  \r\n }  \r\n} ', 10, 0),
(59, 0, 'Difference between abstract class and interface', 'Abstract class\r\n\r\n1) Abstract class can have abstract and non-abstract methods.\r\n2) Abstract class doesn''t support multiple inheritance.\r\n3) Abstract class can have final, non-final, static and non-static variables.\r\n4) Abstract class can have static methods, main method and constructor.\r\n5) Abstract class can provide the implementation of interface.\r\n6) The abstract keyword is used to declare abstract class.\r\n\r\nInterface in java:\r\n1. Interface can have only abstract methods.\r\n2. Interface supports multiple inheritance.\r\n3. Interface supports multiple inheritance.\r\n4. Interface can''t have static methods, main method or constructor.\r\n5. Interface can''t provide the implementation of abstract class.\r\n6. The interface keyword is used to declare interface.\r\n\r\n\r\n\r\n\r\n', 'Abstract class example:\r\n\r\npublic abstract class Shape{\r\npublic abstract void draw();\r\n}\r\n\r\nInterface example\r\npublic interface Drawable{\r\nvoid draw();\r\n}', 10, 0),
(60, 2, 'Java Package', 'A java package is a group of similar types of classes, interfaces and sub-packages.\r\n\r\nPackage in java can be categorized in two form, built-in package and user-defined package.\r\n\r\nThere are many built-in packages such as java, lang, awt, javax, swing, net, io, util, sql etc.\r\n\r\nHere, we will have the detailed learning of creating and using user-defined packages.\r\n\r\nAdvantage of Java Package\r\n\r\n1) Java package is used to categorize the classes and interfaces so that they can be easily maintained.\r\n\r\n2) Java package provides access protection.\r\n\r\n3) Java package removes naming collision.', '//save as Simple.java  \r\npackage mypack;  \r\npublic class Simple{  \r\n public static void main(String args[]){  \r\n    System.out.println("Welcome to package");  \r\n   }  \r\n}  ', 10, 1),
(61, 2, 'Using packagename.*', 'If you use package.* then all the classes and interfaces of this package will be accessible but not subpackages.\r\n\r\nThe import keyword is used to make the classes and interface of another package accessible to the current package.', '//save by A.java  \r\npackage pack;  \r\npublic class A{  \r\n  public void msg(){System.out.println("Hello");}  \r\n}  \r\n//save by B.java  \r\npackage mypack;  \r\nimport pack.*;  \r\n  \r\nclass B{  \r\n  public static void main(String args[]){  \r\n   A obj = new A();  \r\n   obj.msg();  \r\n  }  \r\n}  ', 10, 1),
(62, 202, 'Access Modifiers in java\r\n', 'There are two types of modifiers in java: access modifiers and non-access modifiers.\r\n\r\nThe access modifiers in java specifies accessibility (scope) of a data member, method, constructor or class.\r\n\r\nThere are 4 types of java access modifiers:\r\n\r\nprivate\r\ndefault\r\nprotected\r\npublic\r\n\r\n1) private access modifier\r\n\r\nThe private access modifier is accessible only within class.\r\n\r\n\r\n\r\n\r\n', 'Example of private access modifier:\r\nclass A{  \r\nprivate int data=40;  \r\nprivate void msg(){System.out.println("Hello java");}  \r\n}  \r\n  \r\npublic class Simple{  \r\n public static void main(String args[]){  \r\n   A obj=new A();  \r\n   System.out.println(obj.data);//Compile Time Error  \r\n   obj.msg();//Compile Time Error  \r\n   }  \r\n}  ', 20, 1),
(63, 2, 'Default access modifier', '\r\nIf you don''t use any modifier, it is treated as default bydefault. The default modifier is accessible only within package.', '//save by A.java  \r\npackage pack;  \r\nclass A{  \r\n  void msg(){System.out.println("Hello");}  \r\n}  \r\n//save by B.java  \r\npackage mypack;  \r\nimport pack.*;  \r\nclass B{  \r\n  public static void main(String args[]){  \r\n   A obj = new A();//Compile Time Error  \r\n   obj.msg();//Compile Time Error  \r\n  }  \r\n} ', 10, 0),
(64, 2, 'Protected access modifier', 'The protected access modifier is accessible within package and outside the package but through inheritance only.\r\n\r\nThe protected access modifier can be applied on the data member, method and constructor. It can''t be applied on the class.', '//save by A.java  \r\npackage pack;  \r\npublic class A{  \r\nprotected void msg(){System.out.println("Hello");}  \r\n}  \r\n//save by B.java  \r\npackage mypack;  \r\nimport pack.*;  \r\n  \r\nclass B extends A{  \r\n  public static void main(String args[]){  \r\n   B obj = new B();  \r\n   obj.msg();  \r\n  }  \r\n}  ', 10, 0),
(65, 202, 'public access modifier', 'The public access modifier is accessible everywhere. It has the widest scope among all other modifiers.', '//save by A.java  \r\n  \r\npackage pack;  \r\npublic class A{  \r\npublic void msg(){System.out.println("Hello");}  \r\n}  \r\n//save by B.java  \r\n  \r\npackage mypack;  \r\nimport pack.*;  \r\n  \r\nclass B{  \r\n  public static void main(String args[]){  \r\n   A obj = new A();  \r\n   obj.msg();  \r\n  }  ', 20, 1),
(66, 1, 'Encapsulation in Java', 'Encapsulation in java is a process of wrapping code and data together into a single unit, for example capsule i.e. mixed of several medicines.', '//save as Student.java  \r\npackage com.javatpoint;  \r\npublic class Student{  \r\nprivate String name;  \r\n   \r\npublic String getName(){  \r\nreturn name;  \r\n}  \r\npublic void setName(String name){  \r\nthis.name=name  \r\n}  \r\n}  \r\n//save as Test.java  \r\npackage com.javatpoint;  \r\nclass Test{  \r\npublic static void main(String[] args){  \r\nStudent s=new Student();  \r\ns.setname("vijay");  \r\nSystem.out.println(s.getName());  \r\n}  \r\n}  ', 10, 0),
(67, 2, 'Object class in Java', 'The Object class is the parent class of all the classes in java bydefault. In other words, it is the topmost class of java.\r\n\r\nThe Object class is beneficial if you want to refer any object whose type you don''t know. Notice that parent class reference variable can refer the child class object, know as upcasting.\r\n\r\nLet''s take an example, there is getObject() method that returns an object but it can be of any type like Employee,Student etc, we can use Object class reference to refer that object. For example:\r\n\r\nObject obj=getObject();//we don''t what object would be returned from this method  \r\nThe Object class provides some common behaviours to all the objects such as object can be compared, object can be cloned, object can be notified etc.', '1. public final ClassgetClass()	\r\n\r\nreturns the Class class object of this object. The Class class can further be used to get the metadata of this class.\r\n\r\n2. public int hashCode()	\r\nreturns the hashcode number for this object.\r\n\r\n3. public boolean equals(Object obj)	compares the given object to this object.\r\n\r\n4. protected Object clone() throws CloneNotSupportedException	\r\ncreates and returns the exact copy (clone) of this object.\r\n\r\n5. public String toString()	\r\nreturns the string representation of this object.\r\n\r\n6. public final void notify()	\r\nwakes up single thread, waiting on this object''s monitor.\r\n\r\n7. public final void notifyAll()	wakes up all the threads, waiting on this object''s monitor.\r\n\r\n8. public final void wait(long timeout)throws InterruptedException	causes the current thread to wait for the specified milliseconds, until another thread notifies (invokes notify() or notifyAll() method).', 10, 0);
INSERT INTO `notessal` (`notesid`, `uid`, `topic`, `content`, `code`, `likes`, `nlevel`) VALUES
(68, 2, 'Object cloning in java', 'The object cloning is a way to create exact copy of an object. For this purpose, clone() method of Object class is used to clone an object.\r\n\r\nThe java.lang.Cloneable interface must be implemented by the class whose object clone we want to create. If we don''t implement Cloneable interface, clone() method generates CloneNotSupportedException.\r\n\r\nThe clone() method is defined in the Object class. Syntax of the clone() method is as follows:\r\n\r\nprotected Object clone() throws CloneNotSupportedException ', 'class Student18 implements Cloneable{  \r\nint rollno;  \r\nString name;  \r\n  \r\nStudent18(int rollno,String name){  \r\nthis.rollno=rollno;  \r\nthis.name=name;  \r\n}  \r\n  \r\npublic Object clone()throws CloneNotSupportedException{  \r\nreturn super.clone();  \r\n}  \r\n  \r\npublic static void main(String args[]){  \r\ntry{  \r\nStudent18 s1=new Student18(101,"amit");  \r\n  \r\nStudent18 s2=(Student18)s1.clone();  \r\n  \r\nSystem.out.println(s1.rollno+" "+s1.name);  \r\nSystem.out.println(s2.rollno+" "+s2.name);  \r\n  \r\n}catch(CloneNotSupportedException c){}  \r\n  \r\n}  \r\n} ', 10, 0),
(69, 2, 'Java Array', 'class Student18 implements Cloneable{  \r\nint rollno;  \r\nString name;  \r\n  \r\nStudent18(int rollno,String name){  \r\nthis.rollno=rollno;  \r\nthis.name=name;  \r\n}  \r\n  \r\npublic Object clone()throws CloneNotSupportedException{  \r\nreturn super.clone();  \r\n}  \r\n  \r\npublic static void main(String args[]){  \r\ntry{  \r\nStudent18 s1=new Student18(101,"amit");  \r\n  \r\nStudent18 s2=(Student18)s1.clone();  \r\n  \r\nSystem.out.println(s1.rollno+" "+s1.name);  \r\nSystem.out.println(s2.rollno+" "+s2.name);  \r\n  \r\n}catch(CloneNotSupportedException c){}  \r\n  \r\n}  \r\n} \r\n\r\nSyntax to Declare an Array in java\r\n\r\ndataType[] arr; (or)  \r\ndataType []arr; (or)  \r\ndataType arr[];  \r\nInstantiation of an Array in java\r\n\r\narrayRefVar=new datatype[size];  ', 'class Testarray{  \r\npublic static void main(String args[]){  \r\n  \r\nint a[]=new int[5];//declaration and instantiation  \r\na[0]=10;//initialization  \r\na[1]=20;  \r\na[2]=70;  \r\na[3]=40;  \r\na[4]=50;  \r\n  \r\n//printing array  \r\nfor(int i=0;i<a.length;i++)//length is the property of array  \r\nSystem.out.println(a[i]);  \r\n  \r\n}} ', 10, 0),
(70, 202, 'Passing array to method in java', 'We can pass the java array to method so that we can reuse the same logic on any array.\r\n\r\nLet''s see the simple example to get minimum number of an array using method.', 'class Testarray2{  \r\nstatic void min(int arr[]){  \r\nint min=arr[0];  \r\nfor(int i=1;i<arr.length;i++)  \r\n if(min>arr[i])  \r\n  min=arr[i];  \r\n  \r\nSystem.out.println(min);  \r\n}  \r\n  \r\npublic static void main(String args[]){  \r\n  \r\nint a[]={33,3,4,5};  \r\nmin(a);//passing array to method  \r\n  \r\n}} ', 15, 1),
(71, 23, 'Multidimensional array in java\r\n', 'In such case, data is stored in row and column based index (also known as matrix form).\r\n\r\nSyntax to Declare Multidimensional Array in java\r\n\r\ndataType[][] arrayRefVar; (or)  \r\ndataType [][]arrayRefVar; (or)  \r\ndataType arrayRefVar[][]; (or)  \r\ndataType []arrayRefVar[];   \r\nExample to instantiate Multidimensional Array in java\r\n\r\nint[][] arr=new int[3][3];//3 row and 3 column  \r\nExample to initialize Multidimensional Array in java\r\n\r\narr[0][0]=1;  \r\narr[0][1]=2;  \r\narr[0][2]=3;  \r\narr[1][0]=4;  \r\narr[1][1]=5;  \r\narr[1][2]=6;  \r\narr[2][0]=7;  \r\narr[2][1]=8;  \r\narr[2][2]=9;  ', 'class Testarray3{  \r\npublic static void main(String args[]){  \r\n  \r\n//declaring and initializing 2D array  \r\nint arr[][]={{1,2,3},{2,4,5},{4,4,5}};  \r\n  \r\n//printing 2D array  \r\nfor(int i=0;i<3;i++){  \r\n for(int j=0;j<3;j++){  \r\n   System.out.print(arr[i][j]+" ");  \r\n }  \r\n System.out.println();  \r\n}  \r\n  \r\n}} ', 15, 1),
(72, 2, 'class name of java array', 'In java, array is an object. For array object, an proxy class is created whose name can be obtained by getClass().getName() method on the object.', 'class Testarray4{  \r\npublic static void main(String args[]){  \r\n  \r\nint arr[]={4,4,5};  \r\n  \r\nClass c=arr.getClass();  \r\nString name=c.getName();  \r\n  \r\nSystem.out.println(name);  \r\n  \r\n}} ', 10, 0),
(73, 2, 'Wrapper class in Java', 'Wrapper class in java provides the mechanism to convert primitive into object and object into primitive.\r\n\r\nSince J2SE 5.0, autoboxing and unboxing feature converts primitive into object and object into primitive automatically. The automatic conversion of primitive into object is known and autoboxing and vice-versa unboxing.', 'Wrapper class Example: Primitive to Wrapper\r\n\r\npublic class WrapperExample1{  \r\npublic static void main(String args[]){  \r\n//Converting int into Integer  \r\nint a=20;  \r\nInteger i=Integer.valueOf(a);//converting int into Integer  \r\nInteger j=a;//autoboxing, now compiler will write Integer.valueOf(a) internally  \r\n  \r\nSystem.out.println(a+" "+i+" "+j);  \r\n}}  \r\nOutput:\r\n\r\n20 20 20\r\nWrapper class Example: Wrapper to Primitive\r\n\r\npublic class WrapperExample2{    \r\npublic static void main(String args[]){    \r\n//Converting Integer to int    \r\nInteger a=new Integer(3);    \r\nint i=a.intValue();//converting Integer to int  \r\nint j=a;//unboxing, now compiler will write a.intValue() internally    \r\n    \r\nSystem.out.println(a+" "+i+" "+j);    \r\n}}    \r\nOutput:\r\n\r\n3 3 3', 10, 0),
(74, 2, 'Call by Value and Call by Reference in Java', 'There is only call by value in java, not call by reference. If we call a method passing a value, it is known as call by value. The changes being done in the called method, is not affected in the calling method.', 'Example of call by value in java\r\n\r\nIn case of call by value original value is not changed. Let''s take a simple example:\r\nclass Operation{  \r\n int data=50;  \r\n  \r\n void change(int data){  \r\n data=data+100;//changes will be in the local variable only  \r\n }  \r\n     \r\n public static void main(String args[]){  \r\n   Operation op=new Operation();  \r\n  \r\n   System.out.println("before change "+op.data);  \r\n   op.change(500);  \r\n   System.out.println("after change "+op.data);  \r\n  \r\n }  \r\n}', 10, 0),
(75, 2, 'Java Strictfp Keyword', 'Java strictfp keyword ensures that you will get the same result on every platform if you perform operations in the floating-point variable. The precision may differ from platform to platform that is why java programming language have provided the strictfp keyword, so that you get same result on every platform. So, now you have better control over the floating-point arithmetic.', 'The strictfp keyword can be applied on methods, classes and interfaces.\r\n\r\nstrictfp class A{}//strictfp applied on class  \r\nstrictfp interface M{}//strictfp applied on interface  \r\nclass A{  \r\nstrictfp void m(){}//strictfp applied on method  \r\n} ', 10, 0),
(76, 2, 'Creating API Document | javadoc tool\r\n', 'We can create document api in java by the help of javadoc tool. In the java file, we must use the documentation comment /**... */ to post information for the class, method, constructor, fields etc.', 'package com.abc;  \r\n/** This class is a user-defined class that contains one methods cube.*/  \r\npublic class M{  \r\n  \r\n/** The cube method prints cube of the given number */  \r\npublic static void  cube(int n){System.out.println(n*n*n);}  \r\n} ', 10, 0),
(77, 0, 'Java Command Line Arguments', 'The java command-line argument is an argument i.e. passed at the time of running the java program.\r\n\r\nThe arguments passed from the console can be received in the java program and it can be used as an input.\r\n\r\nSo, it provides a convenient way to check the behavior of the program for the different values. You can pass N (1,2,3 and so on) numbers of arguments from the command prompt.', 'Simple example of command-line argument in java\r\n\r\nIn this example, we are receiving only one argument and printing it. To run this java program, you must pass at least one argument from the command prompt.\r\nclass CommandLineExample{  \r\npublic static void main(String args[]){  \r\nSystem.out.println("Your first argument is: "+args[0]);  \r\n}  \r\n}  \r\ncompile by > javac CommandLineExample.java  \r\nrun by > java CommandLineExample sonoo  \r\nOutput: Your first argument is: sonoo', 10, 0),
(78, 0, 'Difference between object and class', 'Object:\r\n1)	Object is an instance of a class.\r\n2)	Object is a real world entity such as pen, laptop, mobile, bed, keyboard, mouse, chair etc.\r\n3)	Object is a physical entity.\r\n4)	Object is created through new keyword mainly e.g.\r\nStudent s1=new Student();\r\n5)	Object is created many times as per requirement.\r\n6)	Object allocates memory when it is created.\r\n7)	There are many ways to create object in java such as new keyword, newInstance() method, clone() method, factory method and deserialization.\r\n\r\nClass:\r\n1. Class is a blueprint or template from which objects are created.\r\n2. Class is a group of similar objects.\r\n3. Class is a logical entity.\r\n4. Class is declared using class keyword e.g. class Student{}\r\n5. Class is declared once.\r\n6. Class doesn''t allocated memory when it is created.\r\n7. There is only one way to define class in java using class keyword.\r\n', '', 10, 0),
(79, 0, 'Difference between method overloading and method overriding in java', 'Method overloading:\r\n1)	Method overloading is used to increase the readability of the program.\r\n2)	Method overloading is performed within class.\r\n3)	In case of method overloading, parameter must be different.\r\n4)	Method overloading is the example of compile time polymorphism.\r\n5)	In java, method overloading can''t be performed by changing return type of the method only. Return type can be same or different in method overloading. But you must have to change the parameter.\r\n\r\nMethod overriding:\r\n1. Method overriding is used to provide the specific implementation of the method that is already provided by its super class.\r\n2. Method overriding occurs in two classes that have IS-A (inheritance) relationship.\r\n3. In case of method overriding, parameter must be same.\r\n4. Method overriding is the example of run time polymorphism.\r\n5. Return type must be same or covariant in method overriding.', 'Java Method Overloading example\r\n\r\nclass OverloadingExample{  \r\nstatic int add(int a,int b){return a+b;}  \r\nstatic int add(int a,int b,int c){return a+b+c;}  \r\n}  \r\nJava Method Overriding example\r\n\r\nclass Animal{  \r\nvoid eat(){System.out.println("eating...");}  \r\n}  \r\nclass Dog extends Animal{  \r\nvoid eat(){System.out.println("eating bread...");}  \r\n}  ', 10, 0),
(80, 0, 'Java String', 'ava String provides a lot of concepts that can be performed on a string such as compare, concat, equals, split, length, replace, compareTo, intern, substring etc.\r\n\r\nIn java, string is basically an object that represents sequence of char values.\r\n\r\nAn array of characters works same as java string. For example:\r\n\r\nchar[] ch={''j'',''a'',''v'',''a'',''t'',''p'',''o'',''i'',''n'',''t''};  \r\nString s=new String(ch);  \r\nis same as:\r\n\r\nString s="javatpoint";  \r\nThe java.lang.String class implements Serializable, Comparable and CharSequence interfaces.\r\n\r\nThe java String is immutable i.e. it cannot be changed but a new instance is created. For mutable class, you can use StringBuffer and StringBuilder class.\r\n\r\nWe will discuss about immutable string later. Let''s first understand what is string in java and how to create the string object.', 'public class StringExample{  \r\npublic static void main(String args[]){  \r\nString s1="java";//creating string by java string literal  \r\n  \r\nchar ch[]={''s'',''t'',''r'',''i'',''n'',''g'',''s''};  \r\nString s2=new String(ch);//converting char array to string  \r\n  \r\nString s3=new String("example");//creating java string by new keyword  \r\n  \r\nSystem.out.println(s1);  \r\nSystem.out.println(s2);  \r\nSystem.out.println(s3);  \r\n}}  ', 10, 0),
(81, 202, 'Java String class methods', 'Method:\r\n1	char charAt(int index)\r\nreturns char value for the particular index\r\n\r\n2	int length()	\r\nreturns string length\r\n\r\n3	static String format(String format, Object... args)	\r\nreturns formatted string\r\n\r\n4	static String format(Locale l, String format, Object... args)	\r\nreturns formatted string with given locale\r\n\r\n5	String substring(int beginIndex)	returns substring for given begin index\r\n\r\n6	String substring(int beginIndex, int endIndex)	\r\nreturns substring for given begin index and end index', '', 15, 1),
(82, 2, 'Immutable String in Java', 'In java, string objects are immutable. Immutable simply means unmodifiable or unchangeable.\r\n\r\nOnce string object is created its data or state can''t be changed but a new string object is created.', 'class Testimmutablestring{  \r\n public static void main(String args[]){  \r\n   String s="Sachin";  \r\n   s.concat(" Tendulkar");//concat() method appends the string at the end  \r\n   System.out.println(s);//will print Sachin because strings are immutable objects  \r\n }  \r\n}  ', 10, 0),
(83, 0, 'Java String compare', 'We can compare string in java on the basis of content and reference.\r\n\r\nIt is used in authentication (by equals() method), sorting (by compareTo() method), reference matching (by == operator) etc.\r\n\r\nThere are three ways to compare string in java:\r\n\r\nBy equals() method\r\nBy = = operator\r\nBy compareTo() method', 'class Teststringcomparison1{  \r\n public static void main(String args[]){  \r\n   String s1="Sachin";  \r\n   String s2="Sachin";  \r\n   String s3=new String("Sachin");  \r\n   String s4="Saurav";  \r\n   System.out.println(s1.equals(s2));//true  \r\n   System.out.println(s1.equals(s3));//true  \r\n   System.out.println(s1.equals(s4));//false  \r\n }  \r\n}', 10, 0),
(84, 202, 'String compare by equals() method', 'The String equals() method compares the original content of the string. It compares values of string for equality. String class provides two methods:\r\n\r\npublic boolean equals(Object another) compares this string to the specified object.\r\npublic boolean equalsIgnoreCase(String another) compares this String to another string, ignoring case.', 'class Teststringcomparison1{  \r\n public static void main(String args[]){  \r\n   String s1="Sachin";  \r\n   String s2="Sachin";  \r\n   String s3=new String("Sachin");  \r\n   String s4="Saurav";  \r\n   System.out.println(s1.equals(s2));//true  \r\n   System.out.println(s1.equals(s3));//true  \r\n   System.out.println(s1.equals(s4));//false  \r\n }  \r\n}  ', 15, 1),
(85, 202, 'String compare by == operator', 'The = = operator compares references not values.', 'class Teststringcomparison3{  \r\n public static void main(String args[]){  \r\n   String s1="Sachin";  \r\n   String s2="Sachin";  \r\n   String s3=new String("Sachin");  \r\n   System.out.println(s1==s2);//true (because both refer to same instance)  \r\n   System.out.println(s1==s3);//false(because s3 refers to instance created in nonpool)  \r\n }  \r\n}  ', 25, 1),
(86, 202, 'String compare by compareTo() method', 'The String compareTo() method compares values lexicographically and returns an integer value that describes if first string is less than, equal to or greater than second string.\r\n\r\nSuppose s1 and s2 are two string variables. If:\r\n\r\ns1 == s2 :0\r\ns1 > s2   :positive value\r\ns1 < s2   :negative value', 'class Teststringcomparison4{  \r\n public static void main(String args[]){  \r\n   String s1="Sachin";  \r\n   String s2="Sachin";  \r\n   String s3="Ratan";  \r\n   System.out.println(s1.compareTo(s2));//0  \r\n   System.out.println(s1.compareTo(s3));//1(because s1>s3)  \r\n   System.out.println(s3.compareTo(s1));//-1(because s3 < s1 )  \r\n }  \r\n} ', 5, 1),
(87, 0, 'String Concatenation in Java', 'Java string concatenation operator (+) is used to add strings', 'class TestStringConcatenation1{  \r\n public static void main(String args[]){  \r\n   String s="Sachin"+" Tendulkar";  \r\n   System.out.println(s);//Sachin Tendulkar  \r\n }  \r\n}  ', 10, 0),
(88, 2, 'String Concatenation by concat() method', 'The String concat() method concatenates the specified string to the end of current string. Syntax:\r\n\r\npublic String concat(String another)  ', 'class TestStringConcatenation3{  \r\n public static void main(String args[]){  \r\n   String s1="Sachin ";  \r\n   String s2="Tendulkar";  \r\n   String s3=s1.concat(s2);  \r\n   System.out.println(s3);//Sachin Tendulkar  \r\n  }  \r\n}', 10, 0),
(89, 2, 'Substring in Java', 'A part of string is called substring. In other words, substring is a subset of another string. In case of substring startIndex is inclusive and endIndex is exclusive.\r\n\r\nNote: Index starts from 0.\r\n\r\nYou can get substring from the given string object by one of the two methods:\r\n\r\npublic String substring(int startIndex): This method returns new String object containing the substring of the given string from specified startIndex (inclusive).\r\npublic String substring(int startIndex, int endIndex): This method returns new String object containing the substring of the given string from specified startIndex to endIndex.\r\nIn case of string:\r\n\r\nstartIndex: inclusive\r\nendIndex: exclusive', 'public class TestSubstring{  \r\n public static void main(String args[]){  \r\n   String s="Sachin Tendulkar";  \r\n   System.out.println(s.substring(6));//Tendulkar  \r\n   System.out.println(s.substring(0,6));//Sachin  \r\n }  \r\n}  ', 10, 0),
(90, 2, 'Java String class methods', 'The java.lang.String class provides a lot of methods to work on string. By the help of these methods, we can perform operations on string such as trimming, concatenating, converting, comparing, replacing strings etc.\r\n\r\nJava String is a powerful concept because everything is treated as a string if you submit any form in window based, web based or mobile application.\r\n\r\nLet''s see the important methods of String class.\r\n\r\nJava String toUpperCase() and toLowerCase() method\r\n\r\nThe java string toUpperCase() method converts this string into uppercase letter and string toLowerCase() method into lowercase letter.', 'String s="Sachin";  \r\nSystem.out.println(s.toUpperCase());//SACHIN  \r\nSystem.out.println(s.toLowerCase());//sachin  \r\nSystem.out.println(s);//Sachin(no change in original)  ', 10, 0),
(91, 0, 'Java String trim() method', 'The string trim() method eliminates white spaces before and after string.', 'String s="  Sachin  ";  \r\nSystem.out.println(s);//  Sachin    \r\nSystem.out.println(s.trim());//Sachin  ', 10, 0),
(92, 202, 'Java String charAt() method', 'The string charAt() method returns a character at specified index.', 'String s="Sachin";  \r\nSystem.out.println(s.charAt(0));//S  \r\nSystem.out.println(s.charAt(3));//h  ', 15, 1),
(93, 23, 'Java StringBuffer class', 'Java StringBuffer class is used to created mutable (modifiable) string. The StringBuffer class in java is same as String class except it is mutable i.e. it can be changed.\r\n\r\nImportant Constructors of StringBuffer class\r\n\r\nStringBuffer(): creates an empty string buffer with the initial capacity of 16.\r\nStringBuffer(String str): creates a string buffer with the specified string.\r\nStringBuffer(int capacity): creates an empty string buffer with the specified capacity as length.\r\n\r\n\r\nImportant methods of StringBuffer class\r\n\r\npublic synchronized StringBuffer append(String s): is used to append the specified string with this string. The append() method is overloaded like append(char), append(boolean), append(int), append(float), append(double) etc.\r\npublic synchronized StringBuffer insert(int offset, String s): is used to insert the specified string with this string at the specified position. The insert() method is overloaded like insert(int, char), insert(int, boolean), insert(int, int), insert(int, float), insert(int, double) etc.\r\npublic synchronized StringBuffer replace(int startIndex, int endIndex, String str): is used to replace the string from specified startIndex and endIndex.\r\npublic synchronized StringBuffer delete(int startIndex, int endIndex): is used to delete the string from specified startIndex and endIndex.\r\npublic synchronized StringBuffer reverse(): is used to reverse the string.\r\npublic int capacity(): is used to return the current capacity.\r\npublic void ensureCapacity(int minimumCapacity): is used to ensure the capacity at least equal to the given minimum.\r\npublic char charAt(int index): is used to return the character at the specified position.\r\npublic int length(): is used to return the length of the string i.e. total number of characters.\r\npublic String substring(int beginIndex): is used to return the substring from the specified beginIndex.\r\npublic String substring(int beginIndex, int endIndex): is used to return the substring from the specified beginIndex and endIndex.\r\n\r\n', '', 25, 1),
(94, 2, 'Java StringBuilder class', 'Java StringBuilder class is used to create mutable (modifiable) string. The Java StringBuilder class is same as StringBuffer class except that it is non-synchronized. It is available since JDK 1.5.\r\n\r\nImportant Constructors of StringBuilder class\r\n\r\nStringBuilder(): creates an empty string Builder with the initial capacity of 16.\r\nStringBuilder(String str): creates a string Builder with the specified string.\r\nStringBuilder(int length): creates an empty string Builder with the specified capacity as length.', '1) StringBuilder append() method\r\n\r\nThe StringBuilder append() method concatenates the given argument with this string.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder("Hello ");  \r\nsb.append("Java");//now original string is changed  \r\nSystem.out.println(sb);//prints Hello Java  \r\n}  \r\n}  \r\n2) StringBuilder insert() method\r\n\r\nThe StringBuilder insert() method inserts the given string with this string at the given position.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder("Hello ");  \r\nsb.insert(1,"Java");//now original string is changed  \r\nSystem.out.println(sb);//prints HJavaello  \r\n}  \r\n}  \r\n3) StringBuilder replace() method\r\n\r\nThe StringBuilder replace() method replaces the given string from the specified beginIndex and endIndex.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder("Hello");  \r\nsb.replace(1,3,"Java");  \r\nSystem.out.println(sb);//prints HJavalo  \r\n}  \r\n}  \r\n4) StringBuilder delete() method\r\n\r\nThe delete() method of StringBuilder class deletes the string from the specified beginIndex to endIndex.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder("Hello");  \r\nsb.delete(1,3);  \r\nSystem.out.println(sb);//prints Hlo  \r\n}  \r\n}  \r\n5) StringBuilder reverse() method\r\n\r\nThe reverse() method of StringBuilder class reverses the current string.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder("Hello");  \r\nsb.reverse();  \r\nSystem.out.println(sb);//prints olleH  \r\n}  \r\n}  \r\n6) StringBuilder capacity() method\r\n\r\nThe capacity() method of StringBuilder class returns the current capacity of the Builder. The default capacity of the Builder is 16. If the number of character increases from its current capacity, it increases the capacity by (oldcapacity*2)+2. For example if your current capacity is 16, it will be (16*2)+2=34.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder();  \r\nSystem.out.println(sb.capacity());//default 16  \r\nsb.append("Hello");  \r\nSystem.out.println(sb.capacity());//now 16  \r\nsb.append("java is my favourite language");  \r\nSystem.out.println(sb.capacity());//now (16*2)+2=34 i.e (oldcapacity*2)+2  \r\n}  \r\n}  \r\n7) StringBuilder ensureCapacity() method\r\n\r\nThe ensureCapacity() method of StringBuilder class ensures that the given capacity is the minimum to the current capacity. If it is greater than the current capacity, it increases the capacity by (oldcapacity*2)+2. For example if your current capacity is 16, it will be (16*2)+2=34.\r\n\r\nclass A{  \r\npublic static void main(String args[]){  \r\nStringBuilder sb=new StringBuilder();  \r\nSystem.out.println(sb.capacity());//default 16  \r\nsb.append("Hello");  \r\nSystem.out.println(sb.capacity());//now 16  \r\nsb.append("java is my favourite language");  \r\nSystem.out.println(sb.capacity());//now (16*2)+2=34 i.e (oldcapacity*2)+2  \r\nsb.ensureCapacity(10);//now no change  \r\nSystem.out.println(sb.capacity());//now 34  \r\nsb.ensureCapacity(50);//now (34*2)+2  \r\nSystem.out.println(sb.capacity());//now 70  \r\n}  \r\n}  ', 10, 0),
(95, 2, 'Performance Test of StringBuffer and StringBuilder', 'Let''s see the code to check the performance of StringBuffer and StringBuilder classes.', 'public class ConcatTest{  \r\n    public static void main(String[] args){  \r\n        long startTime = System.currentTimeMillis();  \r\n        StringBuffer sb = new StringBuffer("Java");  \r\n        for (int i=0; i<10000; i++){  \r\n            sb.append("Tpoint");  \r\n        }  \r\n        System.out.println("Time taken by StringBuffer: " + (System.currentTimeMillis() - startTime) + "ms");  \r\n        startTime = System.currentTimeMillis();  \r\n        StringBuilder sb2 = new StringBuilder("Java");  \r\n        for (int i=0; i<10000; i++){  \r\n            sb2.append("Tpoint");  \r\n        }  \r\n        System.out.println("Time taken by StringBuilder: " + (System.currentTimeMillis() - startTime) + "ms");  \r\n    }  \r\n} \r\n\r\nOutput:\r\nTime taken by StringBuffer: 16ms\r\nTime taken by StringBuilder: 0ms\r\n', 10, 0),
(96, 2, 'Immutable class', 'There are many immutable classes like String, Boolean, Byte, Short, Integer, Long, Float, Double etc. In short, all the wrapper classes and String class is immutable. We can also create immutable class by creating final class that have final data members as the example given below:', 'In this example, we have created a final class named Employee. It have one final datamember, a parameterized constructor and getter method.\r\npublic final class Employee{  \r\nfinal String pancardNumber;  \r\n  \r\npublic Employee(String pancardNumber){  \r\nthis.pancardNumber=pancardNumber;  \r\n}  \r\n  \r\npublic String getPancardNumber(){  \r\nreturn pancardNumber;  \r\n}  \r\n  \r\n}  \r\nThe above class is immutable because:\r\nThe instance variable of the class is final i.e. we cannot change the value of it after creating an object.\r\nThe class is final so we cannot create the subclass.\r\nThere is no setter methods i.e. we have no option to change the value of the instance variable.', 10, 0),
(97, 2, 'StringTokenizer in Java', 'The java.util.StringTokenizer class allows you to break a string into tokens. It is simple way to break string.\r\n\r\nIt doesn''t provide the facility to differentiate numbers, quoted strings, identifiers etc. like StreamTokenizer class. We will discuss about the StreamTokenizer class in I/O chapter.\r\n\r\nConstructors of StringTokenizer class\r\n\r\nThere are 3 constructors defined in the StringTokenizer class.\r\n\r\n1. StringTokenizer(String str)	\r\ncreates StringTokenizer with specified string.\r\n\r\n2. StringTokenizer(String str, String delim)	\r\ncreates StringTokenizer with specified string and delimeter.\r\n\r\n3. StringTokenizer(String str, String delim, boolean returnValue)	\r\ncreates StringTokenizer with specified string, delimeter and returnValue. If return value is true, delimiter characters are considered to be tokens. If it is false, delimiter characters serve to separate tokens.\r\n\r\n', '', 10, 0),
(98, 0, 'Java String charAt', 'The java string charAt() method returns a char value at the given index number. The index number starts from 0.\r\n\r\nSignature\r\n\r\nThe signature of string charAt() method is given below:\r\n\r\npublic char charAt(int index)  \r\nParameter\r\n\r\nindex : index number, starts with 0\r\n\r\nReturns\r\n\r\nchar value\r\n\r\nSpecified by\r\n\r\nCharSequence interface\r\n\r\nThrows\r\n\r\nIndexOutOfBoundsException : if index is negative value or greater than this string length.', 'public class CharAtExample{  \r\npublic static void main(String args[]){  \r\nString name="javatpoint";  \r\nchar ch=name.charAt(4);//returns the char value at the 4th index  \r\nSystem.out.println(ch);  \r\n}} \r\n\r\nOutput:\r\nt', 10, 0),
(99, 2, 'Java String compareTo() method', 'The java string compareTo() method compares the given string with current string lexicographically. It returns positive number, negative number or 0.\r\n\r\nIf first string is greater than second string, it returns positive number (difference of character value). If first string is less than second string, it returns negative number and if first string is equal to second string, it returns 0.\r\n\r\ns1 > s2 => positive number  \r\ns1 < s2 => negative number  \r\ns1 == s2 => 0  \r\nSignature\r\n\r\npublic int compareTo(String anotherString)  \r\nParameters\r\n\r\nanotherString: represents string that is to be compared with current string\r\n\r\nReturns\r\n\r\nan integer value', 'public class LastIndexOfExample{  \r\npublic static void main(String args[]){  \r\nString s1="hello";  \r\nString s2="hello";  \r\nString s3="meklo";  \r\nString s4="hemlo";  \r\nSystem.out.println(s1.compareTo(s2));  \r\nSystem.out.println(s1.compareTo(s3));  \r\nSystem.out.println(s1.compareTo(s4));  \r\n}}  \r\nOutput:\r\n\r\n0\r\n-5\r\n-1', 10, 0),
(100, 0, 'Java String concat', 'The java string concat() method combines specified string at the end of this string. It returns combined string. It is like appending another string.\r\n\r\nSignature\r\n\r\nThe signature of string concat() method is given below:\r\n\r\npublic String concat(String anotherString)  \r\nParameter\r\n\r\nanotherString : another string i.e. to be combined at the end of this string.\r\n\r\nReturns\r\n\r\ncombined string', 'public class ConcatExample{  \r\npublic static void main(String args[]){  \r\nString s1="java string";  \r\ns1.concat("is immutable");  \r\nSystem.out.println(s1);  \r\ns1=s1.concat(" is immutable so assign it explicitly");  \r\nSystem.out.println(s1);  \r\n}} ', 10, 0),
(201, 7, 'private constructor ', 'Used in singleton class. Makes sure that only one object is created for that class.', 'public class SingleTonClass {\r\n   //Static Class Reference\r\n   private static SingleTonClass obj=null;\r\n   private SingleTonClass(){\r\n      /*Private Constructor will prevent \r\n       * the instantiation of this class directly*/\r\n   }\r\n   public static SingleTonClass objectCreationMethod(){\r\n	/*This logic will ensure that no more than\r\n	 * one object can be created at a time */\r\n	if(obj==null){\r\n	    obj= new SingleTonClass();\r\n	}\r\n        return obj;\r\n   }\r\n   public void display(){\r\n	System.out.println("Singleton class Example");\r\n   }\r\n   public static void main(String args[]){\r\n	//Object cannot be created directly due to private constructor \r\n        //This way it is forced to create object via our method where\r\n        //we have logic for only one object creation\r\n	SingleTonClass myobject= SingleTonClass.objectCreationMethod();\r\n	myobject.display();\r\n   }\r\n}', 10, 2),
(202, 80, 'encapsulation', 'hide the private variables from the user and access them using getter and setter methods.', 'public class EncapsulationDemo{\r\n    private int ssn;\r\n    private String empName;\r\n    private int empAge;\r\n\r\n    //Getter and Setter methods\r\n    public int getEmpSSN(){\r\n        return ssn;\r\n    }\r\n\r\n    public String getEmpName(){\r\n        return empName;\r\n    }\r\n}', 12, 0),
(203, 23, 'aggregation', 'instance of one class in another class. Like a Student object having a Has-A relationship with Address object. ', 'class StudentClass\r\n{\r\n   int rollNum;\r\n   String studentName;\r\n   Address studentAddr; \r\n   StudentClass(int roll, String name, Address addr){\r\n       this.rollNum=roll;\r\n       this.studentName=name;\r\n       this.studentAddr = addr;\r\n   }', 10, 1),
(204, 234, 'super', '1) super.<variable_name> refers to the variable of variable of parent class.\r\n2) super() invokes the constructor of immediate parent class.\r\n3) super.<method_name> refers to the method of parent class.', '//Parent class or Superclass\r\nclass Parentclass\r\n{\r\n	int num=100;\r\n}\r\n//Child class or subclass\r\nclass Subclass extends Parentclass\r\n{\r\n    /* I am declaring the same variable \r\n     * num in child class too.\r\n     */\r\n    int num=110;\r\n    void printNumber(){\r\n 	System.out.println(num);\r\n    }\r\n    public static void main(String args[]){\r\n       Subclass obj= new Subclass();\r\n       obj.printNumber();	\r\n    }\r\n}', 15, 1),
(205, 65, 'static variable', 'Static variable’s value is same for all the object(or instances) of the class or in other words you can say that all instances(objects) of the same class share a single copy of static variables.\r\n', 'class VariableDemo\r\n{\r\n   static int count=0;\r\n   public void increment()\r\n   {\r\n       count++;\r\n   }\r\n}', 15, 0),
(206, 44, 'final variable ', 'final variables are nothing but constants. We cannot change the value of a final variable once it is initialized.', ' final int MAX_VALUE=99;', 10, 0),
(207, 30, 'blank final variable', 'Blank final variable\r\n\r\nA final variable that is not initialized at the time of declaration is known as blank final variable. We must initialize the blank final variable in constructor of the class otherwise it will throw a compilation error ', 'class Demo{  \r\n   //Blank final variable\r\n   final int MAX_VALUE;\r\n	 \r\n   Demo(){\r\n      //It must be initialized in constructor\r\n      MAX_VALUE=100;\r\n   }\r\n}', 10, 1),
(208, 23, 'final method\r\n\r\n', 'A final method cannot be overridden. Which means even though a sub class can call the final method of parent class without any issues but it cannot override it.', 'class XYZ{  \r\n   final void demo(){\r\n      System.out.println("XYZ Class Method");\r\n   }  \r\n}  \r\n	     \r\nclass ABC extends XYZ{  \r\n   void demo(){\r\n      System.out.println("ABC Class Method");\r\n   }  \r\n	     \r\n   public static void main(String args[]){  \r\n      ABC obj= new ABC();  \r\n      obj.demo();  \r\n   }  \r\n}', 15, 1),
(209, 77, 'final class\r\n\r\n', 'We cannot extend a final class.', 'final class XYZ{  \r\n}  \r\n	     \r\nclass ABC extends XYZ{  \r\n   void demo(){\r\n      System.out.println("My Method");\r\n   }  \r\n   public static void main(String args[]){  \r\n      ABC obj= new ABC(); \r\n      obj.demo();\r\n   }  \r\n}\r\nOutput:\r\n\r\nThe type ABC cannot subclass the final class XYZ', 12, 1),
(210, 89, 'interfaces', 'Interface looks like class but it is not a class. An interface can have methods and variables just like the class but the methods declared in interface are by default abstract (only method signature, no body). Also, the variables declared in an interface are public, static & final by default.', 'interface MyInterface\r\n{\r\n   /* All the methods are public abstract by default\r\n    * Note down that these methods are not having body\r\n    */\r\n   public void method1();\r\n   public void method2();\r\n}', 12, 2),
(211, 5, 'Multilevel inheritance', 'It’s pretty clear with the diagram that in Multilevel inheritance there is a concept of grand parent class. If we take the example of above diagram then class C inherits class B and class B inherits class A which means B is a parent class of C and A is a parent class of B. So in this case class C is implicitly inheriting the properties and method of class A along with B that’s what is called multilevel inheritance.', 'class Car{\r\n	public Car()\r\n	{\r\n		System.out.println("Class Car");\r\n	}\r\n	public void vehicleType()\r\n	{\r\n		System.out.println("Vehicle Type: Car");\r\n	}\r\n}\r\nclass Maruti extends Car{\r\n	public Maruti()\r\n	{\r\n		System.out.println("Class Maruti");\r\n	}\r\n	public void brand()\r\n	{\r\n		System.out.println("Brand: Maruti");\r\n	}\r\n	public void speed()\r\n	{\r\n		System.out.println("Max: 90Kmph");\r\n	}\r\n}\r\npublic class Maruti800 extends Maruti{\r\n\r\n	 public Maruti800()\r\n	 {\r\n		 System.out.println("Maruti Model: 800");\r\n	 }\r\n	 public void speed()\r\n		{\r\n			System.out.println("Max: 80Kmph");\r\n		}\r\n	 public static void main(String args[])\r\n	 {\r\n		 Maruti800 obj=new Maruti800();\r\n		 obj.vehicleType();\r\n		 obj.brand();\r\n		 obj.speed();\r\n	 }\r\n}\r\nOutput:\r\n\r\nClass Car\r\nClass Maruti\r\nMaruti Model: 800\r\nVehicle Type: Car\r\nBrand: Maruti\r\nMax: 80Kmph', 10, 2),
(212, 78, 'Garbage collection', 'Garbage collection deals with it and its main purpose are to delete all the objects that are either not in use or out of reach. So, all we do through a Java code is that we create objects as per our need and then destroy them when they are no longer in use. This garbage collector is under the control of JVM. Though JVM can be commanded to run the Garbage collector but then there seems no guarantee that actually the Garbage collector will be set out to work. So, the Garbage collector is normally run at the times when the JVM falls short of memory.', '', 12, 2),
(213, 0, 'inner class', 'What is an inner class?\r\n\r\nInner class are defined inside the body of another class (known as outer class). These classes can have access modifier or even can be marked as abstract and final. Inner classes have special relationship with outer class instances. This relationship allows them to have access to outer class members including private members too.', 'class MyOuterClassDemo {\r\n   private int x= 1;\r\n   public void innerInstance()\r\n   {\r\n       MyInnerClassDemo inner = new MyInnerClassDemo();\r\n       inner. seeOuter();\r\n   }\r\n   public static void main(String args[]){\r\n       MyOuterClassDemo obj = new MyOuterClassDemo();\r\n       obj.innerInstance();\r\n   }\r\n   // inner class definition\r\n   class MyInnerClassDemo {\r\n       public void seeOuter () {\r\n          System.out.println("Outer Value of x is :" + x);\r\n       }\r\n   } // close inner class definition	   \r\n} // close Top level class definition\r\nOutput:\r\n\r\nOuter Value of x is :1', 10, 2),
(214, 34, 'oops paradigms', '1)Encapsulation \r\n\r\nBinding the data with the code that manipulates it.\r\nIt keeps the data and the code safe from external interference\r\n\r\n2)Inheritance\r\n\r\nInheritance is the mechanism by which an object acquires the some/all properties of another object.\r\nIt supports the concept of hierarchical classification.\r\n\r\n3)Polymorphism\r\nPolymorphism means to process objects differently based on their data type.\r\nIn other words it means, one method with multiple implementation, for a certain class of action. And which implementation to be used is decided at runtime depending upon the situation (i.e., data type of the object)\r\nThis can be implemented by designing a generic interface, which provides generic methods for a certain class of action and there can be multiple classes, which provides the implementation of these generic methods.\r\n\r\n', '', 10, 0),
(215, 9, ' Static Nested Classes\r\n\r\n', 'A static nested classes are the inner classes marked with static modifier.Because this is static in nature so this type of inner class doesn’t share any special kind of relationship with an instance of outer class.A static nested class cannot access non static members of outer class.', 'class Outer{\r\n   static class Nested{}\r\n}\r\n//A static nested class can be //instantiated like this:\r\n\r\nclass Outer{// outer class\r\n   static class Nested{}// static nested class\r\n}\r\n\r\nclass Demo{\r\n   public static void main(string[] args){\r\n      // use both class names\r\n      Outer.Nested n= new Outer.Nested();\r\n   }\r\n}', 10, 2),
(216, 56, 'Hierarchical inheritance', 'As you can see in the above diagram that when a class has more than one child classes (sub classes) or in other words more than one child classes have the same parent class then such kind of inheritance is known as hierarchical.', 'Class A\r\n{\r\n  public void methodA()\r\n  {\r\n     System.out.println("method of Class A");\r\n  }\r\n}\r\nClass B extends A\r\n{\r\n  public void methodB()\r\n  {\r\n     System.out.println("method of Class B");\r\n  }\r\n}\r\nClass C extends A\r\n{\r\n public void methodC()\r\n {\r\n System.out.println("method of Class C");\r\n }\r\n}\r\nClass D extends A\r\n{\r\n  public void methodD()\r\n  {\r\n     System.out.println("method of Class D");\r\n  }\r\n}\r\nClass MyClass\r\n{\r\n  public void methodB()\r\n  {\r\n     System.out.println("method of Class B");\r\n  }\r\n  public static void main(String args[])\r\n  {\r\n     B obj1 = new B();\r\n     C obj2 = new C();\r\n     D obj3 = new D();\r\n     obj1.methodA();\r\n     obj2.methodA();\r\n     obj3.methodA();\r\n  }\r\n}', 10, 2),
(217, 36, 'packages', 'Packages in Java is a mechanism to encapsulate a group of classes, interfaces and sub packages. Many implementations of Java use a hierarchical file system to manage source and class files. It is easy to organize class files into packages. All we need to do is put related class files in the same directory, give the directory a name that relates to the purpose of the classes, and add a line to the top of each class file that declares the package name, which is the same as the directory name where they reside.', '', 15, 2),
(218, 90, 'Constructor overloading', 'Constructor overloading is way of having more than one constructor which does different-2 tasks. For e.g. Vector class has 4 types of constructors. If you do not want to specify the initial capacity and capacity increment then you can simply use default constructor of Vector class like this Vector v = new Vector(); however if you need to specify the capacity and increment then you call the parameterized constructor with two int args like this: Vector v= new Vector(10, 5);', 'public class StudentData\r\n{\r\n   private int stuID;\r\n   private String stuName;\r\n   private int stuAge;\r\n   StudentData()\r\n   {\r\n       //Default constructor\r\n       stuID = 100;\r\n       stuName = "New Student";\r\n       stuAge = 18;\r\n   }\r\n   StudentData(int num1, String str, int num2)\r\n   {\r\n       //Parameterized constructor\r\n       stuID = num1;\r\n       stuName = str;\r\n       stuAge = num2;\r\n   }\r\n   //Getter and setter methods\r\n   public int getStuID() {\r\n       return stuID;\r\n   }\r\n   public void setStuID(int stuID) {\r\n       this.stuID = stuID;\r\n   }\r\n   public String getStuName() {\r\n       return stuName;\r\n   }\r\n   public void setStuName(String stuName) {\r\n       this.stuName = stuName;\r\n   }\r\n   public int getStuAge() {\r\n       return stuAge;\r\n   }\r\n   public void setStuAge(int stuAge) {\r\n       this.stuAge = stuAge;\r\n   }\r\n}\r\n\r\nclass TestOverloading\r\n{\r\n   public static void main(String args[])\r\n   {\r\n       //This object creation would call the default constructor\r\n       StudentData myobj = new StudentData();\r\n       System.out.println("Student Name is: "+myobj.getStuName());\r\n       System.out.println("Student Age is: "+myobj.getStuAge());\r\n       System.out.println("Student ID is: "+myobj.getStuID());\r\n\r\n       /*This object creation would call the parameterized\r\n        * constructor StudentData(int, String, int)*/\r\n       StudentData myobj2 = new StudentData(555, "Chaitanya", 25);\r\n       System.out.println("Student Name is: "+myobj2.getStuName());\r\n       System.out.println("Student Age is: "+myobj2.getStuAge());\r\n       System.out.println("Student ID is: "+myobj2.getStuID()); \r\n  }\r\n}', 12, 1),
(219, 24, 'Enum datatype', 'An enum is a special type of data type which is basically a collection (set) of constants.', 'public enum Directions{\r\n  EAST, \r\n  WEST, \r\n  NORTH, \r\n  SOUTH\r\n}', 10, 0),
(220, 82, 'HashMap', 'HashMap is a Map based collection class that is used for storing Key & value pairs. This class makes no guarantees as to the order of the map. It is similar to the Hashtable class except that it is unsynchronized and permits nulls(null values and null key)', '  /* This is how to declare HashMap */\r\n      HashMap<Integer, String> hmap = new HashMap<Integer, String>();\r\n\r\n      /*Adding elements to HashMap*/\r\n      hmap.put(12, "Chaitanya");\r\n      hmap.put(2, "Rahul");\r\n      hmap.put(7, "Singh");\r\n      hmap.put(49, "Ajeet");\r\n      hmap.put(3, "Anuj");\r\n\r\n      /* Display content using Iterator*/\r\n      Set set = hmap.entrySet();\r\n      Iterator iterator = set.iterator();\r\n      while(iterator.hasNext()) {\r\n         Map.Entry mentry = (Map.Entry)iterator.next();\r\n         System.out.print("key is: "+ mentry.getKey() + " & Value is: ");\r\n         System.out.println(mentry.getValue());\r\n      }\r\n\r\n      /* Get values based on key*/\r\n      String var= hmap.get(2);\r\n      System.out.println("Value at index 2 is: "+var);\r\n\r\n      /* Remove values based on key*/\r\n      hmap.remove(3);\r\n      System.out.println("Map key and values after removal:");\r\n      Set set2 = hmap.entrySet();\r\n      Iterator iterator2 = set2.iterator();\r\n      while(iterator2.hasNext()) {\r\n          Map.Entry mentry2 = (Map.Entry)iterator2.next();\r\n          System.out.print("Key is: "+mentry2.getKey() + " & Value is: ");\r\n          System.out.println(mentry2.getValue());\r\n       }', 10, 2),
(221, 22, 'creating Vector objects', 'Vector implements List Interface. Like ArrayList it also maintains insertion order but it is rarely used in non-thread environment as it is synchronized and due to which it gives poor performance in searching, adding, delete and update of its elements.', '//Method 1:\r\nVector vec = new Vector();\r\n\r\n\r\n//Method 2:\r\n//Syntax: \r\nVector object= new Vector(int initialCapacity)\r\nVector vec = new Vector(3);\r\n//It will create a Vector of initial capacity of 3.\r\n\r\n//Method 3:\r\n//Syntax:\r\nVector object= new vector(int initialcapacity, capacityIncrement)\r\nVector vec= new Vector(4, 6)\r\n/*Here we have provided two arguments. The initial capacity is 4 and capacityIncrement is 6. It means upon insertion of 5th element the size would be 10 (4+6) and on 11th insertion it would be 16(10+6).\r\n*/', 10, 2),
(222, 12, 'Thread creation using runnable', 'One way of creating a thread is to create a class that implements the Runnable interface. We must need to give the definition of run() method.\r\nThis run method is the entry point for the thread and thread will be alive till run method finishes its execution.\r\nOnce the thread is created it will start running when start() method gets called. Basically start() method calls run() method implicitly.', 'class MultithreadingDemo implements Runnable{  \r\n  public void run(){  \r\n    System.out.println("My thread is in running state.");  \r\n  }   \r\n  public static void main(String args[]){  \r\n     MultithreadingDemo obj=new MultithreadingDemo();  \r\n     Thread tobj =new Thread(obj);  \r\n     tobj.start();  \r\n }  \r\n}', 15, 2),
(223, 12, 'Thread creation by extending Thread class', 'This is the second way of creating a thread. Here we need to create a new class that extends the Thread class.\r\nThe class should override the run() method which is the entry point for the new thread as described above.\r\nCall start() method to start the execution of a thread.', 'class MultithreadingDemo extends Thread{  \r\n  public void run(){  \r\n    System.out.println("My thread is in running state.");  \r\n  }   \r\n  public static void main(String args[]){  \r\n     MultithreadingDemo obj=new MultithreadingDemo();   \r\n     obj.start();  \r\n  }  \r\n}', 30, 2),
(224, 15, 'Synchronized', 'Multithreading introduces asynchronous behavior to the programs. If a thread is writing some data another thread may be reading the same data at that time. This may bring inconsistency.\r\nWhen two or more threads need access to a shared resource there should be some way that the resource will be used only by one resource at a time. The process to achieve this is called synchronization.\r\nTo implement the synchronous behavior java has synchronous method. Once a thread is inside a synchronized method, no other thread can call any other synchronized method on the same object. All the other threads then wait until the first thread come out of the synchronized block.\r\nWhen we want to synchronize access to objects of a class which was not designed for the multithreaded access and the code of the method which needs to be accessed synchronously is not available with us, in this case we cannot add the synchronized to the appropriate methods. In java we have the solution for this, put the calls to the methods (which needs to be synchronized) defined by this class inside a synchronized block in following manner.', 'Synchronized(object)\r\n{\r\n    // statement to be synchronized\r\n}', 25, 2);
INSERT INTO `notessal` (`notesid`, `uid`, `topic`, `content`, `code`, `likes`, `nlevel`) VALUES
(225, 24, 'execution on JVM', '1) JVM executes Java byte codes\r\n2) Other programming language codes if converted to adequate Java byte code can be executed on JVM\r\n3) JVM is different for different platforms and can also act as a platform itself\r\n4) JVM supports automatic  error handling by  intercepting the errors which can be controlled\r\n5) This feature is useful in platform independency and multi user ability of Java.', '', 10, 0),
(226, 33, 'Compilation of java code', '1) The compiler requires to know the TYPE of every CLASS used in the program source code\r\n2) This is done by setting a default user environment variable CLASSPATH\r\n3) The Javac (Java Compiler) reads the program and converts it into byte code files called as class files', '', 10, 0),
(227, 19, 'for loop', 'It executes a block of statements repeatedly until the specified condition returns false.', 'for (initialization; condition; increment/decrement) {\r\n    statement(s) //block of statements\r\n}', 10, 0),
(228, 24, 'Even or odd number', 'Check whether an entered number is even or odd', 'import java.util.Scanner;\r\n\r\nclass CheckEvenOdd\r\n{\r\n  public static void main(String args[])\r\n  {\r\n    int num;\r\n    System.out.println("Enter an Integer number:");\r\n\r\n    //The input provided by user is stored in num\r\n    Scanner input = new Scanner(System.in);\r\n    num = input.nextInt();\r\n\r\n    /* If number is divisible by 2 then it''s an even number\r\n     * else odd number*/\r\n    if ( num % 2 == 0 )\r\n        System.out.println("Entered number is even");\r\n     else\r\n        System.out.println("Entered number is odd");\r\n  }\r\n}', 10, 0),
(229, 78, 'Exception', 'An Exception can be anything which interrupts the normal flow of the program. When an exception occurs program processing gets terminated and doesn’t continue further. In such cases we get a system generated error message. The good thing about exceptions is that they can be handled. We will cover the handling part later in this same tutorial.\r\n\r\nWhen an exception can occur?\r\nException can occur at runtime (known as runtime exceptions) as well as at compile-time (known Compile-time exceptions).\r\n\r\nReasons for Exceptions\r\nThere can be several reasons for an exception. For example, following situations can cause an exception – Opening a non-existing file, Network connection problem, Operands being manipulated are out of prescribed ranges, class file missing which was supposed to be loaded and so on.', '', 15, 2),
(230, 90, 'try-catch ', 'What is Try Block?\r\n\r\nThe try block contains a block of program statements within which an exception might occur. A try block is always followed by a catch block, which handles the exception that occurs in associated try block. A try block must followed by a Catch block or Finally block or both.\r\n\r\nWhat is Catch Block?\r\n\r\nA catch block must be associated with a try block. The corresponding catch block executes if an exception of a particular type occurs within the try block. For example if an arithmetic exception occurs in try block then the statements enclosed in catch block for arithmetic exception executes.', 'try\r\n{\r\n     //statements that may cause an exception\r\n}\r\ncatch (exception(type) e(object))?\r\n{\r\n     //error handling code\r\n}', 12, 1),
(231, 55, 'Multiple catch blocks ', 'Multiple catch blocks in Java\r\n\r\n1. A try block can have any number of catch blocks.\r\n2. A catch block that is written for catching the class Exception can catch all other exceptions\r\n3. If multiple catch blocks are present in a program then the above mentioned catch block should be placed at the last as per the exception handling best practices.\r\n4. If the try block is not throwing any exception, the catch block will be completely ignored and the program continues.\r\n5. If the try block throws an exception, the appropriate catch block (if one exists) will catch it\r\n–catch(ArithmeticException e) is a catch block that can catch ArithmeticException\r\n–catch(NullPointerException e) is a catch block that can catch NullPointerException\r\n6. All the statements in the catch block will be executed and then the program continues.', 'class Example2{\r\n   public static void main(String args[]){\r\n     try{\r\n         int a[]=new int[7];\r\n         a[4]=30/0;\r\n         System.out.println("First print statement in try block");\r\n     }\r\n     catch(ArithmeticException e){\r\n        System.out.println("Warning: ArithmeticException");\r\n     }\r\n     catch(ArrayIndexOutOfBoundsException e){\r\n        System.out.println("Warning: ArrayIndexOutOfBoundsException");\r\n     }\r\n     catch(Exception e){\r\n        System.out.println("Warning: Some Other exception");\r\n     }\r\n   System.out.println("Out of try-catch block...");\r\n  }\r\n}', 30, 2),
(232, 103, 'Nested try catch', 'The try catch blocks can be nested. One try-catch block can be present in the another try’s body. This is called Nesting of try catch blocks. Each time a try block does not have a catch handler for a particular exception, the stack is unwound and the next try block’s catch (i.e., parent try block’s catch) handlers are inspected for a match.\r\n\r\nIf no catch block matches, then the java run-time system will handle the exception.', '....\r\n//Main try block\r\ntry\r\n{\r\n   statement 1;\r\n   statement 2;\r\n   //try-catch block inside another try block\r\n   try\r\n   {\r\n      statement 3;\r\n      statement 4;\r\n   }\r\n   catch(Exception e1)\r\n   {\r\n       //Exception Message\r\n   }\r\n   //try-catch block inside another try block\r\n   try\r\n   {\r\n       statement 5;\r\n       statement 6;\r\n   }\r\n   catch(Exception e2)\r\n   {\r\n       //Exception Message\r\n   }\r\n}\r\ncatch(Exception e3) //Catch of Main(parent) try block\r\n{\r\n      //Exception Message\r\n}\r\n....', 12, 2),
(233, 255, 'Throws clause', '1. The throws keyword is used in method declaration, in order to explicitly specify the exceptions that a particular method might throw. When a method declaration has one or more exceptions defined using throws clause then the method-call must handle all the defined exceptions.\r\n2. When defining a method you must include a throws clause to declare those exceptions that might be thrown but doesn’t get caught in the method.\r\n3. If a method is using throws clause along with few exceptions then this implicitly tells other methods that – “ If you call me, you must handle these exceptions that I throw”.', 'void MethodName() throws ExceptionName{\r\n    Statement1\r\n    ...\r\n    ...\r\n}', 12, 1),
(234, 234, 'User defined exception', 'User defined exceptions in java are also known as Custom exceptions. Most of the times when we are developing an application in java, we often feel a need to create and throw our own exceptions. These exceptions are known as User defined or Custom exceptions. ', 'lass MyException extends Exception{\r\n    String str1;\r\n    MyException(String str2) {\r\n       str1=str2;\r\n    }\r\n    public String toString(){ \r\n       return ("Output String = "+str1) ;\r\n    }\r\n}\r\n\r\nclass CustomException{\r\n    public static void main(String args[]){\r\n       try{\r\n          throw new MyException("Custom");\r\n          // I''m throwing user defined custom exception above\r\n       }\r\n       catch(MyException exp){\r\n          System.out.println("Hi this is my catch block") ;\r\n          System.out.println(exp) ;\r\n       }\r\n    }\r\n}\r\nOutput:\r\n\r\nHi this is my catch block\r\nOutput String = Custom', 12, 2),
(235, 456, 'Hybrid inheritance', ' that it’s a combine form of single and multiple inheritance. Since java doesn’t support multiple inheritance, the hybrid inheritance is also not possible.\r\n\r\nCase 1:  Using classes: If in above figure B and C are classes then this inheritance is not allowed as a single class cannot extend more than one class (Class D is extending both B and C).\r\n\r\nCase 2: Using Interfaces: If B and C are interfaces then the above hybrid inheritance is allowed as a single class can implement any number of interfaces in java.', 'public class A\r\n{\r\n     public void methodA()\r\n     {\r\n           System.out.println("Class A methodA");\r\n      }\r\n}\r\npublic class B extends A\r\n{\r\n      public void methodA()\r\n      {\r\n           System.out.println("Child class B is overriding inherited method A");\r\n      }\r\n      public void methodB()\r\n      {\r\n           System.out.println("Class B methodB");\r\n       }\r\n}\r\npublic class C extends A\r\n{\r\n      public void methodA()\r\n      {\r\n           System.out.println("Child class C is overriding the methodA");\r\n       }\r\n      public void methodC()\r\n      {\r\n           System.out.println("Class C methodC");\r\n       }\r\n}\r\npublic class D extends B, C\r\n{\r\n      public void methodD()\r\n      {\r\n           System.out.println("Class D methodD");\r\n       }\r\n       public static void main(String args[])\r\n       {\r\n              D obj1= new D();\r\n              obj1.methodD();\r\n              obj1.methodA();\r\n       }\r\n}', 12, 2),
(236, 9, 'Java Regex', 'The Java Regex or Regular Expression is an API to define pattern for searching or manipulating strings.\r\n\r\nIt is widely used to define constraint on strings such as password and email validation. After learning java regex tutorial, you will be able to test your own regular expressions by the Java Regex Tester Tool.\r\n\r\nJava Regex API provides 1 interface and 3 classes in java.util.regex package.\r\n\r\njava.util.regex package\r\n\r\nIt provides following classes and interface for regular expressions. The Matcher and Pattern classes are widely used in java regular expression.\r\n\r\nMatchResult interface\r\nMatcher class\r\nPattern class\r\nPatternSyntaxException class', 'import java.util.regex.*;  \r\npublic class RegexExample1{  \r\npublic static void main(String args[]){  \r\n//1st way  \r\nPattern p = Pattern.compile(".s");//. represents single character  \r\nMatcher m = p.matcher("as");  \r\nboolean b = m.matches();  \r\n  \r\n//2nd way  \r\nboolean b2=Pattern.compile(".s").matcher("as").matches();  \r\n  \r\n//3rd way  \r\nboolean b3 = Pattern.matches(".s", "as");  \r\n  \r\nSystem.out.println(b+" "+b2+" "+b3);  \r\n}}  ', 5, 2),
(237, 9, 'Regex Character classes', 'No.	Character Class	Description\r\n1	[abc]	a, b, or c (simple class)\r\n2	[^abc]	Any character except a, b, or c (negation)\r\n3	[a-zA-Z]	a through z or A through Z, inclusive (range)\r\n4	[a-d[m-p]]	a through d, or m through p: [a-dm-p] (union)\r\n5	[a-z&&[def]]	d, e, or f (intersection)\r\n6	[a-z&&[^bc]]	a through z, except for b and c: [ad-z] (subtraction)\r\n7	[a-z&&[^m-p]]	a through z, and not m through p: [a-lq-z](subtraction)', 'import java.util.regex.*;  \r\nclass RegexExample3{  \r\npublic static void main(String args[]){  \r\nSystem.out.println(Pattern.matches("[amn]", "abcd"));//false (not a or m or n)  \r\nSystem.out.println(Pattern.matches("[amn]", "a"));//true (among a or m or n)  \r\nSystem.out.println(Pattern.matches("[amn]", "ammmna"));//false (m and a comes more than once)  \r\n}}  ', 5, 2),
(238, 9, 'Regex Quantifiers', 'The quantifiers specify the number of occurrences of a character.\r\n\r\nRegex	Description\r\nX?	X occurs once or not at all\r\nX+	X occurs once or more times\r\nX*	X occurs zero or more times\r\nX{n}	X occurs n times only\r\nX{n,}	X occurs n or more times\r\nX{y,z}	X occurs at least y times but less than z times', 'import java.util.regex.*;  \r\nclass RegexExample4{  \r\npublic static void main(String args[]){  \r\nSystem.out.println("? quantifier ....");  \r\nSystem.out.println(Pattern.matches("[amn]?", "a"));//true (a or m or n comes one time)  \r\nSystem.out.println(Pattern.matches("[amn]?", "aaa"));//false (a comes more than one time)  \r\nSystem.out.println(Pattern.matches("[amn]?", "aammmnn"));//false (a m and n comes more than one time)  \r\nSystem.out.println(Pattern.matches("[amn]?", "aazzta"));//false (a comes more than one time)  \r\nSystem.out.println(Pattern.matches("[amn]?", "am"));//false (a or m or n must come one time)  \r\n  \r\nSystem.out.println("+ quantifier ....");  \r\nSystem.out.println(Pattern.matches("[amn]+", "a"));//true (a or m or n once or more times)  \r\nSystem.out.println(Pattern.matches("[amn]+", "aaa"));//true (a comes more than one time)  \r\nSystem.out.println(Pattern.matches("[amn]+", "aammmnn"));//true (a or m or n comes more than once)  \r\nSystem.out.println(Pattern.matches("[amn]+", "aazzta"));//false (z and t are not matching pattern)  \r\n  \r\nSystem.out.println("* quantifier ....");  \r\nSystem.out.println(Pattern.matches("[amn]*", "ammmna"));//true (a or m or n may come zero or more times)  \r\n  \r\n}}  ', 10, 2),
(239, 9, 'Regex Metacharacters', 'The regular expression metacharacters work as a short codes.\r\n\r\nRegex	Description\r\n.	Any character (may or may not match terminator)\r\n\\d	Any digits, short of [0-9]\r\n\\D	Any non-digit, short for [^0-9]\r\n\\s	Any whitespace character, short for [\\t\\n\\x0B\\f\\r]\r\n\\S	Any non-whitespace character, short for [^\\s]\r\n\\w	Any word character, short for [a-zA-Z_0-9]\r\n\\W	Any non-word character, short for [^\\w]\r\n\\b	A word boundary\r\n\\B	A non word boundary', 'import java.util.regex.*;  \r\nclass RegexExample5{  \r\npublic static void main(String args[]){  \r\nSystem.out.println("metacharacters d....");\\\\d means digit  \r\n  \r\nSystem.out.println(Pattern.matches("\\\\d", "abc"));//false (non-digit)  \r\nSystem.out.println(Pattern.matches("\\\\d", "1"));//true (digit and comes once)  \r\nSystem.out.println(Pattern.matches("\\\\d", "4443"));//false (digit but comes more than once)  \r\nSystem.out.println(Pattern.matches("\\\\d", "323abc"));//false (digit and char)  \r\n  \r\nSystem.out.println("metacharacters D....");\\\\D means non-digit  \r\n  \r\nSystem.out.println(Pattern.matches("\\\\D", "abc"));//false (non-digit but comes more than once)  \r\nSystem.out.println(Pattern.matches("\\\\D", "1"));//false (digit)  \r\nSystem.out.println(Pattern.matches("\\\\D", "4443"));//false (digit)  \r\nSystem.out.println(Pattern.matches("\\\\D", "323abc"));//false (digit and char)  \r\nSystem.out.println(Pattern.matches("\\\\D", "m"));//true (non-digit and comes once)  \r\n  \r\nSystem.out.println("metacharacters D with quantifier....");  \r\nSystem.out.println(Pattern.matches("\\\\D*", "mak"));//true (non-digit and may come 0 or more times)  \r\n  \r\n}}  ', 5, 2),
(240, 5, 'Exception Handling in Java', 'The exception handling in java is one of the powerful mechanism to handle the runtime errors so that normal flow of the application can be maintained.\r\n\r\nIn this page, we will learn about java exception, its type and the difference between checked and unchecked exceptions.\r\n\r\nWhat is exception\r\n\r\nDictionary Meaning: Exception is an abnormal condition.\r\n\r\nIn java, exception is an event that disrupts the normal flow of the program. It is an object which is thrown at runtime.\r\n\r\nWhat is exception handling\r\n\r\nException Handling is a mechanism to handle runtime errors such as ClassNotFound, IO, SQL, Remote etc.', '', 4, 2),
(241, 5, 'Types of Exception', 'There are mainly two types of exceptions: checked and unchecked where error is considered as unchecked exception. The sun microsystem says there are three types of exceptions:\r\n\r\nChecked Exception\r\nUnchecked Exception\r\nError\r\nDifference between checked and unchecked exceptions\r\n\r\n1) Checked Exception\r\n\r\nThe classes that extend Throwable class except RuntimeException and Error are known as checked exceptions e.g.IOException, SQLException etc. Checked exceptions are checked at compile-time.\r\n\r\n2) Unchecked Exception\r\n\r\nThe classes that extend RuntimeException are known as unchecked exceptions e.g. ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException etc. Unchecked exceptions are not checked at compile-time rather they are checked at runtime.\r\n\r\n3) Error\r\n\r\nError is irrecoverable e.g. OutOfMemoryError, VirtualMachineError, AssertionError etc.', '', 5, 2),
(242, 5, 'NullPointerException', 'If we have null value in any variable, performing any operation by the variable occurs an NullPointerException.', 'String s=null;  \r\nSystem.out.println(s.length());//NullPointerException  ', 15, 2),
(243, 9, 'NumberFormatException', 'The wrong formatting of any value, may occur NumberFormatException. Suppose I have a string variable that have characters, converting this variable into digit will occur NumberFormatException.', 'String s="abc";  \r\nint i=Integer.parseInt(s);//NumberFormatException  ', 10, 2),
(244, 67, 'ArrayIndexOutOfBoundsException ', 'If you are inserting any value in the wrong index, it would result ArrayIndexOutOfBoundsException as shown below:', 'int a[]=new int[5];  \r\na[10]=50; //ArrayIndexOutOfBoundsException  ', 10, 2),
(245, 5, 'Exception try catch', 'The first step in constructing an exception handler is to enclose the code that might throw an exception within a try block.', 'try {\r\n    code\r\n}\r\ncatch and finally blocks . . .', 5, 2),
(246, 67, 'Chained Exceptions', 'An application often responds to an exception by throwing another exception. In effect, the first exception causes the second exception. It can be very helpful to know when one exception causes another. Chained Exceptions help the programmer do this.\r\n\r\nThe following are the methods and constructors in Throwable that support chained exceptions.\r\n\r\nThrowable getCause()\r\nThrowable initCause(Throwable)\r\nThrowable(String, Throwable)\r\nThrowable(Throwable)\r\n\r\nThe Throwable argument to initCause and the Throwable constructors is the exception that caused the current exception. getCause returns the exception that caused the current exception, and initCause sets the current exception''s cause.', 'try {\r\n\r\n} catch (IOException e) {\r\n    throw new SampleException("Other IOException", e);\r\n}', 7, 2),
(247, 55, 'Multithreading in Java', 'Multithreading in java is a process of executing multiple threads simultaneously.\r\n\r\nThread is basically a lightweight sub-process, a smallest unit of processing. Multiprocessing and multithreading, both are used to achieve multitasking.\r\n\r\nBut we use multithreading than multiprocessing because threads share a common memory area. They don''t allocate separate memory area so saves memory, and context-switching between the threads takes less time than process.\r\n\r\nJava Multithreading is mostly used in games, animation etc.\r\n\r\nAdvantage of Java Multithreading\r\n\r\n1) It doesn''t block the user because threads are independent and you can perform multiple operations at same time.\r\n\r\n2) You can perform many operations together so it saves time.\r\n\r\n3) Threads are independent so it doesn''t affect other threads if exception occur in a single thread.', '', 5, 2),
(248, 55, 'Thread in java', 'A thread is a lightweight sub process, a smallest unit of processing. It is a separate path of execution.\r\n\r\nThreads are independent, if there occurs exception in one thread, it doesn''t affect other threads. It shares a common memory area.', '', 5, 2),
(249, 67, 'Life cycle of a Thread (Thread States)', 'A thread can be in one of the five states. According to sun, there is only 4 states in thread life cycle in java new, runnable, non-runnable and terminated. There is no running state.\r\n\r\nBut for better understanding the threads, we are explaining it in the 5 states.\r\n\r\nThe life cycle of the thread in java is controlled by JVM. The java thread states are as follows:\r\nNew\r\nRunnable\r\nRunning\r\nNon-Runnable (Blocked)\r\nTerminated', '1) New\r\n\r\nThe thread is in new state if you create an instance of Thread class but before the invocation of start() method.\r\n\r\n2) Runnable\r\n\r\nThe thread is in runnable state after invocation of start() method, but the thread scheduler has not selected it to be the running thread.\r\n\r\n3) Running\r\n\r\nThe thread is in running state if the thread scheduler has selected it.\r\n\r\n4) Non-Runnable (Blocked)\r\n\r\nThis is the state when the thread is still alive, but is currently not eligible to run.\r\n\r\n5) Terminated\r\n\r\nA thread is in terminated or dead state when its run() method exits', 10, 2),
(250, 55, 'Thread creation', 'There are two ways to create a thread:\r\n\r\nBy extending Thread class\r\nBy implementing Runnable interface.\r\n\r\nThread class:\r\n\r\nThread class provide constructors and methods to create and perform operations on a thread.Thread class extends Object class and implements Runnable interface.\r\nCommonly used Constructors of Thread class:\r\n\r\nThread()\r\nThread(String name)\r\nThread(Runnable r)\r\nThread(Runnable r,String name)\r\nCommonly used methods of Thread class:\r\n\r\npublic void run(): is used to perform action for a thread.\r\npublic void start(): starts the execution of the thread.JVM calls the run() method on the thread.\r\npublic void sleep(long miliseconds): Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds.\r\npublic void join(): waits for a thread to die.\r\npublic void join(long miliseconds): waits for a thread to die for the specified miliseconds.\r\npublic int getPriority(): returns the priority of the thread.\r\npublic int setPriority(int priority): changes the priority of the thread.\r\npublic String getName(): returns the name of the thread.\r\npublic void setName(String name): changes the name of the thread.\r\npublic Thread currentThread(): returns the reference of currently executing thread.\r\npublic int getId(): returns the id of the thread.\r\npublic Thread.State getState(): returns the state of the thread.\r\npublic boolean isAlive(): tests if the thread is alive.\r\npublic void yield(): causes the currently executing thread object to temporarily pause and allow other threads to execute.\r\npublic void suspend(): is used to suspend the thread(depricated).\r\npublic void resume(): is used to resume the suspended thread(depricated).\r\npublic void stop(): is used to stop the thread(depricated).\r\npublic boolean isDaemon(): tests if the thread is a daemon thread.\r\npublic void setDaemon(boolean b): marks the thread as daemon or user thread.\r\npublic void interrupt(): interrupts the thread.\r\npublic boolean isInterrupted(): tests if the thread has been interrupted.\r\npublic static boolean interrupted(): tests if the current thread has been interrupted.', 'class Multi extends Thread{  \r\npublic void run(){  \r\nSystem.out.println("thread is running...");  \r\n}  \r\npublic static void main(String args[]){  \r\nMulti t1=new Multi();  \r\nt1.start();  \r\n }  \r\n}', 5, 2),
(251, 67, 'Thread scheduler in java', 'Thread scheduler in java is the part of the JVM that decides which thread should run.\r\n\r\nThere is no guarantee that which runnable thread will be chosen to run by the thread scheduler.\r\n\r\nOnly one thread at a time can run in a single process.\r\n\r\nThe thread scheduler mainly uses preemptive or time slicing scheduling to schedule the threads.', 'Difference between preemptive scheduling and time slicing\r\n\r\nUnder preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence. Under time slicing, a task executes for a predefined slice of time and then reenters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors.', 4, 2),
(252, 9, 'sleep method in java', 'The sleep() method of Thread class is used to sleep a thread for the specified amount of time.\r\n\r\nSyntax of sleep() method in java\r\n\r\nThe Thread class provides two methods for sleeping a thread:\r\n\r\npublic static void sleep(long miliseconds)throws InterruptedException\r\npublic static void sleep(long miliseconds, int nanos)throws InterruptedException', 'class TestSleepMethod1 extends Thread{  \r\n public void run(){  \r\n  for(int i=1;i<5;i++){  \r\n    try{Thread.sleep(500);}catch(InterruptedException e){System.out.println(e);}  \r\n    System.out.println(i);  \r\n  }  \r\n }  \r\n public static void main(String args[]){  \r\n  TestSleepMethod1 t1=new TestSleepMethod1();  \r\n  TestSleepMethod1 t2=new TestSleepMethod1();  \r\n   \r\n  t1.start();  \r\n  t2.start();  \r\n }  \r\n}  ', 10, 2),
(253, 9, 'Can we start a thread twice', 'No. After starting a thread, it can never be started again. If you does so, an IllegalThreadStateException is thrown. In such case, thread will run once but for second time, it will throw exception.\r\n\r\n\\', 'public class TestThreadTwice1 extends Thread{  \r\n public void run(){  \r\n   System.out.println("running...");  \r\n }  \r\n public static void main(String args[]){  \r\n  TestThreadTwice1 t1=new TestThreadTwice1();  \r\n  t1.start();  \r\n  t1.start();  \r\n }  \r\n} ', 15, 2),
(254, 55, 'The join() method:', 'The join() method waits for a thread to die. In other words, it causes the currently running threads to stop executing until the thread it joins with completes its task.\r\nSyntax:\r\n\r\npublic void join()throws InterruptedException\r\npublic void join(long milliseconds)throws InterruptedException\r\n', 'class TestJoinMethod1 extends Thread{  \r\n public void run(){  \r\n  for(int i=1;i<=5;i++){  \r\n   try{  \r\n    Thread.sleep(500);  \r\n   }catch(Exception e){System.out.println(e);}  \r\n  System.out.println(i);  \r\n  }  \r\n }  \r\npublic static void main(String args[]){  \r\n TestJoinMethod1 t1=new TestJoinMethod1();  \r\n TestJoinMethod1 t2=new TestJoinMethod1();  \r\n TestJoinMethod1 t3=new TestJoinMethod1();  \r\n t1.start();  \r\n try{  \r\n  t1.join();  \r\n }catch(Exception e){System.out.println(e);}  \r\n  \r\n t2.start();  \r\n t3.start();  \r\n }  \r\n} ', 5, 2),
(255, 67, 'The currentThread() method', 'The currentThread() method returns a reference to the currently executing thread object.\r\nSyntax:\r\n\r\npublic static Thread currentThread()\r\n', 'class TestJoinMethod4 extends Thread{  \r\n public void run(){  \r\n  System.out.println(Thread.currentThread().getName());  \r\n }  \r\n }  \r\n public static void main(String args[]){  \r\n  TestJoinMethod4 t1=new TestJoinMethod4();  \r\n  TestJoinMethod4 t2=new TestJoinMethod4();  \r\n  \r\n  t1.start();  \r\n  t2.start();  \r\n }  \r\n}', 12, 2),
(256, 7, '\r\nNaming a thread:', 'The Thread class provides methods to change and get the name of a thread.\r\npublic String getName(): is used to return the name of a thread.\r\npublic void setName(String name): is used to change the name of a thread.', 'class TestMultiNaming1 extends Thread{  \r\n  public void run(){  \r\n   System.out.println("running...");  \r\n  }  \r\n public static void main(String args[]){  \r\n  TestMultiNaming1 t1=new TestMultiNaming1();  \r\n  TestMultiNaming1 t2=new TestMultiNaming1();  \r\n  System.out.println("Name of t1:"+t1.getName());  \r\n  System.out.println("Name of t2:"+t2.getName());  \r\n   \r\n  t1.start();  \r\n  t2.start();  \r\n  \r\n  t1.setName("Sonoo Jaiswal");  \r\n  System.out.println("After changing name of t1:"+t1.getName());  \r\n }  \r\n}  ', 5, 2),
(257, 7, 'The currentThread() method', 'The currentThread() method returns a reference to the currently executing thread object.\r\nSyntax of currentThread() method:\r\n\r\npublic static Thread currentThread(): returns the reference of currently running thread.', 'class TestMultiNaming2 extends Thread{  \r\n public void run(){  \r\n  System.out.println(Thread.currentThread().getName());  \r\n }  \r\n }  \r\n public static void main(String args[]){  \r\n  TestMultiNaming2 t1=new TestMultiNaming2();  \r\n  TestMultiNaming2 t2=new TestMultiNaming2();  \r\n  \r\n  t1.start();  \r\n  t2.start();  \r\n }  \r\n} ', 10, 2),
(258, 55, 'Priority of a Thread (Thread Priority):', 'Each thread have a priority. Priorities are represented by a number between 1 and 10. In most cases, thread schedular schedules the threads according to their priority (known as preemptive scheduling). But it is not guaranteed because it depends on JVM specification that which scheduling it chooses.\r\n3 constants defiend in Thread class:\r\n\r\npublic static int MIN_PRIORITY\r\npublic static int NORM_PRIORITY\r\npublic static int MAX_PRIORITY\r\nDefault priority of a thread is 5 (NORM_PRIORITY). The value of MIN_PRIORITY is 1 and the value of MAX_PRIORITY is 10.', 'class TestMultiPriority1 extends Thread{  \r\n public void run(){  \r\n   System.out.println("running thread name is:"+Thread.currentThread().getName());  \r\n   System.out.println("running thread priority is:"+Thread.currentThread().getPriority());  \r\n  \r\n  }  \r\n public static void main(String args[]){  \r\n  TestMultiPriority1 m1=new TestMultiPriority1();  \r\n  TestMultiPriority1 m2=new TestMultiPriority1();  \r\n  m1.setPriority(Thread.MIN_PRIORITY);  \r\n  m2.setPriority(Thread.MAX_PRIORITY);  \r\n  m1.start();  \r\n  m2.start();  \r\n   \r\n }  \r\n} ', 12, 2),
(259, 9, 'Daemon Thread in Java', 'Daemon thread in java is a service provider thread that provides services to the user thread. Its life depend on the mercy of user threads i.e. when all the user threads dies, JVM terminates this thread automatically.\r\n\r\nThere are many java daemon threads running automatically e.g. gc, finalizer etc.\r\n\r\nYou can see all the detail by typing the jconsole in the command prompt. The jconsole tool provides information about the loaded classes, memory usage, running threads etc.\r\n\r\nPoints to remember for Daemon Thread in Java\r\n\r\nIt provides services to user threads for background supporting tasks. It has no role in life than to serve user threads.\r\nIts life depends on user threads.\r\nIt is a low priority thread.', 'public class TestDaemonThread1 extends Thread{  \r\n public void run(){  \r\n  if(Thread.currentThread().isDaemon()){//checking for daemon thread  \r\n   System.out.println("daemon thread work");  \r\n  }  \r\n  else{  \r\n  System.out.println("user thread work");  \r\n }  \r\n }  \r\n public static void main(String[] args){  \r\n  TestDaemonThread1 t1=new TestDaemonThread1();//creating thread  \r\n  TestDaemonThread1 t2=new TestDaemonThread1();  \r\n  TestDaemonThread1 t3=new TestDaemonThread1();  \r\n  \r\n  t1.setDaemon(true);//now t1 is daemon thread  \r\n    \r\n  t1.start();//starting threads  \r\n  t2.start();  \r\n  t3.start();  \r\n }  \r\n}  ', 10, 2),
(260, 67, 'Synchronization in Java', 'Synchronization in java is the capability to control the access of multiple threads to any shared resource.\r\n\r\nJava Synchronization is better option where we want to allow only one thread to access the shared resource.\r\n\r\nWhy use Synchronization\r\n\r\nThe synchronization is mainly used to\r\n\r\nTo prevent thread interference.\r\nTo prevent consistency problem.\r\n', '//example of java synchronized method  \r\nclass Table{  \r\n synchronized void printTable(int n){//synchronized method  \r\n   for(int i=1;i<=5;i++){  \r\n     System.out.println(n*i);  \r\n     try{  \r\n      Thread.sleep(400);  \r\n     }catch(Exception e){System.out.println(e);}  \r\n   }  \r\n  \r\n }  \r\n}  \r\n  \r\nclass MyThread1 extends Thread{  \r\nTable t;  \r\nMyThread1(Table t){  \r\nthis.t=t;  \r\n}  \r\npublic void run(){  \r\nt.printTable(5);  \r\n}  \r\n  \r\n}  \r\nclass MyThread2 extends Thread{  \r\nTable t;  \r\nMyThread2(Table t){  \r\nthis.t=t;  \r\n}  \r\npublic void run(){  \r\nt.printTable(100);  \r\n}  \r\n}  \r\n  \r\npublic class TestSynchronization2{  \r\npublic static void main(String args[]){  \r\nTable obj = new Table();//only one object  \r\nMyThread1 t1=new MyThread1(obj);  \r\nMyThread2 t2=new MyThread2(obj);  \r\nt1.start();  \r\nt2.start();  \r\n}  \r\n}  \r\n', 5, 2),
(261, 82, 'Synchronized block in java', 'Synchronized block can be used to perform synchronization on any specific resource of the method.\r\n\r\nSuppose you have 50 lines of code in your method, but you want to synchronize only 5 lines, you can use synchronized block.\r\n\r\nIf you put all the codes of the method in the synchronized block, it will work same as the synchronized method.\r\n\r\nPoints to remember for Synchronized block\r\n\r\nSynchronized block is used to lock an object for any shared resource.\r\nScope of synchronized block is smaller than the method.', 'class Table{  \r\n  \r\n void printTable(int n){  \r\n   synchronized(this){//synchronized block  \r\n     for(int i=1;i<=5;i++){  \r\n      System.out.println(n*i);  \r\n      try{  \r\n       Thread.sleep(400);  \r\n      }catch(Exception e){System.out.println(e);}  \r\n     }  \r\n   }  \r\n }//end of the method  \r\n}  \r\n  \r\nclass MyThread1 extends Thread{  \r\nTable t;  \r\nMyThread1(Table t){  \r\nthis.t=t;  \r\n}  \r\npublic void run(){  \r\nt.printTable(5);  \r\n}  \r\n  \r\n}  \r\nclass MyThread2 extends Thread{  \r\nTable t;  \r\nMyThread2(Table t){  \r\nthis.t=t;  \r\n}  \r\npublic void run(){  \r\nt.printTable(100);  \r\n}  \r\n}  \r\n  \r\npublic class TestSynchronizedBlock1{  \r\npublic static void main(String args[]){  \r\nTable obj = new Table();//only one object  \r\nMyThread1 t1=new MyThread1(obj);  \r\nMyThread2 t2=new MyThread2(obj);  \r\nt1.start();  \r\nt2.start();  \r\n}  \r\n}', 7, 2),
(262, 82, 'Static synchronization', 'If you make any static method as synchronized, the lock will be on the class not on object.', 'class Table{  \r\n  \r\n synchronized static void printTable(int n){  \r\n   for(int i=1;i<=10;i++){  \r\n     System.out.println(n*i);  \r\n     try{  \r\n       Thread.sleep(400);  \r\n     }catch(Exception e){}  \r\n   }  \r\n }  \r\n}  \r\n  \r\nclass MyThread1 extends Thread{  \r\npublic void run(){  \r\nTable.printTable(1);  \r\n}  \r\n}  \r\n  \r\nclass MyThread2 extends Thread{  \r\npublic void run(){  \r\nTable.printTable(10);  \r\n}  \r\n}  \r\n  \r\nclass MyThread3 extends Thread{  \r\npublic void run(){  \r\nTable.printTable(100);  \r\n}  \r\n}  \r\n  \r\n  \r\n  \r\n  \r\nclass MyThread4 extends Thread{  \r\npublic void run(){  \r\nTable.printTable(1000);  \r\n}  \r\n}  \r\n  \r\npublic class TestSynchronization4{  \r\npublic static void main(String t[]){  \r\nMyThread1 t1=new MyThread1();  \r\nMyThread2 t2=new MyThread2();  \r\nMyThread3 t3=new MyThread3();  \r\nMyThread4 t4=new MyThread4();  \r\nt1.start();  \r\nt2.start();  \r\nt3.start();  \r\nt4.start();  \r\n}  \r\n}  ', 7, 2),
(263, 82, 'FileInputStream and FileOutputStream (File Handling)', 'Java FileOutputStream class\r\n\r\nJava FileOutputStream is an output stream for writing data to a file.\r\n\r\nIf you have to write primitive values then use FileOutputStream.Instead, for character-oriented data, prefer FileWriter.But you can write byte-oriented as well as character-oriented data.', 'import java.io.*;  \r\nclass Test{  \r\n  public static void main(String args[]){  \r\n   try{  \r\n     FileOutputstream fout=new FileOutputStream("abc.txt");  \r\n     String s="Sachin Tendulkar is my favourite player";  \r\n     byte b[]=s.getBytes();//converting string into byte array  \r\n     fout.write(b);  \r\n     fout.close();  \r\n     System.out.println("success...");  \r\n    }catch(Exception e){system.out.println(e);}  \r\n  }  \r\n}  ', 10, 2),
(264, 82, 'Java FileInputStream class', 'Java FileInputStream class obtains input bytes from a file.It is used for reading streams of raw bytes such as image data. For reading streams of characters, consider using FileReader.\r\n\r\nIt should be used to read byte-oriented data for example to read image, audio, video etc.', 'import java.io.*;  \r\nclass SimpleRead{  \r\n public static void main(String args[]){  \r\n  try{  \r\n    FileInputStream fin=new FileInputStream("abc.txt");  \r\n    int i=0;  \r\n    while((i=fin.read())!=-1){  \r\n     System.out.println((char)i);  \r\n    }  \r\n    fin.close();  \r\n  }catch(Exception e){system.out.println(e);}  \r\n }  \r\n} ', 10, 2),
(265, 67, 'Java FileWriter and FileReader (File Handling in java)', 'Java FileWriter and FileReader classes are used to write and read data from text files. These are character-oriented classes, used for file handling in java.\r\n\r\nJava has suggested not to use the FileInputStream and FileOutputStream classes if you have to read and write the textual information.', 'import java.io.*;  \r\nclass Simple{  \r\n public static void main(String args[]){  \r\n  try{  \r\n   FileWriter fw=new FileWriter("abc.txt");  \r\n   fw.write("my name is sachin");  \r\n   fw.close();  \r\n  }catch(Exception e){System.out.println(e);}  \r\n  System.out.println("success");  \r\n }  \r\n}  ', 15, 2),
(266, 67, 'Java FileReader class', 'Java FileReader class is used to read data from the file. It returns data in byte format like FileInputStream class.', 'import java.io.*;  \r\nclass Simple{  \r\n public static void main(String args[])throws Exception{  \r\n  FileReader fr=new FileReader("abc.txt");  \r\n  int i;  \r\n  while((i=fr.read())!=-1)  \r\n  System.out.println((char)i);  \r\n  \r\n  fr.close();  \r\n }  \r\n}  ', 8, 2),
(267, 40, 'COnstructor', 'Constructor is a block of code, which runs when you use new keyword in order to instantiate an object. It looks like a method, however it is not a method. Methods have return type but constructors don’t have any return type.\r\n\r\nHow to call a constructor? The constructor gets called when we create an object of a class (i.e. new keyword followed by class name). For e.g. Demo obj =  new Demo(); (here Demo() is a default constructor of Demo class).\r\n\r\nHow does it look?\r\n\r\nDefault constructor: It is also known as no-arg constructor. Constructor with no arguments is known as default constructor.\r\n\r\nParameterized constructor: Constructor with argument list is known as parameterized constructor.', 'class Demo\r\n{\r\n     public Demo()\r\n     {\r\n         System.out.println("This is a default constructor");\r\n     }\r\n}\r\n\r\n\r\nclass Demo\r\n{\r\n      public Demo(int num, String str)\r\n      {\r\n           System.out.println("This is a parameterized constructor");\r\n      }\r\n}\r\n', 10, 1),
(268, 45, 'If I don’t define the constructor within the class, will compiler declare one for me every time?', 'Answer is: No ', 'class Example3\r\n{\r\n      private int var;\r\n      public Example3(int num)\r\n      {\r\n             var=num;\r\n      }\r\n      public int getValue()\r\n      {\r\n              return var;\r\n      }\r\n      public static void main(String args[])\r\n      {\r\n              Example3 myobj = new Example3();\r\n              System.out.println("value of var is: "+myobj.getValue());\r\n      }\r\n}', 8, 1),
(269, 40, 'Constructor chaining', 'Constructor chaining is nothing but a scenario where in one constructor calls the constructor of its super class implicitly or explicitly. Suppose there is a class which inherits another class, in this case if you create the object of child class then first super class(or parent class) constructor will be invoked and then child class constructor will be invoked.', 'class Human\r\n{\r\n        String s1, s2;\r\n        public Human()\r\n        {\r\n              s1 ="Super class";\r\n              s2 ="Parent class";\r\n        }\r\n        public Human(String str)\r\n        {\r\n               s1= str;\r\n               s2= str;\r\n        }\r\n}\r\nclass Boy extends Human\r\n{\r\n        public Boy()\r\n        {\r\n              s2 ="Child class";\r\n        }\r\n        public void disp()\r\n        {\r\n               System.out.println("String 1 is: "+s1);\r\n               System.out.println("String 2 is: "+s2);\r\n        }\r\n        public static void main(String args[])\r\n        {\r\n                Boy obj = new Boy();\r\n                obj.disp();\r\n        }\r\n}', 11, 1),
(270, 45, 'constructor overloading', 'Like methods, constructors can also be overloaded. We will see constructor overloading with the help of an example using this() and parameterized constructor. Before we got through the source code and examples lets discuss why we need to overload a constructor:\r\n\r\nConstructor overloading is way of having more than one constructor which does different-2 tasks. For e.g. Vector class has 4 types of constructors. If you do not want to specify the initial capacity and capacity increment then you can simply use default constructor of Vector class like this Vector v = new Vector(); however if you need to specify the capacity and increment then you call the parameterized constructor with two int args like this: Vector v= new Vector(10, 5);\r\n\r\nYou must have understood the need to overloading. Lets see how to overload a constructor with the help of below example program:', 'package beginnersbook.com;\r\npublic class StudentData\r\n{\r\n   private int stuID;\r\n   private String stuName;\r\n   private int stuAge;\r\n   StudentData()\r\n   {\r\n       //Default constructor\r\n       stuID = 100;\r\n       stuName = "New Student";\r\n       stuAge = 18;\r\n   }\r\n   StudentData(int num1, String str, int num2)\r\n   {\r\n       //Parameterized constructor\r\n       stuID = num1;\r\n       stuName = str;\r\n       stuAge = num2;\r\n   }\r\n   //Getter and setter methods\r\n   public int getStuID() {\r\n       return stuID;\r\n   }\r\n   public void setStuID(int stuID) {\r\n       this.stuID = stuID;\r\n   }\r\n   public String getStuName() {\r\n       return stuName;\r\n   }\r\n   public void setStuName(String stuName) {\r\n       this.stuName = stuName;\r\n   }\r\n   public int getStuAge() {\r\n       return stuAge;\r\n   }\r\n   public void setStuAge(int stuAge) {\r\n       this.stuAge = stuAge;\r\n   }\r\n}\r\n\r\nclass TestOverloading\r\n{\r\n   public static void main(String args[])\r\n   {\r\n       //This object creation would call the default constructor\r\n       StudentData myobj = new StudentData();\r\n       System.out.println("Student Name is: "+myobj.getStuName());\r\n       System.out.println("Student Age is: "+myobj.getStuAge());\r\n       System.out.println("Student ID is: "+myobj.getStuID());\r\n\r\n       /*This object creation would call the parameterized\r\n        * constructor StudentData(int, String, int)*/\r\n       StudentData myobj2 = new StudentData(555, "Chaitanya", 25);\r\n       System.out.println("Student Name is: "+myobj2.getStuName());\r\n       System.out.println("Student Age is: "+myobj2.getStuAge());\r\n       System.out.println("Student ID is: "+myobj2.getStuID()); \r\n  }\r\n}', 8, 1),
(271, 40, 'private constructor', 'The use of private constructor is to serve singleton classes. A singleton class is one which limits the number of objects creation to one. Using private constructor we can ensure that no more than one object can be created at a time. We will see in the below example how to use private constructor for limiting the number of objects for a singleton class.', 'package beginnersbook.com;\r\npublic class SingleTonClass {\r\n   //Static Class Reference\r\n   private static SingleTonClass obj=null;\r\n   private SingleTonClass(){\r\n      /*Private Constructor will prevent \r\n       * the instantiation of this class directly*/\r\n   }\r\n   public static SingleTonClass objectCreationMethod(){\r\n	/*This logic will ensure that no more than\r\n	 * one object can be created at a time */\r\n	if(obj==null){\r\n	    obj= new SingleTonClass();\r\n	}\r\n        return obj;\r\n   }\r\n   public void display(){\r\n	System.out.println("Singleton class Example");\r\n   }\r\n   public static void main(String args[]){\r\n	//Object cannot be created directly due to private constructor \r\n        //This way it is forced to create object via our method where\r\n        //we have logic for only one object creation\r\n	SingleTonClass myobject= SingleTonClass.objectCreationMethod();\r\n	myobject.display();\r\n   }\r\n}', 5, 1),
(272, 45, 'constructor in interface', 'This is a most frequently asked java interview question. The answer is No, interface cannot have constructors. In this post we will discuss why constructors are not allowed in interface?\r\n\r\nAs we know that all the methods in interface are public abstract by default which means the method implementation cannot be provided in the interface itself. It has to be provided by the implementing class. Consider the below piece of code:', 'public interface SumInterface{\r\n\r\n    public int mymethod(int num1, int num2);\r\n}\r\npublic class SumClass implements SumInterface{\r\n\r\n    public int mymethod(int num1, int num2){\r\n           int op= num1+num2;\r\n           return op;\r\n    }\r\n    public static void main(Sring args[])\r\n    {\r\n           SumClass obj= new SumClass();\r\n           System.out.println(obj.mymethod(2, 3));\r\n}', 6, 1),
(273, 40, 'What is polymorphism', 'Polymorphism is the capability of a method to do different things based on the object that it is acting upon. In other words, polymorphism allows you define one interface and have multiple implementations. I know it sounds confusing. Don’t worry we will discuss this in detail.\r\n\r\nIt is a  feature that allows one interface to be used for a general class of  actions.\r\nAn operation may exhibit different behavior in different instances.\r\nThe behavior depends on the types of data used in the operation.\r\nIt plays an important role in allowing objects having different internal structures to share the same external interface.\r\nPolymorphism is extensively used in implementing inheritance.\r\nFollowing concepts demonstrate different types of polymorphism in java.\r\n1) Method Overloading\r\n2) Method Overriding', '', 5, 1),
(274, 45, 'method overloading', 'To call an overloaded method in Java, it is must to use the type and/or number of arguments to determine which version of the overloaded method to actually call.\r\nOverloaded methods may have different return types; the return type alone is insufficient to distinguish two versions of a method. .\r\nWhen Java encounters a call to an overloaded method, it simply executes the version of the method whose parameters match the arguments used in the call.\r\nIt allows the user to achieve compile time polymorphism.\r\nAn overloaded method can throw different exceptions.\r\nIt can have different access modifiers.', 'class Overload\r\n{\r\n    void demo (int a)\r\n    {\r\n       System.out.println ("a: " + a);\r\n    }\r\n    void demo (int a, int b)\r\n    {\r\n       System.out.println ("a and b: " + a + "," + b);\r\n    }\r\n    double demo(double a) {\r\n       System.out.println("double a: " + a);\r\n       return a*a;\r\n    }\r\n}\r\nclass MethodOverloading\r\n{\r\n    public static void main (String args [])\r\n    {\r\n        Overload Obj = new Overload();\r\n        double result;\r\n        Obj .demo(10);\r\n        Obj .demo(10, 20);\r\n        result = Obj .demo(5.5);\r\n        System.out.println("O/P : " + result);\r\n    }\r\n}', 12, 1),
(275, 45, 'method overriding', 'Child class has the same method as of base class. In such cases child class overrides the parent class method without even touching the source code of the base class. This feature is known as method overriding.', 'ublic class BaseClass\r\n{\r\n    public void methodToOverride() //Base class method\r\n    {\r\n         System.out.println ("I''m the method of BaseClass");\r\n    }\r\n}\r\npublic class DerivedClass extends BaseClass\r\n{\r\n    public void methodToOverride() //Derived Class method\r\n    {\r\n         System.out.println ("I''m the method of DerivedClass");\r\n    }\r\n}\r\n\r\npublic class TestMethod\r\n{\r\n     public static void main (String args []) {\r\n        // BaseClass reference and object\r\n        BaseClass obj1 = new BaseClass(); \r\n        // BaseClass reference but DerivedClass object\r\n        BaseClass obj2 = new DerivedClass(); \r\n        // Calls the method from BaseClass class\r\n        obj1.methodToOverride(); \r\n        //Calls the method from DerivedClass class\r\n        obj2.methodToOverride(); \r\n     }\r\n}', 6, 1),
(276, 40, 'Method Overloading', 'Method Overloading is a feature that allows a class to have two or more methods having same name, if their argument lists are different. In the last tutorial we discussed constructor overloading that allows a class to have more than one constructors having different argument lists.\r\n\r\nArgument lists could differ in –\r\n1. Number of parameters.\r\n2. Data type of parameters.\r\n3. Sequence of Data type of parameters.\r\n\r\nMethod overloading is also known as Static Polymorphism.\r\n\r\nPoints to Note:\r\n1. Static Polymorphism is also known as compile time binding or early binding.\r\n2. Static binding happens at compile time. Method overloading is an example of static binding where binding of method call to its definition happens at Compile time.', 'class DisplayOverloading\r\n{\r\n    public void disp(char c)\r\n    {\r\n         System.out.println(c);\r\n    }\r\n    public void disp(char c, int num)  \r\n    {\r\n         System.out.println(c + " "+num);\r\n    }\r\n}\r\nclass Sample\r\n{\r\n   public static void main(String args[])\r\n   {\r\n       DisplayOverloading obj = new DisplayOverloading();\r\n       obj.disp(''a'');\r\n       obj.disp(''a'',10);\r\n   }\r\n}', 9, 1);
INSERT INTO `notessal` (`notesid`, `uid`, `topic`, `content`, `code`, `likes`, `nlevel`) VALUES
(277, 40, 'method overriding', 'Declaring a method in subclass which is already present in parent class is known as method overriding. Earlier we shared method overloading in java. In this tutorial we will see method overriding with examples.\r\n\r\nExample:\r\n\r\nOne of the simplest example – Here Boy class extends Human class. Both the classes have a common method void eat(). Boy class is giving its own implementation to the eat() method or in other words it is overriding the method eat()', 'class Human{\r\n   public void eat()\r\n   {\r\n      System.out.println("Human is eating");\r\n   }\r\n}\r\nclass Boy extends Human{\r\n   public void eat(){\r\n      System.out.println("Boy is eating");\r\n   }\r\n   public static void main( String args[]) {\r\n      Boy obj = new Boy();\r\n      obj.eat();\r\n   }\r\n}', 7, 1),
(278, 32, 'OBJECT SERIALIZATION', 'Java object serialization is used to persist Java objects to a file, database, network, process or any other system. Serialization flattens objects into an ordered, or serialized stream of bytes. The ordered stream of bytes can then be read at a later time, or in another environment, to recreate the original objects.\r\n\r\nJava serialization does not cannot occur for transient or static fields. Marking the field transient prevents the state from being written to the stream and from being restored during deserialization. Java provides classes to support writing objects to streams and restoring objects from streams. Only objects that support the java.io.Serializable interface or the java.io.Externalizable interface can be written to streams.\r\npublic interface Serializable\r\n\r\nThe Serializable interface has no methods or fields. (Marker Interface)\r\nOnly objects of classes that implement java.io.Serializable interface can be serialized or deserialized', 'import java.io.Serializable;\r\npublic class PersonDetails implements Serializable {\r\n\r\n	private String name;\r\n	private int age;\r\n	private String sex;\r\n	public PersonDetails(String name, int age, String sex) {\r\n		this.name = name;\r\n		this.age = age;\r\n		this.sex = sex;\r\n	}\r\n	public int getAge() {\r\n		return age;\r\n	}\r\n	public void setAge(int age) {\r\n		this.age = age;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public String getSex() {\r\n		return sex;\r\n	}\r\n	public void setSex(String sex) {\r\n		this.sex = sex;\r\n	}\r\n}', 15, 1),
(279, 32, 'Java Object Typecasting', 'java object typecasting one object reference can be type cast into another object reference. The cast can be to its own class type or to one of its subclass or superclass types or interfaces. There are compile-time rules and runtime rules for casting in java.\r\n\r\nTypecast Objects with a dynamically loaded Class ? – The casting of object references depends on the relationship of the classes involved in the same hierarchy. Any object reference can be assigned to a reference variable of the type Object, because the Object class is a superclass of every Java class.\r\nThere can be 2 casting java scenarios\r\n\r\n· Upcasting\r\n· Downcasting', '//X is a supper class of Y and Z which are sibblings.\r\npublic class RunTimeCastDemo {\r\n\r\n	public static void main(String args[]) {\r\n		X x = new X();\r\n		Y y = new Y();\r\n		Z z = new Z();\r\n		X xy = new Y(); // compiles ok (up the hierarchy)\r\n		X xz = new Z(); // compiles ok (up the hierarchy)\r\n		//		Y yz = new Z();   incompatible type (siblings)\r\n		//		Y y1 = new X();   X is not a Y\r\n		//		Z z1 = new X();   X is not a Z\r\n		X x1 = y; // compiles ok (y is subclass of X)\r\n		X x2 = z; // compiles ok (z is subclass of X)\r\n		Y y1 = (Y) x; // compiles ok but produces runtime error\r\n		Z z1 = (Z) x; // compiles ok but produces runtime error\r\n		Y y2 = (Y) x1; // compiles and runs ok (x1 is type Y)\r\n		Z z2 = (Z) x2; // compiles and runs ok (x2 is type Z)\r\n		//		Y y3 = (Y) z;     inconvertible types (siblings)\r\n		//		Z z3 = (Z) y;     inconvertible types (siblings)\r\n		Object o = z;\r\n		Object o1 = (Y) o; // compiles ok but produces runtime error\r\n	}\r\n}', 15, 1),
(280, 32, 'implicit typecasting', 'In general an implicit cast is done when an Object reference is assigned (cast) to:\r\n\r\n* A reference variable whose type is the same as the class from which the object was instantiated.\r\nAn Object as Object is a super class of every Class.\r\n* A reference variable whose type is a super class of the class from which the object was instantiated.\r\n* A reference variable whose type is an interface that is implemented by the class from which the object was instantiated.\r\n* A reference variable whose type is an interface that is implemented by a super class of the class from which the object was instantiated.\r\n\r\nConsider an interface Vehicle, a super class Car and its subclass Ford. The following example shows the automatic conversion of object references handled by the compiler', 'interface Vehicle {\r\n}\r\nclass Car implements Vehicle {\r\n}class Ford extends Car {\r\n', 12, 1),
(281, 32, 'instanceof operator', 'The instanceof operator is called the type comparison operator, lets you determine if an object belongs to a specific class, or implements a specific interface. It returns true if an object is an instance of the class or if the object implements the interface, otherwise it returns false.', 'class Vehicle {\r\n\r\n	String name;\r\n	Vehicle() {\r\n		name = "Vehicle";\r\n	}\r\n}\r\n\r\nclass HeavyVehicle extends Vehicle {\r\n\r\n	HeavyVehicle() {\r\n		name = "HeavyVehicle";\r\n	}\r\n}\r\n\r\nclass Truck extends HeavyVehicle {\r\n\r\n	Truck() {\r\n		name = "Truck";\r\n	}\r\n}\r\n\r\nclass LightVehicle extends Vehicle {\r\n\r\n	LightVehicle() {\r\n		name = "LightVehicle";\r\n	}\r\n}\r\n\r\npublic class InstanceOfExample {\r\n\r\n	static boolean result;\r\n	static HeavyVehicle hV = new HeavyVehicle();\r\n	static Truck T = new Truck();\r\n	static HeavyVehicle hv2 = null;\r\n	public static void main(String[] args) {\r\n		result = hV instanceof HeavyVehicle;\r\n		System.out.print("hV is an HeavyVehicle: " + result + "\\n");\r\n		result = T instanceof HeavyVehicle;\r\n		System.out.print("T is an HeavyVehicle: " + result + "\\n");\r\n		result = hV instanceof Truck;\r\n		System.out.print("hV is a Truck: " + result + "\\n");\r\n		result = hv2 instanceof HeavyVehicle;\r\n		System.out.print("hv2 is an HeavyVehicle: " + result + "\\n");\r\n		hV = T; //Sucessful Cast form child to parent\r\n		T = (Truck) hV; //Sucessful Explicit Cast form parent to child\r\n	}\r\n}', 8, 1),
(282, 32, 'Abstract class', 'Java Abstract classes are used to declare common characteristics of subclasses. An abstract class cannot be instantiated. It can only be used as a superclass for other classes that extend the abstract class. Abstract classes are declared with the abstract keyword. Abstract classes are used to provide a template or design for concrete subclasses down the inheritance tree.\r\n\r\nLike any other class, an abstract class can contain fields that describe the characteristics and methods that describe the actions that a class can perform. An abstract class can include methods that contain no implementation. These are called abstract methods. The abstract method declaration must then end with a semicolon rather than a block. If a class has any abstract methods, whether declared or inherited, the entire class must be declared abstract. Abstract methods are used to provide a template for the classes that inherit the abstract methods.\r\n\r\nAbstract classes cannot be instantiated; they must be subclassed, and actual implementations must be provided for the abstract methods. Any implementation specified can, of course, be overridden by additional subclasses. An object must have an implementation for all of its methods. You need to create a subclass that provides an implementation for the abstract method.\r\n\r\nA class abstract Vehicle might be specified as abstract to represent the general abstraction of a vehicle, as creating instances of the class would not be meaningful.', 'abstract class Vehicle {\r\n\r\n	int numofGears;\r\n	String color;\r\n	abstract boolean hasDiskBrake();\r\n	abstract int getNoofGears();\r\n}\r\n\r\nabstract class Shape {\r\n\r\n	public String color;\r\n	public Shape() {\r\n	}\r\n	public void setColor(String c) {\r\n		color = c;\r\n	}\r\n	public String getColor() {\r\n		return color;\r\n	}\r\n	abstract public double area();\r\n}', 10, 1),
(283, 32, 'interface', 'In Java, this multiple inheritance problem is solved with a powerful construct called interfaces. Interface can be used to define a generic template and then one or more abstract classes to define partial implementations of the interface. Interfaces just specify the method declaration (implicitly public and abstract) and can only contain fields (which are implicitly public static final). Interface definition begins with a keyword interface. An interface like that of an abstract class cannot be instantiated.\r\n\r\nMultiple Inheritance is allowed when extending interfaces i.e. one interface can extend none, one or more interfaces. Java does not support multiple inheritance, but it allows you to extend one class and implement many interfaces.\r\n\r\nIf a class that implements an interface does not define all the methods of the interface, then it must be declared abstract and the method definitions must be provided by the subclass that extends the abstract class.', 'interface Shape {\r\n\r\n	public double area();\r\n	public double volume();\r\n}\r\n\r\npublic class Point implements Shape {\r\n\r\n	static int x, y;\r\n	public Point() {\r\n		x = 0;\r\n		y = 0;\r\n	}\r\n	public double area() {\r\n		return 0;\r\n	}\r\n	public double volume() {\r\n		return 0;\r\n	}\r\n	public static void print() {\r\n		System.out.println("point: " + x + "," + y);\r\n	}\r\n	public static void main(String args[]) {\r\n		Point p = new Point();\r\n		p.print();\r\n	}\r\n}', 20, 1),
(284, 39, 'static binding', 'Association of method definition to the method call is known as binding. There are two types of binding: Static binding and dynamic binding. Lets discuss them one by one.\r\n\r\nStatic Binding or Early Binding\r\n\r\nThe binding which can be resolved at compile time by compiler is known as static or early binding. All the static, private and final methods have always been bonded at compile-time . Why binding of Static, final and private methods is always a static binding? You would understand it better after reading dynamic binding. Still let me explain this – Compiler knows that all such methods cannot be overridden and will always be accessed by object of local class. Hence compiler doesn’t have any difficulty to determine object of class (local class for sure). That’s the reason binding for such methods is static.', 'class Human{\r\n....\r\n}\r\nclass Boy extends Human{\r\n   public void walk(){\r\n      System.out.println("Boy walks");\r\n   }\r\n   public static void main( String args[]) {\r\n      Boy obj1 = new Boy();\r\n      obj1.walk();\r\n   }\r\n}', 10, 1),
(285, 39, 'Dynamic binding', 'When compiler is not able to resolve the call/binding at compile time, such binding is known as Dynamic or late Binding. Overriding is a perfect example of dynamic binding as in overriding both parent and child classes have same method. Thus while calling the overridden method, the compiler gets confused between parent and child class method(since both the methods have same name).', 'package beginnersbook.com;\r\nclass Human{\r\n   public void walk()\r\n   {\r\n       System.out.println("Human walks");\r\n   }\r\n}\r\nclass Boy extends Human{\r\n   public void walk(){\r\n       System.out.println("Boy walks");\r\n   }\r\n   public static void main( String args[]) {\r\n       //Reference is of parent class\r\n       Human myobj = new Boy();\r\n       myobj.walk();\r\n   }\r\n}', 10, 1),
(286, 39, 'encapsulation', 'The whole idea behind encapsulation is to hide the implementation details from users. If a data member is private it means it can only be accessed within the same class. No outside class can access private data member (variable) of other class. However if we setup public getter and setter methods to update (for e.g. void setSSN(int ssn))and read (for e.g.  int getSSN()) the private data fields then the outside class can access those private data fields via public methods. This way data can only be accessed by public methods thus making the private fields and their implementation hidden for outside classes. That’s why encapsulation is known as data hiding. Lets see an example to understand this concept better.', 'public class EncapsulationDemo{\r\n    private int ssn;\r\n    private String empName;\r\n    private int empAge;\r\n\r\n    //Getter and Setter methods\r\n    public int getEmpSSN(){\r\n        return ssn;\r\n    }\r\n\r\n    public String getEmpName(){\r\n        return empName;\r\n    }\r\n\r\n    public int getEmpAge(){\r\n        return empAge;\r\n    }\r\n\r\n    public void setEmpAge(int newValue){\r\n        empAge = newValue;\r\n    }\r\n\r\n    public void setEmpName(String newValue){\r\n        empName = newValue;\r\n    }\r\n\r\n    public void setEmpSSN(int newValue){\r\n        ssn = newValue;\r\n    }\r\n}\r\npublic class EncapsTest{\r\n    public static void main(String args[]){\r\n         EncapsulationDemo obj = new EncapsulationDemo();\r\n         obj.setEmpName("Mario");\r\n         obj.setEmpAge(32);\r\n         obj.setEmpSSN(112233);\r\n         System.out.println("Employee Name: " + obj.getEmpName());\r\n         System.out.println("Employee SSN: " + obj.getEmpSSN());\r\n         System.out.println("Employee Age: " + obj.getEmpAge());\r\n    } \r\n}', 10, 1),
(287, 39, 'interface', 'Interface looks like class but it is not a class. An interface can have methods and variables just like the class but the methods declared in interface are by default abstract (only method signature, no body). Also, the variables declared in an interface are public, static & final by default. We will discuss these points in detail, later in this post.', 'interface MyInterface\r\n{\r\n   public void method1();\r\n   public void method2();\r\n}\r\nclass XYZ implements MyInterface\r\n{\r\n  public void method1()\r\n  {\r\n      System.out.println("implementation of method1");\r\n  }\r\n  public void method2()\r\n  {\r\n      System.out.println("implementation of method2");\r\n  }\r\n  public static void main(String arg[])\r\n  {\r\n      MyInterface obj = new XYZ();\r\n      obj. method1();\r\n  }\r\n}', 15, 1),
(288, 39, 'abstract class and methods', 'A class that is declared using “abstract” keyword is known as abstract class. It may or may not include abstract methods which means in abstract class you can have concrete methods (methods with body) as well along with abstract methods ( without an implementation, without braces, and followed by a semicolon). An abstract class can not be instantiated (you are not allowed to create object of Abstract class).', '/ Declaration using abstract keyword\r\nabstract class AbstractDemo{\r\n   // Concrete method: body and braces\r\n   public void myMethod(){\r\n      //Statements here\r\n   }\r\n\r\n   // Abstract method: without body and braces \r\n   abstract public void anotherMethod();\r\n}', 10, 1),
(289, 39, 'polymorphism', 'Polymorphism is the capability of a method to do different things based on the object that it is acting upon. In other words, polymorphism allows you define one interface and have multiple implementations. I know it sounds confusing. Don’t worry we will discuss this in detail.\r\n\r\nIt is a  feature that allows one interface to be used for a general class of  actions.\r\nAn operation may exhibit different behavior in different instances.\r\nThe behavior depends on the types of data used in the operation.\r\nIt plays an important role in allowing objects having different internal structures to share the same external interface.\r\nPolymorphism is extensively used in implementing inheritance.\r\nFollowing concepts demonstrate different types of polymorphism in java.\r\n1) Method Overloading\r\n2) Method Overriding', '', 5, 1),
(290, 100, 'super keyword', 'When invoking a superclass version of an overridden method the super keyword is used.', 'class Vehicle {\r\n    public void move () {\r\n         System.out.println ("Vehicles are used for moving from one place to another ");\r\n    }\r\n}\r\n\r\nclass Car extends Vehicle {\r\n    public void move () {\r\n      super. move (); // invokes the super class method\r\n      System.out.println ("Car is a good medium of transport ");\r\n    }\r\n}\r\n\r\npublic class TestCar {\r\n    public static void main (String args []){\r\n        Vehicle b = new Car (); // Vehicle reference but Car object\r\n        b.move (); //Calls the method in Car class\r\n    }\r\n}', 10, 1),
(291, 100, 'final keyword', 'final keyword can be used along with variables, methods and classes. We will cover following topics in detail.\r\n\r\n1) final variable\r\n2) final method\r\n3) final class\r\n\r\n1) final variable\r\n\r\nfinal variables are nothing but constants. We cannot change the value of a final variable once it is initialized. \r\n\r\n2) final method\r\n\r\nA final method cannot be overridden. Which means even though a sub class can call the final method of parent class without any issues but it cannot override it.', '1) final variable\r\nclass Demo{  \r\n\r\n   final int MAX_VALUE=99;\r\n   void myMethod(){  \r\n      MAX_VALUE=101;\r\n   }  \r\n   public static void main(String args[]){  \r\n      Demo obj=new  Demo();  \r\n      obj.myMethod();  \r\n   }  \r\n}\r\n\r\n2) final method\r\nclass XYZ{  \r\n   final void demo(){\r\n      System.out.println("XYZ Class Method");\r\n   }  \r\n}  \r\n	     \r\nclass ABC extends XYZ{  \r\n   void demo(){\r\n      System.out.println("ABC Class Method");\r\n   }  \r\n	     \r\n   public static void main(String args[]){  \r\n      ABC obj= new ABC();  \r\n      obj.demo();  \r\n   }  \r\n}\r\n', 10, 1),
(292, 100, 'packages', 'Packages in Java is a mechanism to encapsulate a group of classes, interfaces and sub packages. Many implementations of Java use a hierarchical file system to manage source and class files. It is easy to organize class files into packages. All we need to do is put related class files in the same directory, give the directory a name that relates to the purpose of the classes, and add a line to the top of each class file that declares the package name, which is the same as the directory name where they reside.\r\n\r\nIn java there are already many predefined packages that we use while programming.\r\n\r\nFor example: java.lang, java.io, java.util etc.\r\nHowever one of the most useful feature of java is that we can define our own packages', '', 8, 1),
(293, 65, 'declare array', 'To use an array in a program, you must declare a variable to reference the array, and you must specify the type of array the variable can reference. Here is the syntax for declaring an array variable:\r\n\r\ndataType[] arrayRefVar;   // preferred way.\r\n\r\nor\r\n\r\ndataType arrayRefVar[];  //  works but not preferred way.', '', 12, 0),
(294, 65, 'do while loop', 'Like a while statement, except that it tests the condition at the end of the loop body', 'do\r\n{\r\n   //Statements\r\n}while(Boolean_expression);', 12, 0),
(295, 67, 'FileInputStream  ', 'Java byte streams are used to perform input and output of 8-bit bytes. Though there are many classes related to byte streams but the most frequently used classes are , FileInputStream and FileOutputStream. ', 'Following is an example which makes use of these two classes to copy an input file into an output file:\r\n\r\nimport java.io.*;\r\n\r\npublic class CopyFile {\r\n   public static void main(String args[]) throws IOException\r\n   {\r\n      FileInputStream in = null;\r\n      FileOutputStream out = null;\r\n\r\n      try {\r\n         in = new FileInputStream("input.txt");\r\n         out = new FileOutputStream("output.txt");\r\n         \r\n         int c;\r\n         while ((c = in.read()) != -1) {\r\n            out.write(c);\r\n         }\r\n      }finally {\r\n         if (in != null) {\r\n            in.close();\r\n         }\r\n         if (out != null) {\r\n            out.close();\r\n         }\r\n      }\r\n   }\r\n}', 12, 2),
(296, 67, 'try catch', 'A try statement is used to catch exceptions that might be thrown as your program executes. You should use a try statement whenever you use a statement that might throw an exception That way, your program won’t crash if the exception occurs.', 'try\r\n{\r\n    statements that can throw exceptions\r\n}\r\ncatch (exception-type identifier)\r\n{\r\n    statements executed when exception is thrown\r\n}\r\nfinally\r\n{\r\n    statements that are executed whether or not\r\n    exceptions occur', 12, 2),
(297, 103, 'Types of exception, good for debugging', 'ArithmeticException	You are trying to use your computer to solve a mathematical problem that you cannot solve yourself. Read up on your arithmetics and try again.\r\n\r\nArrayIndexOutOfBoundsException	See IndexOutOfBoundsException. The difference is that this exception refers to more than one finger.\r\n\r\nClassNotFoundException	You seem to have invented your own class\r\n\r\nNumberFormatException	You are using outdated units of measurement, for example inches or pints. Convert to SI. There is a known bug that causes this exception to be thrown if you are very short or tall.', '', 15, 2),
(298, 79, 'static and dynamic binding\r\n', 'Association of method definition to the method call is known as binding. There are two types of binding: Static binding and dynamic binding. Lets discuss them one by one.\r\n\r\nStatic: The binding which can be resolved at compile time by compiler is known as static or early binding. \r\n\r\ndynamic:When compiler is not able to resolve the call/binding at compile time, such binding is known as Dynamic or late Binding. Overriding is a perfect example of dynamic binding as in overriding both parent and child classes have same method.\r\n', '', 12, 1),
(299, 103, 'Aggregation', 'Aggregation is a special form of association. It is also a relationship between two classes like association, however its a directional association, which means it is strictly a one way association. It represents a Has-A relationship.', 'public class Subject {    private String name;    public void setName(String name)   {     this.name = name;   }    public String getName()   {     return name;   } }  public class Student {    private Subject[] studyAreas = new Subject[10];    //the rest of the Student class }', 20, 2),
(300, 234, 'arraylist and vector difference', '1) Synchronization: ArrayList is non-synchronized which means multiple threads can work on ArrayList at the same time. For e.g. if one thread is performing an add operation on ArrayList, there can be an another thread performing remove operation on ArrayList at the same time in a multithreaded environment\r\n\r\nwhile Vector is synchronized. This means if one thread is working on Vector, no other thread can get a hold of it. Unlike ArrayList, only one thread can perform an operation on vector at a time.\r\n\r\n2) Resize: Both ArrayList and Vector can grow and shrink dynamically to maintain the optimal use of storage, however the way they resized is different. ArrayList grow by half of its size when resized while Vector doubles the size of itself by default when grows.\r\n\r\n3) Performance: ArrayList gives better performance as it is non-synchronized. Vector operations gives poor performance as they are thread-safe, the thread which works on Vector gets a lock on it which makes other thread wait till the lock is released.\r\n\r\n4) fail-fast: First let me explain what is fail-fast: If the collection (ArrayList, vector etc) gets structurally modified by any means, except the add or remove methods of iterator, after creation of iterator then the iterator will throw ConcurrentModificationException. Structural modification refers to the addition or deletion of elements from the collection.', '', 12, 1),
(301, 234, 'sort a hashmap', 'We can ignore the generic type and make the methods work for any types like the following.', 'import java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.TreeMap;\r\n \r\npublic class Solution {\r\n	public static void main(String[] args) {\r\n		HashMap<String, Integer> map = new HashMap<String, Integer>();\r\n		map.put("a", 10);\r\n		map.put("b", 30);\r\n		map.put("c", 50);\r\n		map.put("d", 40);\r\n		map.put("e", 20);\r\n		System.out.println(map);\r\n \r\n		Map sortedMap = sortByValue(map);\r\n		System.out.println(sortedMap);\r\n	}\r\n \r\n	public static Map sortByValue(Map unsortedMap) {\r\n		Map sortedMap = new TreeMap(new ValueComparator(unsortedMap));\r\n		sortedMap.putAll(unsortedMap);\r\n		return sortedMap;\r\n	}\r\n \r\n}\r\n \r\nclass ValueComparator implements Comparator {\r\n	Map map;\r\n \r\n	public ValueComparator(Map map) {\r\n		this.map = map;\r\n	}\r\n \r\n	public int compare(Object keyA, Object keyB) {\r\n		Comparable valueA = (Comparable) map.get(keyA);\r\n		Comparable valueB = (Comparable) map.get(keyB);\r\n		return valueB.compareTo(valueA);\r\n	}\r\n}', 12, 2),
(302, 23, ' Constructors for Your Classes', 'A class contains constructors that are invoked to create objects from the class blueprint. Constructor declarations look like method declarations—except that they use the name of the class and have no return type. For example, Bicycle has one constructor:', 'public Bicycle(int startCadence, int startSpeed, int startGear) {\r\n    gear = startGear;\r\n    cadence = startCadence;\r\n    speed = startSpeed;\r\n}', 10, 1),
(303, 23, 'Passing information to constructor', 'The declaration for a method or a constructor declares the number and the type of the arguments for that method or constructor. For example, the following is a method that computes the monthly payments for a home loan, based on the amount of the loan, the interest rate, the length of the loan (the number of periods), and the future value of the loan', 'public double computePayment(\r\n                  double loanAmt,\r\n                  double rate,\r\n                  double futureValue,\r\n                  int numPeriods) {\r\n    double interest = rate / 100.0;\r\n    double partial1 = Math.pow((1 + interest), \r\n                    - numPeriods);\r\n    double denominator = (1 - partial1) / interest;\r\n    double answer = (-loanAmt / denominator)\r\n                    - ((futureValue * partial1) / denominator);\r\n    return answer;\r\n}', 15, 1),
(304, 23, 'Protected access modifiers', 'The protected access modifier provides the same access as the default access modifier, with the addition that subclasses can access protected methods and member variables (fields) of the superclass. This is true even if the subclass is not located in the same package as the superclass', 'public class Clock {\r\n    protected long time = 0;    // time in milliseconds\r\n}\r\n\r\n\r\npublic class SmartClock() extends Clock{\r\n\r\n    public long getTimeInSeconds() {\r\n        return this.time / 1000;\r\n    }\r\n}', 15, 1),
(305, 9, 'Public access modifiers', 'The Java access modifier public means that all code can access the class, field, constructor or method, regardless of where the accessing code is located. The accessing code can be in a different class and different package.', 'public class Clock {\r\n    public long time = 0;\r\n}\r\n\r\n\r\npublic class ClockReader {\r\n    Clock clock = new Clock();\r\n\r\n    public long readClock{\r\n        return clock.time;\r\n    }\r\n}', 20, 2),
(306, 32, 'Class access modifiers', 'It is important to keep in mind that the Java access modifier assigned to a Java class takes precedence over any access modifiers assigned to fields, constructors and methods of that class. If the class is marked with the default access modifier, then no other class outside the same Java package can access that class, including its constructors, fields and methods. It doesn''t help that you declare these fields public, or even public static.\r\n\r\nThe Java access modifiers private and protected cannot be assigned to a class. Only to constructors, methods and fields inside classes. Classes can only have the default (package) and public access modifier assigned to them.', '', 15, 1),
(307, 32, 'Access modifiers and inheritance', 'When you create a subclass of some class, the methods in the subclass cannot have less accessible access modifiers assigned to them than they had in the superclass. For instance, if a method in the superclass is public then it must be public in the subclass too, in case the subclass overrides the method. If a method in the superclass is protected then it must be either protected or public in the subclass.\r\n\r\nWhile it is not allowed to decrease accessibility of an overridden method, it is allowed to expand accessibility of an overridden method. For instance, if a method is assigned the default access modifier in the superclass, then it is allowed to assign the overridden method in the subclass the public access modifier.', '', 12, 1),
(308, 23, 'Manipulating Characters in a String', 'The String class has a number of methods for examining the contents of strings, finding characters or substrings within a string, changing case, and other tasks.\r\n\r\nGetting Characters and Substrings by Index\r\n\r\nYou can get the character at a particular index within a string by invoking the charAt() accessor method. The index of the first character is 0, while the index of the last character is length()-1. For example, the following code gets the character at index 9 in a string:\r\n\r\nString anotherPalindrome = "Niagara. O roar again!"; \r\nchar aChar = anotherPalindrome.charAt(9);', '', 20, 1),
(309, 23, 'The StringBuilder Class', 'StringBuilder objects are like String objects, except that they can be modified. Internally, these objects are treated like variable-length arrays that contain a sequence of characters. At any point, the length and content of the sequence can be changed through method invocations.\r\n\r\nStrings should always be used unless string builders offer an advantage in terms of simpler code (see the sample program at the end of this section) or better performance. For example, if you need to concatenate a large number of strings, appending to a StringBuilder object is more efficient.\r\n', 'tringBuilder()	Creates an empty string builder with a capacity of 16 (16 empty elements).\r\nStringBuilder(CharSequence cs)	Constructs a string builder containing the same characters as the specified CharSequence, plus an extra 16 empty elements trailing the CharSequence.\r\nStringBuilder(int initCapacity)	Creates an empty string builder with the specified initial capacity.', 20, 1),
(310, 30, 'What is an interface?', 'Interface looks like class but it is not a class. An interface can have methods and variables just like the class but the methods declared in interface are by default abstract (only method signature, no body). Also, the variables declared in an interface are public, static & final by default. We will discuss these points in detail, later in this post.', 'interface MyInterface\r\n{\r\n   /* All the methods are public abstract by default\r\n    * Note down that these methods are not having body\r\n    */\r\n   public void method1();\r\n   public void method2();\r\n}', 15, 1),
(311, 30, 'Nested interfaces', 'An interface which is declared inside another interface or class is called nested interface. They are also known as inner interface. For example Entry interface in collections framework is declared inside Map interface, that’s why we don’ use it directly, rather we use it like this: Map.Entry. Read more about nested interface along with examples at the link: Nested Interface with examples.\r\n\r\nKey points: Here are the key points to remember about interfaces:\r\n1) We can’t instantiate an interface in java.\r\n\r\n2) Interface provides complete abstraction as none of its methods can have body. On the other hand, abstract class provides partial abstraction as it can have abstract and concrete(methods with body) methods both.\r\n\r\n3) implements keyword is used by classes to implement an interface.\r\n\r\n4) While providing implementation in class of any method of an interface, it needs to be mentioned as public.\r\n\r\n5) Class implementing any interface must implement all the methods, otherwise the class should be declared as “abstract”.\r\n\r\n6) Interface cannot be declared as private, protected or transient.\r\n\r\n7) All the interface methods are by default abstract and public.\r\n\r\n8) Variables declared in interface are public, static and final by default.', 'interface Try\r\n{\r\n   int a=10;\r\n   public int a=10;\r\n   public static final int a=10;\r\n   final int a=10;\r\n   static int a=0;\r\n}', 15, 1),
(312, 30, 'Type Casting', 'Automatic Type casting take place when,\r\n\r\nthe two types are compatible\r\nthe target type is larger than the source type', 'public class Test\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n      int i = 100;	\r\n      long l = i;	//no explicit type casting required  \r\n      float f = l;	//no explicit type casting required  \r\n      System.out.println("Int value "+i);\r\n      System.out.println("Long value "+l);\r\n      System.out.println("Float value "+f);\r\n    }\r\n    \r\n}', 15, 1),
(313, 39, 'Narrowing or explicit type casting', 'When you are assigning a larger type value to a variable of smaller type, then you need to perform explicit type casting.', 'public class Test\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n      double d = 100.04;  \r\n      long l = (long)d;  //explicit type casting required  \r\n      int i = (int)l;	//explicit type casting required  \r\n      \r\n      System.out.println("Double value "+d);\r\n      System.out.println("Long value "+l);\r\n      System.out.println("Int value "+i);\r\n     \r\n    }\r\n    \r\n}', 25, 1),
(314, 7, 'what is exception?', 'An Exception can be anything which interrupts the normal flow of the program. When an exception occurs program processing gets terminated and doesn’t continue further. In such cases we get a system generated error message. The good thing about exceptions is that they can be handled. We will cover the handling part later in this same tutorial.\r\n\r\nWhy to handle exception?\r\nIf an exception is raised, which has not been handled by programmer then program execution can get terminated and system prints a non user friendly error message.', '', 15, 2),
(315, 7, 'Checked exceptions\r\n', 'All exceptions other than Runtime Exceptions are known as Checked exceptions as the compiler checks them during compilation to see whether the programmer has handled them or not. If these exceptions are not handled/declared in the program, it will give compilation error.', 'Examples of Checked Exceptions :-\r\nClassNotFoundException\r\nIllegalAccessException\r\nNoSuchFieldException\r\nEOFException etc.', 15, 2),
(316, 36, 'Throw exception', 'In java we have already defined exception classes such as ArithmeticException, ArrayIndexOutOfBoundsException, NullPointerException etc. There are certain conditions defined for these exceptions and on the occurrence of those conditions they are implicitly thrown by JVM(java virtual machine).\r\n\r\nDo you know that a programmer can create a new exception and throw it explicitly? These exceptions are known as user-defined exceptions. In order to throw user defined exceptions, throw keyword is being used. In this tutorial, we will see how to create a new exception and throw it in a program using throw keyword.', 'public void sample()\r\n{\r\n   //Statements\r\n   //if (somethingWrong) then\r\n   IOException e = new IOException();\r\n   throw e;\r\n   //More Statements\r\n }', 20, 2),
(317, 36, 'How to throw an already defined exception using throw keyword', '', 'package beginnersbook.com;\r\nclass Exception2{\r\n   static int sum(int num1, int num2){\r\n      if (num1 == 0)\r\n         throw new ArithmeticException("First parameter is not valid");\r\n      else\r\n         System.out.println("Both parameters are correct!!");\r\n      return num1+num2;\r\n   }\r\n   public static void main(String args[]){\r\n      int res=sum(0,12);\r\n      System.out.println(res);\r\n      System.out.println("Continue Next statements");\r\n   }\r\n}', 25, 2),
(318, 36, 'Arithmetic exception', 'Class: Java.lang.ArithmeticException\r\nThis is a built-in-class present in java.lang package. This exception occurs when an integer is divided by zero.', 'class ExceptionDemo1\r\n{\r\n   public static void main(String args[])\r\n   {\r\n      try{\r\n         int num1=30, num2=0;\r\n         int output=num1/num2;\r\n         System.out.println ("Result = " +output);\r\n      }\r\n      catch(ArithmeticException e){\r\n         System.out.println ("Arithmetic Exception: You can''t divide an integer by 0");\r\n      }\r\n   }\r\n}', 5, 2),
(319, 80, 'The JVM', 'At runtime, the JVM reads and interprets .class files and executes the program''s instructions on the native hardware platform for which the JVM was written. The JVM interprets the bytecode just as a CPU would interpret assembly-language instructions. The difference is that the JVM is a piece of software written specifically for a particular platform. The JVM is the heart of the Java language''s "write-once, run-anywhere" principle. Your code can run on any chipset for which a suitable JVM implementation is available. JVMs are available for major platforms like Linux and Windows, and subsets of the Java language have been implemented in JVMs for mobile phones and hobbyist chips.', '', 5, 0),
(320, 80, 'What is an object?', 'Structured programming languages like C and COBOL follow a different programming paradigm from object-oriented ones. The structured-programming paradigm is highly data oriented: You have data structures, and then program instructions act on that data. Object-oriented languages such as the Java language combine data and program instructions into objects.\r\nAn object is a self-contained entity that contains attributes and behavior, and nothing more. Instead of having a data structure with fields (attributes) and passing that structure around to all of the program logic that acts on it (behavior), in an object-oriented language, data and program logic are combined. This combination can occur at vastly different levels of granularity, from fine-grained objects such as a Number, to coarse-grained objects, such as a FundsTransfer service in a large banking application.\r\nParent and child objects\r\nA parent object is one that serves as the structural basis for deriving more-complex child objects. A child object looks like its parent but is more specialized. With the object-oriented paradigm, you can reuse the common attributes and behavior of the parent object, adding to its child objects attributes and behavior that differ. (You learn more about inheritance in the next section of this tutorial.)', '', 15, 0),
(321, 80, 'Key words', 'Like any programming language, the Java language designates certain words that the compiler recognizes as special. For that reason, you''re not allowed to use them for naming your Java constructs. The list of reserved words is surprisingly short:\r\nabstract\r\nassert\r\nboolean\r\nbreak\r\nbyte\r\ncase\r\ncatch\r\nchar\r\nclass\r\nconst\r\ncontinue\r\ndefault\r\ndo\r\ndouble\r\nelse\r\nenum\r\nextends\r\nfinal\r\nfinally\r\nfloat\r\nfor\r\ngoto\r\nif\r\nimplements\r\nimport\r\ninstanceof\r\nint\r\ninterface\r\nlong\r\nnative\r\nnew\r\npackage\r\nprivate\r\nprotected\r\npublic\r\nreturn\r\nshort\r\nstatic\r\nstrictfp\r\nsuper\r\nswitch\r\nsynchronized\r\nthis\r\nthrow\r\nthrows\r\ntransient\r\ntry\r\nvoid\r\nvolatile\r\nwhile', '', 5, 0),
(322, 80, 'Java class', 'A class is a blueprint for a discrete entity (object) that contains attributes and behavior. The class defines the object''s basic structure, and at runtime, your application creates an instance of the object. An object has a crisp boundary and a state, and it can do things when correctly asked. Every object-oriented language has rules about how to define a class.', 'package packageName;\r\nimport ClassNameToImport; accessSpecifier class ClassName {\r\n  accessSpecifier dataType variableName [= initialValue];\r\n  accessSpecifier ClassName([argumentList]) {\r\n    constructorStatement(s)\r\n  }\r\n  accessSpecifier returnType methodName ([argumentList]) {\r\n    methodStatement(s)\r\n  }\r\n  // This is a comment\r\n  /* This is a comment too */\r\n  /* This is a\r\n   multiline\r\n     comment */\r\n}', 20, 0),
(323, 12, 'Packaging classes', 'With the Java language, you can choose the names for your classes, such as Account, Person, or LizardMan. At times, you might end up using the same name to express two slightly different concepts. This situation is called a name collision, and it happens frequently. The Java language uses packages to resolve these conflicts.\r\nA Java package is a mechanism for providing a namespace— an area inside of which names are unique, but outside of which they might not be. To identify a construct uniquely, you must fully qualify it by including its namespace.\r\nPackages also give you a nice way to build more-complex applications with discrete units of functionality.', 'package orgType.orgName.appName.compName;\r\n\r\norgType is the organization type, such as com, org, or net.\r\norgName is the name of the organization''s domain, such as makotojava, oracle, or ibm.\r\nappName is the name of the application, abbreviated.\r\ncompName is the name of the component.', 15, 2),
(324, 12, 'REGEX', 'A regular expression defines a search pattern for strings. The abbreviation for regular expression is regex. The search pattern can be anything from a simple character, a fixed string or a complex expression containing special characters describing the pattern. The pattern defined by the regex may match one or several times or not at all for a given string.\r\n\r\nRegular expressions can be used to search, edit and manipulate text.\r\n\r\nThe process of analyzing or modifying a text with a regex is called: The regular expression is applied to the text (string) . The pattern defined by the regex is applied on the text from left to right. Once a source character has been used in a match, it cannot be reused. For example, the regex aba will match ababababa only two times (aba_aba__).\r\n', 'this is text----Matches exactly "this is text"\r\nthis\\s+is\\s+text----Matches the word "this" followed by one or more whitespace characters followed by the word "is" followed by one or more whitespace characters followed by the word "text".\r\n^\\d+(\\.\\d+)?----^ defines that the patter must start at beginning of a new line. \\d+ matches one or several digits. The ? makes the statement in brackets optional. \\. matches ".", parentheses are used for grouping. Matches for example "5", "1.5" and "2.21".', 15, 2),
(325, 12, 'Using regular expressions with String methods\r\n', 'Strings in Java have built-in support for regular expressions. Strings have four built-in methods for regular expressions, i.e., the matches(), split()), replaceFirst() and replaceAll() methods. The replace() method does NOT support regular expressions.\r\n\r\nThese methods are not optimized for performance. We will later use classes which are optimized for performance.', 's.matches("regex")----Evaluates if "regex" matches s. Returns only true if the WHOLE string can be matched.\r\ns.split("regex")----Creates an array with substrings of s divided at occurrence of "regex". "regex" is not included in the result.\r\ns.replaceFirst("regex"), "replacement"---	Replaces first occurance of "regex" with "replacement.\r\ns.replaceAll("regex"), "replacement"---	Replaces all occurances of "regex" with "replacement.', 15, 2),
(326, 56, 'Regex pattern matcher', 'For advanced regular expressions the java.util.regex.Pattern and java.util.regex.Matcher classes are used.\r\n\r\nYou first create a Pattern object which defines the regular expression. This Pattern object allows you to create a Matcher object for a given string. This Matcher object then allows you to do regex operations on a String.', 'package de.vogella.regex.test;\r\n\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\npublic class RegexTestPatternMatcher {\r\n  public static final String EXAMPLE_TEST = "This is my small example string which I''m going to use for pattern matching.";\r\n\r\n  public static void main(String[] args) {\r\n    Pattern pattern = Pattern.compile("\\\\w+");\r\n    // in case you would like to ignore case sensitivity,\r\n    // you could use this statement:\r\n    // Pattern pattern = Pattern.compile("\\\\s+", Pattern.CASE_INSENSITIVE);\r\n    Matcher matcher = pattern.matcher(EXAMPLE_TEST);\r\n    // check all occurance\r\n    while (matcher.find()) {\r\n      System.out.print("Start index: " + matcher.start());\r\n      System.out.print(" End index: " + matcher.end() + " ");\r\n      System.out.println(matcher.group());\r\n    }\r\n    // now create a new pattern and matcher to replace whitespace with tabs\r\n    Pattern replace = Pattern.compile("\\\\s+");\r\n    Matcher matcher2 = replace.matcher(EXAMPLE_TEST);\r\n    System.out.println(matcher2.replaceAll("\\t"));\r\n  }\r\n} ', 15, 2),
(327, 56, 'JAVA swing', 'Swing is a GUI widget toolkit for Java. It is part of Oracle''s Java Foundation Classes (JFC) – an API for providing a graphical user interface (GUI) for Java programs.\r\n\r\nSwing was developed to provide a more sophisticated set of GUI components than the earlier Abstract Window Toolkit (AWT). Swing provides a native look and feel that emulates the look and feel of several platforms, and also supports a pluggable look and feel that allows applications to have a look and feel unrelated to the underlying platform. It has more powerful and flexible components than AWT. In addition to familiar components such as buttons, check boxes and labels, Swing provides several advanced components such as tabbed panel, scroll panes, trees, tables, and lists.\r\n\r\nUnlike AWT components, Swing components are not implemented by platform-specific code. Instead, they are written entirely in Java and therefore are platform-independent. The term "lightweight" is used to describe such an element.[1]\r\n\r\nSwing is currently in the process of being replaced by JavaFX.\r\n', '', 10, 2),
(328, 56, 'JFC and Swing', 'Swing GUI Components-----Includes everything from buttons to split panes to tables. Many components are capable of sorting, printing, and drag and drop, to name a few of the supported features.\r\nPluggable Look-and-Feel Support	The look and feel of Swing applications is pluggable, allowing a choice of look and feel. For example, the same program can use either the Java or the Windows look and feel. Additionally, the Java platform supports the GTK+ look and feel, which makes hundreds of existing look and feels available to Swing programs. Many more look-and-feel packages are available from various sources.\r\nAccessibility API----Enables assistive technologies, such as screen readers and Braille displays, to get information from the user interface.\r\nJava 2D API-----Enables developers to easily incorporate high-quality 2D graphics, text, and images in applications and applets. Java 2D includes extensive APIs for generating and sending high-quality output to printing devices.\r\nInternationalization----Allows developers to build applications that can interact with users worldwide in their own languages and cultural conventions. With the input method framework developers can build applications that accept text in languages that use thousands of different characters, such as Japanese, Chinese, or Korean.', '', 15, 2),
(329, 56, 'SWING PACKAGES', 'The Swing API is powerful, flexible — and immense. The Swing API has 18 public packages:\r\n\r\njavax.accessibility	\r\njavax.swing.plaf	\r\njavax.swing.text\r\njavax.swing	\r\njavax.swing.plaf.basic	javax.swing.text.html\r\njavax.swing.border	javax.swing.plaf.metal	javax.swing.text.html.parser\r\njavax.swing.colorchooser	javax.swing.plaf.multi	javax.swing.text.rtf\r\njavax.swing.event	javax.swing.plaf.synth	\r\njavax.swing.tree\r\njavax.swing.filechooser	javax.swing.table	\r\njavax.swing.undo\r\nFortunately, most programs use only a small subset of the API. This trail sorts out the API for you, giving you examples of common code and pointing you to methods and classes you''re likely to need. Most of the code in this trail uses only one or two Swing packages:\r\n\r\njavax.swing\r\njavax.swing.event (not always required)', '', 10, 2),
(330, 22, 'Packages in java and how to use them?', 'Packages in Java is a mechanism to encapsulate a group of classes, interfaces and sub packages. Many implementations of Java use a hierarchical file system to manage source and class files. It is easy to organize class files into packages. All we need to do is put related class files in the same directory, give the directory a name that relates to the purpose of the classes, and add a line to the top of each class file that declares the package name, which is the same as the directory name where they reside.\r\n\r\nIn java there are already many predefined packages that we use while programming.', 'For example: java.lang, java.io, java.util etc.\r\nHowever one of the most useful feature of java is that we can define our own packages', 15, 2);
INSERT INTO `notessal` (`notesid`, `uid`, `topic`, `content`, `code`, `likes`, `nlevel`) VALUES
(331, 22, 'Multithreading ', 'Java was one of the first languages to make multithreading easily available to developers. Java had multithreading capabilities from the very beginning. Therefore, Java developers often face the problems described above. That is the reason I am writing this trail on Java concurrency. As notes to myself, and any fellow Java developer whom may benefit from it.\r\n\r\nThe trail will primarily be concerned with multithreading in Java, but some of the problems occurring in multithreading are similar to problems occurring in multitasking and in distributed systems. References to multitasking and distributed systems may therefore occur in this trail too. Hence the word "concurrency" rather than "multithreading".', '', 10, 2),
(332, 22, 'Creating and Starting Threads', 'Creating a thread in Java is done like this:\r\n\r\n  Thread thread = new Thread();\r\n\r\n\r\nTo start the Java thread you will call its start() method, like this:\r\n\r\n  thread.start();', ' public class MyThread extends Thread {\r\n\r\n    public void run(){\r\n       System.out.println("MyThread running");\r\n    }\r\n  }\r\n\r\n\r\nTo create and start the above thread you can do like this:\r\n\r\n  MyThread myThread = new MyThread();\r\n  myTread.start();', 25, 2),
(333, 22, 'Runnable Interface Implementation', 'A way to specify what code a thread should run is by creating a class that implements java.lang.Runnable. The Runnable object can be executed by a Thread', 'public class MyRunnable implements Runnable {\r\n\r\n    public void run(){\r\n       System.out.println("MyRunnable running");\r\n    }\r\n  }\r\n\r\nThread thread = new Thread(new MyRunnable());\r\n   thread.start();\r\n', 10, 2),
(334, 22, 'Thread.currentThread()', 'The Thread.currentThread() method returns a reference to the Thread instance executing currentThread() . This way you can get access to the Java Thread object representing the thread executing a given block of code. Here is an example of how to use Thread.currentThread() :\r\n\r\nString threadName = Thread.currentThread().getName();', '', 15, 2),
(335, 15, 'Exception classes', 'In Java, exceptions are objects. When you throw an exception, you throw an object. You can''t throw just any object as an exception, however -- only those objects whose classes descend from Throwable. Throwable serves as the base class for an entire family of classes, declared in java.lang, that your program can instantiate and throw. A small part of this family is shown in Figure 1.\r\n\r\nAs you can see in Figure 1, Throwable has two direct subclasses, Exception and Error. Exceptions (members of the Exception family) are thrown to signal abnormal conditions that can often be handled by some catcher, though it''s possible they may not be caught and therefore could result in a dead thread. Errors (members of the Error family) are usually thrown for more serious problems, such as OutOfMemoryError, that may not be so easy to handle. In general, code you write should throw only exceptions, not errors. Errors are usually thrown by the methods of the Java API, or by the Java virtual machine itself.', '// In source packet in file except/ex9/Example9a.java\r\nimport java.io.*;\r\nclass Example9a {\r\n    public static void main(String[] args)\r\n        throws IOException {\r\n        if (args.length == 0) {\r\n            System.out.println("Must give filename as first arg.");\r\n            return;\r\n        }\r\n        FileInputStream in;\r\n        try {\r\n            in = new FileInputStream(args[0]);\r\n        }\r\n        catch (FileNotFoundException e) {\r\n            System.out.println("Can''t find file: " + args[0]);\r\n            return;\r\n        }\r\n        int ch;\r\n        while ((ch = in.read()) != -1) {\r\n            System.out.print((char) ch);\r\n        }\r\n        System.out.println();\r\n        in.close();\r\n    }\r\n}', 20, 2),
(336, 15, 'Checked vs Unchecked exceptions', 'The big question, then, is whether to throw a "checked" or an "unchecked" exception. A checked exception is some subclass of Exception (or Exception itself), excluding class RuntimeException and its subclasses. Unchecked exceptions are RuntimeException and any of its subclasses. Class Error and its subclasses also are unchecked, but as you should be focusing on throwing exceptions only, your decision should be whether to throw a subclass of RuntimeException (an unchecked exception) or some other subclass of Exception (a checked exception).\r\n\r\nIf you throw a checked exception (and don''t catch it), you will need to declare the exception in your method''s throws clause. Client programmers who wish to call your method will then need to either catch and handle the exception within the body of their methods, or declare the exception in the throws clause of their methods. Making an exception checked forces client programmers to deal with the possibility that the exception will be thrown.', '', 15, 2),
(337, 15, 'What is thread safety?', 'Thread safety simply means that the fields of an object or class always maintain a valid state, as observed by other objects and classes, even when used concurrently by multiple threads.\r\n\r\nThere are two big reasons you need to think about thread safety when you design classes and objects in Java:\r\n\r\nSupport for multiple threads is built into the Java language and API\r\nAll threads inside a Java virtual machine (JVM) share the same heap and method area\r\nBecause multithreading is built into Java, it is possible that any class you design eventually may be used concurrently by multiple threads. You needn''t (and shouldn''t) make every class you design thread-safe, because thread safety doesn''t come for free. But you should at least think about thread safety every time you design a Java class. You''ll find a discussion of the costs of thread safety and guidelines concerning when to make classes thread-safe later in this article.\r\n\r\n', '', 10, 2),
(338, 36, 'HashMAp', 'A HashMap contains values based on the key. It implements the Map interface and extends AbstractMap class.\r\nIt contains only unique elements.\r\nIt may have one null key and multiple null values.\r\nIt maintains no order.', 'import java.util.*;  \r\nclass TestCollection13{  \r\n public static void main(String args[]){  \r\n   \r\n  HashMap<Integer,String> hm=new HashMap<Integer,String>();  \r\n  \r\n  hm.put(100,"Amit");  \r\n  hm.put(101,"Vijay");  \r\n  hm.put(102,"Rahul");  \r\n  \r\n  for(Map.Entry m:hm.entrySet()){  \r\n   System.out.println(m.getKey()+" "+m.getValue());  \r\n  }  \r\n }  \r\n}  ', 25, 2),
(339, 5, 'LinkedHashMap class', 'A LinkedHashMap contains values based on the key. It implements the Map interface and extends HashMap class.\r\nIt contains only unique elements.\r\nIt may have one null key and multiple null values.\r\nIt is same as HashMap instead maintains insertion order.', 'import java.util.*;  \r\nclass TestCollection14{  \r\n public static void main(String args[]){  \r\n   \r\n  LinkedHashMap<Integer,String> hm=new LinkedHashMap<Integer,String>();  \r\n  \r\n  hm.put(100,"Amit");  \r\n  hm.put(101,"Vijay");  \r\n  hm.put(102,"Rahul");  \r\n  \r\nfor(Map.Entry m:hm.entrySet()){  \r\n   System.out.println(m.getKey()+" "+m.getValue());  \r\n  }  \r\n }  \r\n}  ', 25, 2),
(340, 5, 'HashMap (TreeMap class)', 'A TreeMap contains values based on the key. It implements the NavigableMap interface and extends AbstractMap class.\r\nIt contains only unique elements.\r\nIt cannot have null key but can have multiple null values.\r\nIt is same as HashMap instead maintains ascending order.', 'import java.util.*;  \r\nclass TestCollection15{  \r\n public static void main(String args[]){  \r\n   \r\n  TreeMap<Integer,String> hm=new TreeMap<Integer,String>();  \r\n  \r\n  hm.put(100,"Amit");  \r\n  hm.put(102,"Ravi");  \r\n  hm.put(101,"Vijay");  \r\n  hm.put(103,"Rahul");  \r\n  \r\n  for(Map.Entry m:hm.entrySet()){  \r\n   System.out.println(m.getKey()+" "+m.getValue());  \r\n  }  \r\n }  \r\n}  ', 15, 2),
(341, 77, 'How final keyword works?', 'In Java we use final keyword to variables to make its values not to be changed. But I see that you can change the value in the constructor / methods of the class. Again, if the variable is static then it is a compilation error.', 'private final List foo;\r\n\r\npublic Test()\r\n{\r\n    foo = new ArrayList();\r\n    foo.add("foo"); // Modification-1\r\n}\r\npublic static void main(String[] args) \r\n{\r\n    Test t = new Test();\r\n    t.foo.add("bar"); // Modification-2\r\n    System.out.println("print - " + t.foo);\r\n}', 25, 1),
(342, 33, 'Stacks and queues in java', 'we introduce two closely-related data types for manipulating arbitrarily large collections of objects: the stack and the queue. Each is defined by two basic operations: insert a new item, and remove an item. When we insert an item, our intent is clear. But when we remove an item, which one do we choose? The rule used for a queue is to always remove the item that has been in the collection the most amount of time. This policy is known as first-in-first-out or FIFO. The rule used for a stack is to always remove the item that has been in the collection the least amount of time. This policy is known as last-in first-out or LIFO.', '', 10, 1),
(343, 77, 'linkedlist in java', 'For classes such as stacks that implement collections of objects, an important objective is to ensure that the amount of space used is always proportional to the number of items in the collection. Now we consider the use of a fundamental data structure known as a linked list that can provide implementations of collections (and, in particular, stacks) that achieves this important objective.\r\nA linked list is a recursive data structure defined as follows: a linked list is either empty (null) or a reference to a node having a reference to a linked list. The node in this definition is an abstract entity that might hold any kind of data in addition to the node reference that characterizes its role in building linked lists. With object-oriented programming, implementing linked lists is not difficult. We start with a simple example of a class for the node abstraction:', 'class Node { \r\n   String item; \r\n   Node next; \r\n}\r\n\r\n\r\nNode first  = new Node(); \r\nNode second = new Node(); \r\nNode third  = new Node(); \r\n\r\nfirst.item  = "to"; \r\nsecond.item = "be"; \r\nthird.item  = "or";\r\n\r\nfirst.next  = second; \r\nsecond.next = third; \r\nthird.next  = null;', 15, 1),
(344, 79, 'Stack in Java', 'A stack is a LIFO sequence. Addition and removal takes place only at one end, called the top.\r\n\r\nOperations\r\n\r\npush(x): add an item on the top\r\npop: remove the item at the top\r\npeek: return the item at the top (without removing it)\r\nsize: return the number of items in the stack\r\nisEmpty: return whether the stack has no items', 'package edu.lmu.cs.collections;\r\n\r\n/**\r\n * A small stack interface.  You can query the size of the stack and\r\n * ask whether it is empty, push items, pop items, and peek at the top\r\n * item.\r\n */\r\npublic interface Stack {\r\n\r\n    /**\r\n     * Adds the given item to the top of the stack.\r\n     */\r\n    void push(Object item);\r\n\r\n    /**\r\n     * Removes the top item from the stack and returns it.\r\n     * @exception java.util.NoSuchElementException if the stack is empty.\r\n     */\r\n    Object pop();\r\n\r\n    /**\r\n     * Returns the top item from the stack without popping it.\r\n     * @exception java.util.NoSuchElementException if the stack is empty.\r\n     */\r\n    Object peek();\r\n\r\n    /**\r\n     * Returns the number of items currently in the stack.\r\n     */\r\n    int size();\r\n\r\n    /**\r\n     * Returns whether the stack is empty or not.\r\n     */\r\n    boolean isEmpty();\r\n}', 20, 1),
(345, 77, 'Linked implementation of stack', '', 'package edu.lmu.cs.collections;\r\n\r\nimport java.util.NoSuchElementException;\r\n\r\n/**\r\n * An implementation of the stack interface using singly-linked\r\n * nodes.\r\n */\r\npublic class LinkedStack implements Stack {\r\n    private class Node {\r\n        public Object data;\r\n        public Node next;\r\n        public Node(Object data, Node next) {\r\n            this.data = data;\r\n            this.next = next;\r\n        }\r\n    }\r\n\r\n    private Node top = null;\r\n\r\n    public void push(Object item) {\r\n        top = new Node(item, top);\r\n    }\r\n\r\n    public Object pop() {\r\n        Object item = peek();\r\n        top = top.next;\r\n        return item;\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return top == null;\r\n    }\r\n\r\n    public Object peek() {\r\n        if (top == null) {\r\n            throw new NoSuchElementException();\r\n        }\r\n        return top.data;\r\n    }\r\n\r\n    public int size() {\r\n        int count = 0;\r\n        for (Node node = top; node != null; node = node.next) {\r\n            count++;\r\n        }\r\n        return count;\r\n    }\r\n}', 20, 1),
(346, 90, 'Stack ADT', 'ctions we have seen include arrays and lists.\r\n\r\nAs I said, an ADT is defined by the operations you can perform on it. Stacks can perform only the following operations:\r\n\r\nconstructor\r\nCreate a new, empty stack.\r\npush\r\nAdd a new item to the stack.\r\npop\r\nRemove and return an item from the stack. The item that is returned is always the last one that was added.\r\nempty\r\nCheck whether the stack is empty.\r\nA stack is sometimes called a "last in, first out," or LIFO data structure, because the last item added is the first to be removed.', '', 15, 1),
(347, 90, 'Java stack object', 'Java provides a built-in object type called Stack that implements the Stack ADT. You should make some effort to keep these two things---the ADT and the Java implementation---straight. Before using the Stack class, we have to import it from java.util.\r\n\r\nThen the syntax for constructing a new Stack is\r\n\r\n    Stack stack = new Stack (); \r\nInitially the stack is empty, as we can confirm with the empty method, which returns a boolean:\r\n\r\n    System.out.println (stack.empty ()); \r\nA stack is a generic data structure, which means that we can add any type of item to it. In the Java implementation, though, we can only add object types. For our first example, we''ll use Node objects, as defined in the previous chapter. Let''s start by creating and printing a short list.\r\n\r\n    LinkedList list = new LinkedList (); \r\n    list.addFirst (3); \r\n    list.addFirst (2); \r\n    list.addFirst (1); \r\n    list.print (); \r\nThe output is (1, 2, 3). To put a Node object onto the stack, use the push method:\r\n\r\n    stack.push (list.head); \r\nThe following loop traverses the list and pushes all the nodes onto the stack:\r\n\r\n    for (Node node = list.head; node != null; node = node.next) { \r\n        stack.push (node); \r\n    } \r\nWe can remove an element from the stack with the pop method.\r\n\r\n    Object obj = stack.pop (); \r\nThe return type from pop is Object! That''s because the stack implementation doesn''t really know the type of the objects it contains. When we pushed the Node objects, they were automatically converted to Objects. When we get them back from the stack, we have to cast them back to Nodes.\r\n\r\nNode node = (Node) obj; \r\nSystem.out.println (node); \r\nUnfortunately, the burden falls on the programmer to keep track of the objects in the stack and cast them back to the right type when they are removed. If you try to cast an object to the wrong type, you get a ClassCastException.\r\n\r\nThe following loop is a common idiom for popping all the elements from a stack, stopping when it is empty:\r\n\r\n    while (!stack.empty ()) { \r\n        Node node = (Node) stack.pop (); \r\n        System.out.print (node + " "); \r\n    } \r\n\r\nThe output is 3 2 1. In other words, we just used a stack to print the elements of a list backwards! Granted, it''s not the standard format for printing a list, but using a stack it was remarkably easy to do.\r\n\r\nYou should compare this code to the implementations of printBackward in the previous chapter. There is a natural parallel between the recursive version of printBackward and the stack algorithm here. The difference is that printBackward uses the run-time stack to keep track of the nodes while it traverses the list, and then prints them on the way back from the recursion. The stack algorithm does the same thing, just using a Stack object instead of the run-time stack.', '', 20, 1),
(348, 77, 'Queue Implementations in java', 'Being a Collection subtype all methods in the Collection interface are also available in the Queue interface.\r\n\r\nSince Queue is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following Queue implementations in the Java Collections API:\r\n\r\njava.util.LinkedList\r\njava.util.PriorityQueue\r\nLinkedList is a pretty standard queue implementation.\r\n\r\nPriorityQueue stores its elements internally according to their natural order (if they implement Comparable), or according to a Comparator passed to the PriorityQueue.\r\n\r\nThere are also Queue implementations in the java.util.concurrent package, but I will leave the concurrency utilities out of this tutorial.', 'Here are a few examples of how to create a Queue instance:\r\n\r\nQueue queueA = new LinkedList();\r\nQueue queueB = new PriorityQueue();', 20, 1),
(349, 100, 'Adding and accessing elements in queue', 'To add elements to a Queue you call its add() method. This method is inherited from the Collection interface. Here are a few examples:\r\n\r\nQueue queueA = new LinkedList();\r\n\r\nqueueA.add("element 1");\r\nqueueA.add("element 2");\r\nqueueA.add("element 3");\r\nThe order in which the elements added to the Queue are stored internally, depends on the implementation. The same is true for the order in which elements are retrieved from the queue. You should consult the JavaDoc''s for more information about the specific Queue implementations.\r\n\r\nYou can peek at the element at the head of the queue without taking the element out of the queue. This is done via the element() method. Here is how that looks:\r\n\r\nObject firstElement = queueA.element();', 'Queue queueA = new LinkedList();\r\n\r\nqueueA.add("element 0");\r\nqueueA.add("element 1");\r\nqueueA.add("element 2");\r\n\r\n//access via Iterator\r\nIterator iterator = queueA.iterator();\r\nwhile(iterator.hasNext(){\r\n  String element = (String) iterator.next();\r\n}\r\n\r\n//access via new for-loop\r\nfor(Object object : queueA) {\r\n    String element = (String) object;\r\n}', 20, 1),
(350, 456, 'Generic queue', 'By default you can put any Object into a Queue, but from Java 5, Java Generics makes it possible to limit the types of object you can insert into a Queue. Here is an example:\r\n\r\nQueue<MyObject> queue = new LinkedList<MyObject>();\r\nThis Queue can now only have MyObject instances inserted into it. You can then access and iterate its elements without casting them. Here is how it looks:\r\n\r\nMyObject myObject = queue.remove();\r\n\r\nfor(MyObject anObject : queue){\r\n   //do someting to anObject...   \r\n}', '', 20, 1),
(351, 456, 'Java dequeue implementation', 'Being a Queue subtype all methods in the Queue and Collection interfaces are also available in the Deque interface.\r\n\r\nSince Deque is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following Deque implementations in the Java Collections API:\r\n\r\njava.util.ArrayDeque\r\njava.util.LinkedList\r\nLinkedList is a pretty standard deque / queue implementation.\r\n\r\nArrayDeque stores its elements internally in an array. If the number of elements exceeds the space in the array, a new array is allocated, and all elements moved over. In other words, the ArrayDeque grows as needed, even if it stores its elements in an array.', 'Here are a few examples of how to create a Deque instance:\r\n\r\nDeque dequeA = new LinkedList();\r\nDeque dequeB = new ArrayDeque();', 20, 1),
(352, 100, 'Method overloading and overriding', 'The difference between overriding and overloading in Java is a common source of confusion – but it is fairly easy to understand with the examples we present below. Let’s start the discussion by talking more about method overloading first. Method overloading in Java occurs when two or more methods in the same class have the exact same name but different parameters (remember that method parameters accept values passed into the method). Now, two or more methods with the same name in the same class sounds simple enough to understand. But, what do we mean exactly by different parameters? Well, let’s consider a very simple example.\r\n\r\nSuppose we have a class called TestClass which has two methods, and both methods have the same name. Let’s say that name is “someMethod”. Those two methods would be considered to be “overloaded” if if one or both of these conditions is true:', '//compiler error - can''t overload based on the   \r\n//type returned -\r\n//(one method returns int, the other returns a float):    \r\n\r\nint changeDate(int Year) ;  \r\nfloat changeDate (int Year);    \r\n\r\n//compiler error - can''t overload by changing just \r\n//the name of the parameter (from Year to Month):    \r\n\r\nint changeDate(int Year);   \r\nint changeDate(int Month) ;  \r\n \r\n//valid case of overloading, since the methods\r\n//have different number of parameters:        \r\n\r\nint changeDate(int Year, int Month) ;  \r\nint changeDate(int Year);    \r\n\r\n//also a valid case of overloading, since the   \r\n//parameters are of different types:    \r\n\r\nint changeDate(float Year) ;  \r\nint changeDate(int Year);  \r\n', 20, 1),
(353, 456, 'stack in java', 'A stack consists of a sequence of items, which should be thought of as piled one on top of the other like a physical stack of boxes or cafeteria trays. Only the top item on the stack is accessible at any given time. It can be removed from the stack with an operation called pop. An item lower down on the stack can only be removed after all the items on top of it have been popped off the stack. A new item can be added to the top of the stack with an operation called push. We can make a stack of any type of items. If, for example, the items are values of type int, then the push and pop operations can be implemented as instance methods\r\n\r\nvoid push (int newItem) -- Add newItem to top of stack.\r\nint pop() -- Remove the top int from the stack and return it.\r\nIt is an error to try to pop an item from an empty stack, so it is important to be able to tell whether a stack is empty. We need another stack operation to do the test, implemented as an instance method\r\n\r\nboolean isEmpty() -- Returns true if the stack is empty.\r\nThis defines a "stack of ints" as an abstract data type. This ADT can be implemented in several ways, but however it is implemented, its behavior must correspond to the abstract mental image of a stack.', 'public class StackOfInts {\r\n\r\n   /**\r\n    * An object of type Node holds one of the items in the linked list \r\n    * that represents the stack.\r\n    */\r\n   private static class Node {\r\n      int item;\r\n      Node next;\r\n   }\r\n   \r\n   private Node top;  // Pointer to the Node that is at the top of\r\n                      //   of the stack.  If top == null, then the\r\n                      //   stack is empty.\r\n   \r\n   /**\r\n    * Add N to the top of the stack.\r\n    */\r\n   public void push( int N ) {\r\n      Node newTop;         // A Node to hold the new item.\r\n      newTop = new Node();\r\n      newTop.item = N;     // Store N in the new Node.\r\n      newTop.next = top;   // The new Node points to the old top.\r\n      top = newTop;        // The new item is now on top.\r\n   }\r\n   \r\n   /**\r\n    * Remove the top item from the stack, and return it.\r\n    * Throws an IllegalStateException if the stack is empty when\r\n    * this method is called.\r\n    */\r\n   public int pop() {\r\n      if ( top == null )\r\n         throw new IllegalStateException("Can''t pop from an empty stack.");\r\n      int topItem = top.item;  // The item that is being popped.\r\n      top = top.next;          // The previous second item is now on top.\r\n      return topItem;\r\n   }\r\n   \r\n   /**\r\n    * Returns true if the stack is empty.  Returns false\r\n    * if there are one or more items on the stack.\r\n    */\r\n   public boolean isEmpty() {\r\n      return (top == null);\r\n   }\r\n\r\n} // end class StackOfInts', 18, 1),
(354, 100, 'postfix expression evaluation using stack in java', 'Algrithm:\r\nStart with an empty stack\r\nfor each item in the expression:\r\n    if the item is a number:\r\n       Push the number onto the stack\r\n    else if the item is an operator:\r\n       Pop the operands from the stack  // Can generate an error\r\n       Apply the operator to the operands\r\n       Push the result onto the stack\r\n    else\r\n       There is an error in the expression\r\nPop a number from the stack  // Can generate an error\r\nif the stack is not empty:\r\n   There is an error in the expression\r\nelse:\r\n   The last number that was popped is the value of the expression', '', 30, 1),
(355, 39, 'vector class', 'create a new vector ', 'Vector<int> v = new Vector<int>();', 1, 1),
(356, 39, 'packages', 'Packages in Java is a mechanism to encapsulate a group of classes, interfaces and sub packages.', 'package foo;', 1, 1),
(357, 5, 'Static synchronization', 'If you make any static method as synchronized, the lock will be on the class not on object.', '', 1, 2),
(358, 36, 'Regex Quantifiers', 'Java Regex API provides 1 interface and 3 classes in java.util.regex package.java.util.regex packageIt provides following classes and interface for regular expressions.', '', 1, 2),
(359, 36, 'FileInputStream class', 'Java FileReader class is used to read data from the file. It returns data in byte format like FileInputStream class.', '', 1, 2),
(362, 40, 'FileInputStream class', 'Java FileReader class is used to read data from the file. It returns data in byte format like FileInputStream class.', '', 1, 1),
(363, 82, 'start a thread twice', 'Creating a thread in Java is done like this: Thread thread = new Thread();To start the Java thread you will call its start() method, like this: thread.start();', '', 1, 2),
(364, 23, 'HashMap ', 'A TreeMap contains values based on the key. It implements the NavigableMap interface and extends AbstractMap class.It contains only unique elements.It cannot have null key but can have multiple null values.It is same as HashMap instead maintains ascending order.', '', 1, 1),
(365, 0, 'Method overloading', 'Instead of overloading, you can use dynamic number of arguments. After the last parameter, you can pass optional unlimited parameters of the same type. These parameters are defined by adding a last parameter and adding ... after its type. The dynamic arguments will be received as an array:The above method can be called with a dynamic number of arguments, for example:This feature was not available before Java 1.5 ', '', 1, 1),
(366, 22, 'Naming a thread', 'The currentThread() method returns a reference to the currently executing thread object.Syntax:public static Thread currentThread()', '', 1, 2),
(367, 45, 'Valid main methods', 'etc etc', '', 1, 0),
(368, 45, 'variables', 'hkugsdxh', 'htdeu', 1, 0);

-- --------------------------------------------------------

--
-- Table structure for table `text`
--

CREATE TABLE `text` (
  `textid` int(11) NOT NULL,
  `topic` text NOT NULL,
  `content` text NOT NULL,
  `code` text NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `text`
--

INSERT INTO `text` (`textid`, `topic`, `content`, `code`) VALUES
(1, 'Java - Overview', 'Java programming language was originally developed by Sun Microsystems which was initiated by James Gosling and released in 1995 as core component of Sun Microsystems Java platform (Java 1.0 [J2SE]).The latest release of the Java Standard Edition is Java SE 8. With the advancement of Java and its widespread popularity, multiple configurations were built to suite various types of platforms. Ex: J2EE for Enterprise Applications, J2ME for Mobile Applications.The new J2 versions were renamed as Java SE, Java EE and Java ME respectively. Java is guaranteed to be <b>Write Once, Run Anywhere.</b>Java is: <li><p><b>Object Oriented:</b> In Java, everything is an Object. Java can be easily extended since it is based on the Object model.</p></li> <li><p><b>Platform independent:</b> Unlike many other programming languages including C and C++, when Java is compiled, it is not compiled into platform specific machine, rather into platform independent byte code. This byte code is distributed over the web and interpreted by virtual Machine (JVM) on whichever platform it is being run.</p></li> <li><p><b>Simple:</b> Java is designed to be easy to learn. If you understand the basic concept of OOP Java would be easy to master.</p></li> <li><p><b>Secure:</b> With Javas secure feature it enables to develop virus-free, tamper-free systems. Authentication techniques are based on public-key encryption.</p></li> <li><p><b>Architectural-neutral: </b>Java compiler generates an architecture-neutral object file format which makes the compiled code to be executable on many processors, with the presence of Java runtime system.</p></li> <li><p><b>Portable:</b> Being architectural-neutral and having no implementation dependent aspects of the specification makes Java portable. Compiler in Java is written in ANSI C with a clean portability boundary which is a POSIX subset.</p></li> <li><p><b>Robust:</b> Java makes an effort to eliminate error prone situations by emphasizing mainly on compile time error checking and runtime checking.</p></li> <li><p><b>Multithreaded:</b> With Javas multithreaded feature it is possible to write programs that can do many tasks simultaneously. This design feature allows developers to construct smoothly running interactive applications.</p></li> <li><p><b>Interpreted:</b> Java byte code is translated on the fly to native machine instructions and is not stored anywhere. The development process is more rapid and analytical since the linking is an incremental and light weight process. </p></li> <li><p><b>High Performance:</b> With the use of Just-In-Time compilers, Java enables high performance.</p></li> <li><p><b>Distributed:</b> Java is designed for the distributed environment of the internet.</p></li> <li><p><b>Dynamic:</b> Java is considered to be more dynamic than C or C++ since it is designed to adapt to an evolving environment. Java programs can carry extensive amount of run-time information that can be used to verify and resolve accesses to objects on run-time.</p></li> ', ''),
(2, 'History of Java:', 'James Gosling initiated the Java language project in June 1991 for use in one of his many set-top box projects. The language, initially called Oak after an oak tree that stood outside Goslings office, also went by the name Green and ended up later being renamed as Java, from a list of random words.Sun released the first public implementation as Java 1.0 in 1995. It promised <b>Write Once, Run Anywhere</b>(WORA), providing no-cost run-times on popular platforms. On 13 November 2006, Sun released much of Java as free and open source software under the terms of the GNU General Public License (GPL).On 8 May 2007, Sun finished the process, making all of Javas core code free and open-source, aside from a small portion of code to which Sun did not hold the copyright.', ''),
(3, 'Tools you will need:', 'For performing the examples discussed in this tutorial, you will need a Pentium 200-MHz computer with a minimum of 64 MB of RAM (128 MB of RAM recommended).You also will need the following softwares: <li><p>Linux 7.1 or Windows xp/7/8 operating system.</p></li> <li><p>Java JDK 8 </p></li> <li><p>Microsoft Notepad or any other text editor</p></li> This tutorial will provide the necessary skills to create GUI, networking, and Web applications using Java.', ''),
(4, 'Try It Option:', 'We have provided you an option to compile and execute available code online. Just click on <b>Try it</b> button avaiable at top-right corner of the code window to compile and execute available code. There are certain examples which can not be executed online, so we have skipped those examples.There may be a case that you do not see the result of the compiled/executed code, in such case you can re-try to compile and execute the code using <b>execute</b> button available in compliation pop-up window.', '<br><code><pre class="prettyprint notranslate tryit"> public class MyFirstJavaProgram {      public static void main(String []args) {        System.out.println("Hello World");     } }  </pre></code><br>'),
(5, 'Local Environment Setup', 'If you are still willing to set up your environment for Java programming language, then this section guides you on how to download and set up Java on your machine. Please follow the following steps to set up the environment.Java SE is freely available from the link <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank">Download Java</a>. So you download a version based on your operating system.Follow the instructions to download java and run the <b>.exe</b> to install Java on your machine. Once you installed Java on your machine, you would need to set environment variables to point to correct installation directories:', ''),
(6, 'Setting up the path for windows:', 'Assuming you have installed Java in <i>c:Program Filesjavajdk</i> directory: <li><p>Right-click on My Computer and select Properties.</p></li> <li><p>Click on the Environment variables button under the Advanced tab.</p></li> <li><p>Now, alter the Path variable so that it also contains the path to the Java executable. Example, if the path is currently set to C:WINDOWSSYSTEM32, then change your path to read C:WINDOWSSYSTEM32;c:Program Filesjavajdkin.</p></li> ', ''),
(7, 'Setting up the path for Linux, UNIX, Solaris, FreeBSD:', 'Environment variable PATH should be set to point to where the Java binaries have been installed. Refer to your shell documentation if you have trouble doing this.Example, if you use <i>bash</i> as your shell, then you would add the following line to the end of your .bashrc: export PATH=/path/to/java:$PATH', ''),
(8, 'Popular Java Editors:', 'To write your Java programs, you will need a text editor. There are even more sophisticated IDEs available in the market. But for now, you can consider one of the following: <li><p><b>Notepad:</b> On Windows machine you can use any simple text editor like Notepad (Recommended for this tutorial), TextPad.</p></li> <li><p><b>Netbeans:</b> is a Java IDE that is open-source and free which can be downloaded from <a href="http://www.netbeans.org/index.html" target="_blank">http://www.netbeans.org/index.html</a>.</p></li> <li><p><b>Eclipse:</b> is also a Java IDE developed by the eclipse open-source community and can be downloaded from <a href="http://www.eclipse.org/" target="_blank">http://www.eclipse.org/</a>.</p></li> ', ''),
(9, 'Java - Basic Syntax', 'When we consider a Java program it can be defined as a collection of objects that communicate via invoking each others methods. Let us now briefly look into what do class, object, methods and instance variables mean. <li><p><b>Object -</b> Objects have states and behaviours. Example: A dog has states - colour, name, breed as well as behaviours -wagging, barking, eating. An object is an instance of a class. </p></li> <li><p><b>Class -</b> A class can be defined as a template/ blue print that describes the behaviours/states that object of its type support.</p></li> <li><p><b>Methods -</b> A method is basically a behaviour. A class can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.</p></li> <li><p><b>Instance Variables -</b> Each object has its unique set of instance variables. An objects state is created by the values assigned to these instance variables.</p></li> ', ''),
(10, 'First Java Program:', 'Let us look at a simple code that would print the words <i>Hello World</i>.Lets look at how to save the file, compile and run the program. Please follow the steps given below: <li><p>Open notepad and add the code as above.</p></li> <li><p>Save the file as: MyFirstJavaProgram.java.</p></li> <li><p>Open a command prompt window and go to the directory where you saved the 	class. Assume its C:.</p></li> <li><p>Type  javac MyFirstJavaProgram.java and press enter to compile your code. If there are no errors in your code, the command prompt will take you to the next line (Assumption : The path variable is set).</p></li> <li><p>Now, type  java MyFirstJavaProgram  to run your program.</p></li>	 <li><p>You will be able to see  Hello World  printed on the window.</p></li> ', '<br><code><pre class="prettyprint notranslate tryit"> public class MyFirstJavaProgram {     /* This is my first java program.       * This will print Hello World as the output     */ 	     public static void main(String []args) {        System.out.println("Hello World"); // prints Hello World     } }  </pre></code><br><br><code><pre class="result notranslate"> C:&gt; javac MyFirstJavaProgram.java C:&gt; java MyFirstJavaProgram  Hello World </pre></code><br>'),
(11, 'Basic Syntax:', 'About Java programs, it is very important to keep in mind the following points. <li><p><b>Case Sensitivity - </b> Java is case sensitive, which means identifier <b>Hello</b> and <b>hello</b> would have different meaning in Java.</p></li> <li><p><b>Class Names - </b> For all class names the first letter should be in Upper Case. <br /><br /> If several words are used to form a name of the class, each inner words first letter should be in Upper Case.<br /><br /> Example <i>class MyFirstJavaClass </i></p></li> <li><p><b>Method Names - </b> All method names should start with a Lower Case letter.  <br /><br /> If several words are  used to form the name of the method, then each inner words first letter should be in Upper Case.<br /><br /> Example <i>public void myMethodName()</i></p></li> <li><p><b>Program File Name - </b> Name of the program file should exactly match the class name.  <br /><br /> When saving the file, you should save it using the class name (Remember Java is case sensitive) and append .java to the end of the name (if the file name and the class name do not match your program will not compile).<br /><br /> Example: Assume MyFirstJavaProgram is the class  name. Then the file should be saved as <i>MyFirstJavaProgram.java</i></p></li> <li><p><b>public static void main(String args[]) -</b> Java program processing starts from the main() method which is a mandatory part of every Java program.</p></li> ', ''),
(12, 'Java Identifiers:', 'All Java components require names. Names used for classes, variables and methods are called identifiers.In Java, there are several points to remember about identifiers. They are as follows: <li><p>All identifiers should begin with a letter (A to Z or a to z), currency character ($) or an underscore (_).</p></li> <li><p>After the first character identifiers can have any combination of characters.</p></li> <li><p>A key word cannot be used as an identifier.</p></li> <li><p>Most importantly identifiers are case sensitive.</p></li> <li><p>Examples of legal identifiers: age, $salary, _value,  __1_value</p></li> <li><p>Examples of illegal identifiers: 123abc, -salary</p></li> ', ''),
(13, 'Java Modifiers:', 'Like other languages, it is possible to modify classes, methods, etc., by using modifiers. There are two categories of modifiers: <li><p><b>Access Modifiers: </b> default, public , protected, private</p></li> <li><p><b>Non-access Modifiers: </b> final, abstract, strictfp</p></li> We will be looking into more details about modifiers in the next section.', ''),
(14, 'Java Variables:', 'We would see following type of variables in Java: <li>Local Variables</li> <li>Class Variables (Static Variables)</li> <li>Instance Variables (Non-static variables)</li> ', ''),
(15, 'Java Arrays:', 'Arrays are objects that store multiple variables of the same type. However, an array itself is an object on the heap. We will look into how to declare, construct and initialize in the upcoming chapters.', ''),
(16, 'Java Enums:', 'Enums were introduced in java 5.0. Enums restrict a variable to have one of only a few predefined values. The values in this enumerated list are called enums.With the use of enums it is possible to reduce the number of bugs in your code. For example, if we consider an application for a fresh juice shop, it would be possible to restrict the glass size to small, medium and large. This would make sure that it would not allow anyone to order any size other than the small, medium or large.', ''),
(17, 'Example:', 'Above example will produce the following result:<b>Note:</b> enums can be declared as their own or inside a class. Methods, variables, constructors can be defined inside enums as well.', '<br><code><pre class="prettyprint notranslate tryit"> class FreshJuice {     enum FreshJuiceSize{ SMALL, MEDIUM, LARGE }    FreshJuiceSize size; }  public class FreshJuiceTest {     public static void main(String args[]){       FreshJuice juice = new FreshJuice();       juice.size = FreshJuice.FreshJuiceSize.MEDIUM ;       System.out.println("Size: " + juice.size);    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Size: MEDIUM </pre></code><br>'),
(18, 'Java Keywords:', 'The following list shows the reserved words in Java. These reserved words may not be used as constant or variable or any other identifier names.', ''),
(19, 'Comments in Java', 'Java supports single-line and multi-line comments very similar to c and c++. All characters available inside any comment are ignored by Java compiler.', '<br><code><pre class="prettyprint notranslate tryit"> public class MyFirstJavaProgram{     /* This is my first java program.     * This will print Hello World as the output     * This is an example of multi-line comments.     */      public static void main(String []args){        // This is an example of single line comment        /* This is also an example of single line comment. */        System.out.println("Hello World");      } }  </pre></code><br>'),
(20, 'Using Blank Lines:', 'A line containing only white space, possibly with a comment, is known as a blank line, and Java totally ignores it.', ''),
(21, 'Inheritance:', 'In Java, classes can be derived from classes.  Basically if you need to create a new class and here is already a class that has some of the code you require, then it is possible to derive your new class from the already existing code. This concept allows you to reuse the fields and methods of the existing class without having to rewrite the code in a new class. In this scenario the existing class is called the superclass and the derived class is called the subclass.', ''),
(22, 'Interfaces:', 'In Java language, an interface can be defined as a contract between objects on how to communicate with each other. Interfaces play a vital role when it comes to the concept of inheritance.An interface defines the methods, a deriving class(subclass) should use. But the implementation of the methods is totally up to the subclass.', ''),
(23, 'Java - Object &amp; Classes', 'Java is an Object-Oriented Language. As a language that has the Object Oriented feature, Java supports the following fundamental concepts: <li>Polymorphism</li> <li>Inheritance</li> <li>Encapsulation</li> <li>Abstraction</li> <li>Classes</li> <li>Objects</li> <li>Instance</li> <li>Method</li> <li>Message Parsing</li> In this chapter, we will look into the concepts Classes and Objects. <li><p><b>Object -</b> Objects have states and behaviors. Example: A dog has states - color, name, breed as well as behaviors -wagging, barking, eating. An object is an instance of a class. </p></li> <li><p><b>Class -</b> A class can be defined as a template/blue print that describes the behaviors/states that object of its type support.</p></li> ', ''),
(24, 'Objects in Java:', 'Let us now look deep into what are objects. If we consider the real-world we can find many objects around us, Cars, Dogs, Humans, etc. All these objects have a state and behavior.If we consider a dog, then its state is - name, breed, color, and the behavior is - barking, wagging, runningIf you compare the software object with a real world object, they have very similar characteristics.Software objects also have a state and behavior. A software objects state is stored in fields and behavior is shown via methods.So in software development, methods operate on the internal state of an object and the object-to-object communication is done via methods.', ''),
(25, 'Classes in Java:', 'A class is a blue print from which individual objects are created.A sample of a class is given below:A class can contain any of the following variable types. <li><p><b>Local variables: </b>Variables defined inside methods, constructors or blocks are called local variables. The variable will be declared and initialized within the method and the variable will be destroyed when the method has completed.</p></li> <li><p><b>Instance variables: </b>Instance variables are variables within a class but outside any method. These variables are initialized when the class is instantiated. Instance variables can be accessed from inside any method, constructor or blocks of that particular class.</p></li> <li><p><b>Class variables: </b>Class variables are variables declared with in a class, outside any method, with the static keyword.</p></li> A class can have any number of methods to access the value of various kinds of methods. In the above example, barking(), hungry() and sleeping() are methods.Below mentioned are some of the important topics that need to be discussed when looking into classes of the Java Language.', '<br><code><pre class="prettyprint notranslate"> public class Dog{    String breed;    int ageC    String color;     void barking(){    }        void hungry(){    }        void sleeping(){    } } </pre></code><br>'),
(26, 'Constructors:', 'When discussing about classes, one of the most important sub topic would be constructors. Every class has a constructor. If we do not explicitly write a constructor for a class the Java compiler builds a default constructor for that class.Each time a new object is created, at least one constructor will be invoked. The main rule of constructors is that they should have the same name as the class. A class can have more than one constructor.Example of a constructor is given below:Java also supports <a href="/java/java_using_singleton.htm">Singleton Classes</a> where you would be able to create only one instance of a class.<b>Note: </b>We have two different types of constructors we are going to discuss constructors in detail in coming chapters.', '<br><code><pre class="prettyprint notranslate"> public class Puppy{    public Puppy(){    }     public Puppy(String name){       // This constructor has one parameter, <i>name</i>.    } } </pre></code><br>'),
(27, 'Creating an Object:', 'As mentioned previously, a class provides the blueprints for objects. So basically an object is created from a class. In Java, the new key word is used to create new objects. There are three steps when creating an object from a class: <li><p><b>Declaration: </b>A variable declaration with a variable name with an object type.</p></li> <li><p><b>Instantiation: </b>The new key word is used to create the object.</p></li> <li><p><b>Initialization: </b>The new keyword is followed by a call to a constructor. This call initializes the new object.</p></li> Example of creating an object is given below:If we compile and run the above program, then it would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class Puppy{     public Puppy(String name){       // This constructor has one parameter, <i>name</i>.       System.out.println("Passed Name is :" + name );     }        public static void main(String []args){       // Following statement would create an object myPuppy       Puppy myPuppy = new Puppy( "tommy" );    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Passed Name is :tommy </pre></code><br>'),
(28, 'Accessing Instance Variables and Methods:', 'Instance variables and methods are accessed via created objects. To access an instance variable the fully qualified path should be as follows:', '<br><code><pre class="prettyprint notranslate"> /* First create an object */ ObjectReference = new Constructor();  /* Now call a variable as follows */ ObjectReference.variableName;  /* Now you can call a class method as follows */ ObjectReference.MethodName(); </pre></code><br>'),
(29, 'Example:', 'This example explains how to access instance variables and methods of a class:If we compile and run the above program, then it would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class Puppy{        int puppyAge;     public Puppy(String name){       // This constructor has one parameter, <i>name</i>.       System.out.println("Name chosen is :" + name );     }        public void setAge( int age ){        puppyAge = age;    }     public int getAge( ){        System.out.println("Puppys age is :" + puppyAge );         return puppyAge;    }        public static void main(String []args){       /* Object creation */       Puppy myPuppy = new Puppy( "tommy" );        /* Call class method to set puppys age */       myPuppy.setAge( 2 );        /* Call another class method to get puppys age */       myPuppy.getAge( );        /* You can access instance variable as follows as well */       System.out.println("Variable Value :" + myPuppy.puppyAge );     } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Name chosen is :tommy Puppys age is :2 Variable Value :2 </pre></code><br>'),
(30, 'Source file declaration rules:', 'As the last part of this section lets now look into the source file declaration rules. These rules are essential when declaring classes, <i>import</i> statements and <i>package</i> statements in a source file. <li><p>There can be only one public class per source file.</p></li> <li><p>A source file can have multiple non public classes.</p></li> <li><p>The public class name should be the name of the source file as well which should be appended by <b>.java</b> at the end. For example: the class name is <i>public class Employee{}</i> then the source file should be as Employee.java.</p></li> <li><p>If the class is defined inside a package, then the package statement should be the first statement in the source file.</p></li> <li><p>If import statements are present then they must be written between the package statement and the class declaration. If there are no package statements then the import statement should be the first line in the source file. </p></li> <li><p>Import and package statements will imply to all the classes present in the source file. It is not possible to declare different import and/or package statements to different classes in the source file.</p></li> Classes have several access levels and there are different types of classes; abstract classes, final classes, etc. we will be explaining about all these in the access modifiers chapter.Apart from the above mentioned types of classes, Java also has some special classes called Inner classes and Anonymous classes.', ''),
(31, 'Java Package:', 'In simple, it is a way of categorizing the classes and interfaces. When developing applications in Java,  hundreds of classes and interfaces will be written, therefore categorizing these classes is a must as well as makes life much easier.', ''),
(32, 'Import statements:', 'In Java if a fully qualified name, which includes the package and the class name, is given then the compiler can easily locate the source code or classes. Import statement is a way of giving the proper location for the compiler to find that particular class.For example, the following line would ask compiler to load all the classes available in directory java_installation/java/io :', '<br><code><pre class="prettyprint notranslate"> import java.io.*; </pre></code><br>'),
(33, 'A Simple Case Study', 'For our case study, we will be creating two classes. They are Employee and EmployeeTest.First open notepad and add the following code. Remember this is the Employee class and the class is a public class. Now, save this source file with the name Employee.java.The Employee class has four instance variables name, age, designation and salary. The class has one explicitly defined constructor, which takes a parameter.As mentioned previously in this tutorial, processing starts from the main method. Therefore in-order for us to run this Employee class there should be main method and objects should be created. We will be creating a separate class for these tasks.Given below is the <i>EmployeeTest</i> class, which creates two instances of the class Employee and invokes the methods for each object to assign values for each variable.Save the following code in EmployeeTest.java fileNow, compile both the classes and then run <i>EmployeeTest</i> to see the result as follows:', '<br><code><pre class="prettyprint notranslate" id="employee"> import java.io.*;  public class Employee{     String name;    int age;    String designation;    double salary; 	    // This is the constructor of the class Employee    public Employee(String name){       this.name = name;    }    // Assign the age of the Employee  to the variable age.    public void empAge(int empAge){       age =  empAge;    }    /* Assign the designation to the variable designation.*/    public void empDesignation(String empDesig){       designation = empDesig;    }    /* Assign the salary to the variable	salary.*/    public void empSalary(double empSalary){       salary = empSalary;    }    /* Print the Employee details */    public void printEmployee(){       System.out.println("Name:"+ name );       System.out.println("Age:" + age );       System.out.println("Designation:" + designation );       System.out.println("Salary:" + salary);    } } </pre></code><br><br><code><pre class="prettyprint notranslate tryit" title="employee"> import java.io.*;  public class EmployeeTest{     public static void main(String args[]){       /* Create two objects using constructor */       Employee empOne = new Employee("James Smith");       Employee empTwo = new Employee("Mary Anne");        // Invoking methods for each object created       empOne.empAge(26);       empOne.empDesignation("Senior Software Engineer");       empOne.empSalary(1000);       empOne.printEmployee();        empTwo.empAge(21);       empTwo.empDesignation("Software Engineer");       empTwo.empSalary(500);       empTwo.printEmployee();    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> C:&gt; javac Employee.java C:&gt; javac EmployeeTest.java C:&gt; java EmployeeTest Name:James Smith Age:26 Designation:Senior Software Engineer Salary:1000.0 Name:Mary Anne Age:21 Designation:Software Engineer Salary:500.0 </pre></code><br>'),
(34, 'Java - Basic Datatypes', 'Variables are nothing but reserved memory locations to store values. This means that when you create a variable you reserve some space in memory.Based on the data type of a variable, the operating system allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to variables, you can store integers, decimals, or characters in these variables.There are two data types available in Java: <li><p>Primitive Data Types</p></li> <li><p>Reference/Object Data Types</p></li> ', ''),
(35, 'Primitive Data Types:', 'There are eight primitive data types supported by Java. Primitive data types are predefined by the language and named by a keyword. Let us now look into detail about the eight primitive data types.', ''),
(36, 'byte:', ' <li><p>Byte data type is an 8-bit signed twos complement integer.</p></li> <li><p>Minimum value is -128 (-2^7)</p></li> <li><p>Maximum value is 127 (inclusive)(2^7 -1)</p></li> <li><p>Default value is 0</p></li> <li><p>Byte data type is used to save space in large arrays, mainly in place of integers, since a byte is four times smaller than an int.</p></li> <li><p>Example:  byte a = 100 , byte b = -50</p></li> ', ''),
(37, 'short:', ' <li><p>Short data type is a 16-bit signed twos complement integer. </p></li> <li><p>Minimum value is -32,768 (-2^15)</p></li> <li><p>Maximum value is 32,767 (inclusive) (2^15 -1)</p></li> <li><p>Short data type can also be used to save memory as byte data type. A short is 2 times smaller than an int</p></li> <li><p>Default value is 0.</p></li> <li><p>Example: short  s = 10000, short r = -20000</p></li> ', ''),
(38, 'int:', ' <li><p>Int data type is a 32-bit signed twos complement integer.</p></li> <li><p>Minimum value is - 2,147,483,648.(-2^31)</p></li> <li><p>Maximum value is 2,147,483,647(inclusive).(2^31 -1)</p></li> <li><p>Int is generally used as the default data type for integral values unless there is a concern about memory.</p></li> <li><p>The default value is 0.</p></li> <li><p>Example: int a = 100000, int b = -200000</p></li> ', ''),
(39, 'long:', ' <li><p>Long data type is a 64-bit signed twos complement integer. </p></li> <li><p>Minimum value is -9,223,372,036,854,775,808.(-2^63)</p></li> <li><p>Maximum value is 9,223,372,036,854,775,807 (inclusive). (2^63 -1)</p></li> <li><p>This type is used when a wider range than int is needed.</p></li> <li><p>Default value is 0L.</p></li> <li><p>Example: long a = 100000L, long b = -200000L</p></li> ', ''),
(40, 'float:', ' <li><p>Float data type is a single-precision 32-bit IEEE 754 floating point. </p></li> <li><p>Float is mainly used to save memory in large arrays of floating point numbers.</p></li> <li><p>Default value is 0.0f.</p></li> <li><p>Float data type is never used for precise values such as currency. </p></li> <li><p>Example: float f1 = 234.5f</p></li> ', ''),
(41, 'double:', ' <li><p>double data type is a double-precision 64-bit IEEE 754 floating point.</p></li>  <li><p>This data type is generally used as the default data type for decimal values, generally the default choice. </p></li> <li><p>Double data type should never be used for precise values such as currency.</p></li> <li><p>Default value is 0.0d.</p></li> <li><p>Example: double d1 = 123.4</p></li> ', ''),
(42, 'boolean:', ' <li><p>boolean data type represents one bit of information.</p></li> <li><p>There are only two possible values: true and false.</p></li> <li><p>This data type is used for simple flags that track true/false conditions.</p></li> <li><p>Default value is false.</p></li> <li><p>Example: boolean one = true</p></li> ', ''),
(43, 'char:', ' <li><p>char data type is a single 16-bit Unicode character. </p></li> <li><p>Minimum value is u0000 (or 0).</p></li> <li><p>Maximum value is  uffff (or 65,535 inclusive).</p></li> <li><p>Char data type is used to store any character.</p></li>  <li><p>Example: char letterA =A</p></li> ', ''),
(44, 'Reference Data Types:', ' <li><p>Reference variables are created using defined constructors of the classes. They are used to access objects. These variables are declared to be of a specific type that cannot be changed. For example, Employee, Puppy etc.</p></li>  <li><p>Class objects, and various type of array variables come under reference data type.</p></li> <li><p>Default value of any reference variable is null.</p></li>  <li><p>A reference variable can be used to refer to any object of the declared type or any compatible type.</p></li>  <li><p>Example: Animal animal = new Animal("giraffe");</p></li>  ', ''),
(45, 'Java Literals:', 'A literal is a source code representation of a fixed value. They are represented directly in the code without any computation.Literals can be assigned to any primitive type variable. For example:byte, int, long, and short can be expressed in decimal(base 10), hexadecimal(base 16) or octal(base 8) number systems as well.Prefix 0 is used to indicate octal and prefix 0x indicates hexadecimal when using these number systems for literals. For example:String literals in Java are specified like they are in most other languages by enclosing a sequence of characters between a pair of double quotes. Examples of string literals are:String and char types of literals can contain any Unicode characters. For example:Java language supports few special escape sequences for String and char literals as well. They are:', '<br><code><pre class="prettyprint notranslate"> byte a = 68; char a = A </pre></code><br><br><code><pre class="prettyprint notranslate"> int decimal = 100; int octal = 0144; int hexa =  0x64; </pre></code><br><br><code><pre class="prettyprint notranslate"> "Hello World" "two\nlines" ""This is in quotes"" </pre></code><br><br><code><pre class="prettyprint notranslate"> char a = u0001; String a = "u0001"; </pre></code><br>'),
(46, 'Java - Variable Types', 'A variable provides us with named storage that our programs can manipulate. Each variable in Java has a specific type, which determines the size and layout of the variables memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.You must declare all variables before they can be used. The basic form of a variable declaration is shown here:Here <i>data type</i> is one of Javas datatypes and <i>variable</i> is the name of the variable. To declare more than one variable of the specified type, you can use a comma-separated list.Following are valid examples of variable declaration and initialization in Java:This chapter will explain various variable types available in Java Language. There are three kinds of variables in Java: <li><p>Local variables </p></li> <li><p>Instance variables </p></li> <li><p>Class/static variables</p></li> ', '<br><code><pre class="prettyprint notranslate"> data type variable [ = value][, variable [= value] ...] ; </pre></code><br><br><code><pre class="prettyprint notranslate"> int a, b, c;         // Declares three ints, a, b, and c. int a = 10, b = 10;  // Example of initialization byte B = 22;         // initializes a byte type variable B. double pi = 3.14159; // declares and assigns a value of PI. char a = a;        // the char variable a iis initialized with value a </pre></code><br>'),
(47, 'Local variables:', ' <li><p>Local variables are declared in methods, constructors, or blocks.</p></li> <li><p>Local variables are created when the method, constructor or block is entered and the variable will be destroyed once it exits the method, constructor or block.</p></li> <li><p>Access modifiers cannot be used for local variables.</p></li> <li><p>Local variables are visible only within the declared method, constructor or block.</p></li> <li><p>Local variables are implemented at stack level internally.</p></li> <li><p>There is no default value for local variables so local variables should be declared and an initial value should be assigned before the first use.</p></li> ', ''),
(48, 'Example:', 'Here, <i>age</i> is a local variable. This is defined inside <i>pupAge()</i> method and its scope is limited to this method only.This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class Test{     public void pupAge(){       int age = 0;       age = age + 7;       System.out.println("Puppy age is : " + age);    }        public static void main(String args[]){       Test test = new Test();       test.pupAge();    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Puppy age is: 7 </pre></code><br>'),
(49, 'Example:', 'Following example uses <i>age</i> without initializing it, so it would give an error at the time of compilation.This would produce the following error while compiling it:', '<br><code><pre class="prettyprint notranslate tryit"> public class Test{     public void pupAge(){       int age;       age = age + 7;       System.out.println("Puppy age is : " + age);    }        public static void main(String args[]){       Test test = new Test();       test.pupAge();    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Test.java:4:variable number might not have been initialized age = age + 7;          ^ 1 error </pre></code><br>'),
(50, 'Instance variables:', ' <li><p>Instance variables are declared in a class, but outside a method, constructor or any block.</p></li> <li><p>When a space is allocated for an object in the heap, a slot for each instance variable value is created.</p></li> <li><p>Instance variables are created when an object is created with the use of the keyword new and destroyed when the object is destroyed.</p></li> <li><p>Instance variables hold values that must be referenced by more than one method, constructor or block, or essential parts of an objects state that must be present throughout the class.</p></li> <li><p>Instance variables can be declared in class level before or after use.</p></li> <li><p>Access modifiers can be given for instance variables.</p></li> <li><p>The instance variables are visible for all methods, constructors and block in the class. Normally, it is recommended to make these variables private (access level). However visibility for subclasses can be given for these variables with the use of access modifiers.</p></li> <li><p>Instance variables have default values. For numbers the default value is 0, for Booleans it is false and for object references it is null. Values can be assigned during the declaration or within the constructor.</p></li> <li><p>Instance variables can be accessed directly by calling the variable name inside the class. However within static methods and different class ( when instance variables are given accessibility) should be called using the fully qualified name . <i>ObjectReference.VariableName</i>.</p></li> ', ''),
(51, 'Example:', 'This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.io.*;  public class Employee{    // this instance variable is visible for any child class.    public String name;        // salary  variable is visible in Employee class only.    private double salary;        // The name variable is assigned in the constructor.     public Employee (String empName){       name = empName;    }     // The salary variable is assigned a value.    public void setSalary(double empSal){       salary = empSal;    }        // This method prints the employee details.    public void printEmp(){       System.out.println("name  : " + name );       System.out.println("salary :" + salary);    }     public static void main(String args[]){       Employee empOne = new Employee("Ransika");       empOne.setSalary(1000);       empOne.printEmp();    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> name  : Ransika salary :1000.0 </pre></code><br>'),
(52, 'Class/static variables:', ' <li><p>Class variables also known as static variables are declared with the <i>static</i> keyword in a class, but outside a method, constructor or a block. </p></li> <li><p>There would only be one copy of each class variable per class, regardless of how many objects are created from it.</p></li> <li><p>Static variables are rarely used other than being declared as constants. Constants are variables that are declared as public/private, final and static. Constant variables never change from their initial value.</p></li> <li><p>Static variables are stored in static memory. It is rare to use static variables other than declared final and used as either public or private constants.</p></li> <li><p>Static variables are created when the program starts and destroyed when the program stops.</p></li> <li><p>Visibility is similar to instance variables. However, most static variables are declared public since they must be available for users of the class.</p></li> <li><p>Default values are same as instance variables. For numbers, the default value is 0; for Booleans, it is false; and for object references, it is null. Values can be assigned during the declaration or within the constructor. Additionally values can be assigned in special static initializer blocks.</p></li> <li><p>Static variables can be accessed by calling with the class name <i>ClassName.VariableName</i>.</p></li> <li><p>When declaring class variables as public static final, then variables names (constants) are all in upper case. If the static variables are not public and final the naming syntax is the same as instance and local variables.</p></li> ', ''),
(53, 'Example:', 'This would produce the following result:<b>Note:</b> If the variables are access from an outside class the constant should be accessed as Employee.DEPARTMENT', '<br><code><pre class="prettyprint notranslate tryit"> import java.io.*;  public class Employee{    // salary  variable is a private static variable    private static double salary;     // DEPARTMENT is a constant    public static final String DEPARTMENT = "Development ";     public static void main(String args[]){       salary = 1000;       System.out.println(DEPARTMENT + "average salary:" + salary);    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Development average salary:1000 </pre></code><br>'),
(54, 'Java - Modifier Types', 'Modifiers are keywords that you add to those definitions to change their meanings. The Java language has a wide variety of modifiers, including the following: <li><p><a href="/java/java_access_modifiers.htm"> Java Access Modifiers</a></p></li> <li><p><a href="/java/java_nonaccess_modifiers.htm">Non Access Modifiers</a></p></li> To use a modifier, you include its keyword in the definition of a class, method, or variable. The modifier precedes the rest of the statement, as in the following examples (Italic ones) &minus;', '<br><code><pre class="prettyprint notranslate"> <i>public</i> class className {    // ... } <i>private</i> boolean myFlag; <i>static final</i> double weeks = 9.5; <i>protected static final</i> int BOXWIDTH = 42; <i>public static</i> void main(String[] arguments) {    // body of method } </pre></code><br>'),
(55, 'Access Control Modifiers:', 'Java provides a number of access modifiers to set access levels for classes, variables, methods and constructors. The four access levels are: <li><p>Visible to the package, the default. No modifiers are needed.</p></li> <li><p>Visible to the class only (private).</p></li> <li><p>Visible to the world (public).</p></li> <li><p>Visible to the package and all subclasses (protected).</p></li> ', ''),
(56, 'Non Access Modifiers:', 'Java provides a number of non-access modifiers to achieve many other functionality. <li><p>The <i>static</i> modifier for creating class methods and variables</p></li> <li><p>The <i>final</i> modifier for finalizing the implementations of classes, methods, and variables.</p></li> <li><p>The <i>abstract</i> modifier for creating abstract classes and methods.</p></li> <li><p>The <i>synchronized</i> and <i>volatile</i> modifiers, which are used for threads.</p></li> ', ''),
(57, 'Java - Basic Operators', 'Java provides a rich set of operators to manipulate variables. We can divide all the Java operators into the following groups: <li><p>Arithmetic Operators</p></li> <li><p>Relational Operators</p></li> <li><p>Bitwise Operators</p></li> <li><p>Logical Operators</p></li> <li><p>Assignment Operators</p></li> <li><p>Misc Operators</p></li> ', ''),
(58, 'The Arithmetic Operators:', 'Arithmetic operators are used in mathematical expressions in the same way that they are used in algebra. The following table lists the arithmetic operators:Assume integer variable A holds 10 and variable B holds 20, then:<a href="/java/java_arithmatic_operators_examples.htm">Show Examples</a>', ''),
(59, 'The Relational Operators:', 'There are following relational operators supported by Java languageAssume variable A holds 10 and variable B holds 20, then:<a href="/java/java_relational_operators_examples.htm">Show Examples</a>', ''),
(60, 'The Bitwise Operators:', 'Java defines several bitwise operators, which can be applied to the integer types, long, int, short, char, and byte.Bitwise operator works on bits and performs bit-by-bit operation. Assume if a = 60; and b = 13; now in binary format they will be as follows:a = 0011 1100b = 0000 1101-----------------a&amp;b = 0000 1100a|b = 0011 1101a^b = 0011 0001~a&nbsp; = 1100 0011The following table lists the bitwise operators:Assume integer variable A holds 60 and variable B holds 13 then:<a href="/java/java_bitwise_operators_examples.htm">Show Examples</a>', ''),
(61, 'The Logical Operators:', 'The following table lists the logical operators:Assume Boolean variables A holds true and variable B holds false, then:<a href="/java/java_logical_operators_examples.htm">Show Examples</a>', ''),
(62, 'The Assignment Operators:', 'There are following assignment operators supported by Java language:<a href="/java/java_assignment_operators_examples.htm">Show Examples</a>', ''),
(63, 'Miscellaneous Operators', 'There are few other operators supported by Java Language.', ''),
(64, 'Conditional Operator ( ? : )', 'Conditional operator is also known as the ternary operator. This operator consists of three operands and is used to evaluate Boolean expressions. The goal of the operator is to decide which value should be assigned to the variable. The operator is written as:Following is the example:This would produce the following result &minus;', '<br><code><pre class="prettyprint notranslate"> variable x = (expression) ? value if true : value if false </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> public class Test {     public static void main(String args[]){       int a, b;       a = 10;       b = (a == 1) ? 20: 30;       System.out.println( "Value of b is : " +  b );        b = (a == 10) ? 20: 30;       System.out.println( "Value of b is : " + b );    } } </pre></code><br><br><code><pre class="result notranslate"> Value of b is : 30 Value of b is : 20 </pre></code><br>'),
(65, 'instance of Operator:', 'This operator is used only for object reference variables. The operator checks whether the object is of a particular type (class type or interface type).  instanceof operator is written as:If the object referred by the variable on the left side of the operator passes the IS-A check for the class/interface type on the right side, then the result will be true. Following is the example:This would produce the following result:This operator will still return true if the object being compared is the assignment compatible with the type on the right. Following is one more example:This would produce the following result:', '<br><code><pre class="prettyprint notranslate"> ( Object reference variable ) instanceof  (class/interface type) </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> public class Test {     public static void main(String args[]){       String name = "James";       // following will return true since name is type of String       boolean result = name instanceof String;         System.out.println( result );    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> true </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> class Vehicle {}  public class Car extends Vehicle {    public static void main(String args[]){       Vehicle a = new Car();       boolean result =  a instanceof Car;       System.out.println( result );    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> true </pre></code><br>'),
(66, 'Precedence of Java Operators:', 'Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator:For example, x = 7 + 3 * 2; here  x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.', ''),
(67, 'Java - Loop Control', ' There may be a situation when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.Programming languages provide various control structures that allow for more complicated execution paths.A <b>loop</b> statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages:Java programming language provides the following types of loop to handle looping requirements. Click the following links to check their detail.', ''),
(68, 'Loop Control Statements:', 'Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.Java supports the following control statements. Click the following links to check their detail.', ''),
(69, 'Enhanced for loop in Java:', 'As of Java 5, the enhanced for loop was introduced. This is mainly used to traverse collection of elements including arrays.', '');
INSERT INTO `text` (`textid`, `topic`, `content`, `code`) VALUES
(70, 'Syntax:', 'The syntax of enhanced for loop is: <li><p><b>Declaration:</b> The newly declared block variable, which is of a type compatible with the elements of the array you are accessing. The variable will be available within the for block and its value would be the same as the current array element.</p></li> <li><p><b>Expression:</b> This evaluates to the array you need to loop through. The expression can be an array variable or method call that returns an array.</p></li> ', '<br><code><pre class="prettyprint notranslate"> for(declaration : expression) {    //Statements } </pre></code><br>'),
(71, 'Example:', 'This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class Test {     public static void main(String args[]){       int [] numbers = {10, 20, 30, 40, 50};        for(int x : numbers ){          System.out.print( x );          System.out.print(",");       }       System.out.print("\n");       String [] names ={"James", "Larry", "Tom", "Lacy"};       for( String name : names ) {          System.out.print( name );          System.out.print(",");       }    } } </pre></code><br><br><code><pre class="result notranslate"> 10,20,30,40,50, James,Larry,Tom,Lacy, </pre></code><br>'),
(72, 'Java - Decision Making', 'Decision making structures have one or more conditions to be evaluated or tested by the program, along with a statement or statements that are to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.Following is the general form of a typical decision making structure found in most of the programming languages:Java programming language provides following types of decision making statements. Click the following links to check their detail.', ''),
(73, 'The ? : Operator:', 'We have covered <b>conditional operator ? :</b> in previous chapter which can be used to replace <b>if...else</b> statements. It has the following general form:Where Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the colon.To determine the value of whole expression, initially exp1 is evaluated  <li>If the value of exp1 is true, then the value of Exp2 will be the value of the whole expression. </li> <li>If the value of exp1 is false, then Exp3 is evaluated and its value becomes the value of the entire expression.</li>', '<br><code><pre class="prettyprint notranslate"> Exp1 ? Exp2 : Exp3; </pre></code><br>'),
(74, 'Java - Numbers Class', 'Normally, when we work with Numbers, we use primitive data  types  such as  byte, int, long, double, etc.', ''),
(75, 'Example:', 'However, in development, we come across situations where we need to use objects instead of primitive data types. In-order to achieve this Java provides <b>wrapper classes</b> All the wrapper classes (Integer, Long, Byte, Double, Float, Short) are subclasses of the abstract class Number. <img src="/java/images/number_classes.jpg" alt="Number Subclasses" /> The object of the wrapper class contains or wraps its respective primitive data type. converting primitive data types into object is called boxing, and this is taken care by the compiler. therefore while using a wrapper class you just need to pass the value of the primitive data type to the constructor of the Wrapper class. And  the Wrapper object will be converted back to a primitive data type, and this process is called un boxing. The <b>Number</b> class is part of the java.lang package.Here is an example of boxing and unboxing:This would produce the following result:When x is assigned integer value, the compiler boxes the integer because x is integer object. Later, x is unboxed so that they can be added as integer.', '<br><code><pre class="prettyprint notranslate"> int i = 5000; float gpa = 13.65; byte mask = 0xaf; </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> public class Test{     public static void main(String args[]){       Integer x = 5; // boxes int to an Integer object       x =  x + 10;   // unboxes the Integer to a int       System.out.println(x);     } } </pre></code><br><br><code><pre class="prettyprint notranslate"> 15 </pre></code><br>'),
(76, 'Number Methods:', 'Here is the list of the instance methods that all the subclasses of the Number class implement:', ''),
(77, 'Java - Character Class', 'Normally, when we work with characters, we use primitive data  types char.', ''),
(78, 'Example:', 'However in development, we come across situations where we need to use objects instead of primitive data types. In order to achieve this, Java provides wrapper class <b>Character</b> for  primitive data type char.The Character class offers a number of useful class (i.e., static) methods for manipulating characters. You can create a Character object with the Character constructor:The Java compiler will also create a Character object for you under some circumstances. For example, if you pass a primitive char into a method that expects an object, the compiler automatically converts the char to a Character for you. This feature is called autoboxing or unboxing, if the conversion goes the other way.', '<br><code><pre class="prettyprint notranslate"> char ch = a;  // Unicode for uppercase Greek omega character char uniChar = u039A;   // an array of chars char[] charArray ={ a, b, c, d, e };  </pre></code><br><br><code><pre class="prettyprint notranslate"> Character ch = new Character(a); </pre></code><br>'),
(79, 'Escape Sequences:', 'A character preceded by a backslash () is an escape sequence and has special meaning to the compiler.The newline character (\n) has been used frequently in this tutorial in System.out.println() statements to advance to the next line after the string is printed.Following table shows the Java escape sequences:When an escape sequence is encountered in a print statement, the compiler interprets it accordingly.', ''),
(80, 'Example:', 'If you want to put quotes within quotes you must use the escape sequence, ", on the interior quotes:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class Test {     public static void main(String args[]) {       System.out.println("She said "Hello!" to me.");    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> She said "Hello!" to me. </pre></code><br>'),
(81, 'Character Methods:', 'Here is the list of the important instance methods that all the subclasses of the Character class implement:For a complete list of methods, please refer to the java.lang.Character API specification.', ''),
(82, 'Java - Strings Class', 'Strings, which are widely used in Java programming, are a sequence of characters. In the Java programming language, strings are objects.The Java platform provides the String class to create and manipulate strings.', ''),
(83, 'Creating Strings:', 'The most direct way to create a string is to write:Whenever it encounters a string literal in your code, the compiler creates a String object with its value in this case, "Hello world!.As with any other object, you can create String objects by using the new keyword and a constructor. The String class has eleven constructors that allow you to provide the initial value of the string using different sources, such as an array of characters.This would produce the following result:<b>Note:</b> The String class is immutable, so that once it is created a String object cannot be changed. If there is a necessity to make a lot of modifications to Strings of characters, then you should use <a href="/java/java_string_buffer.htm">String Buffer &amp; String Builder</a> Classes.', '<br><code><pre class="prettyprint notranslate"> String greeting = "Hello world!"; </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> public class StringDemo{     public static void main(String args[]){       char[] helloArray = { h, e, l, l, o, .};       String helloString = new String(helloArray);         System.out.println( helloString );    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> hello. </pre></code><br>'),
(84, 'String Length:', 'Methods used to obtain information about an object are known as accessor methods. One accessor method that you can use with strings is the length() method, which returns the number of characters contained in the string object.Below given program is an example of <b>length()</b> , method String class.This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class StringDemo {     public static void main(String args[]) {       String palindrome = "Dot saw I was Tod";       int len = palindrome.length();       System.out.println( "String Length is : " + len );    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> String Length is : 17 </pre></code><br>'),
(85, 'Concatenating Strings:', 'The String class includes a method for concatenating two strings:This returns a new string that is string1 with string2 added to it at the end. You can also use the concat() method with string literals, as in:Strings are more commonly concatenated with the + operator, as in:which results in:Let us look at the following example:This would produce the following result:', '<br><code><pre class="prettyprint notranslate"> string1.concat(string2); </pre></code><br><br><code><pre class="prettyprint notranslate"> "My name is ".concat("Zara"); </pre></code><br><br><code><pre class="prettyprint notranslate"> "Hello," + " world" + "!" </pre></code><br><br><code><pre class="prettyprint notranslate"> "Hello, world!" </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> public class StringDemo {     public static void main(String args[]) {       String string1 = "saw I was ";       System.out.println("Dot " + string1 + "Tod");    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Dot saw I was Tod </pre></code><br>'),
(86, 'Creating Format Strings:', 'You have printf() and format() methods to print output with formatted numbers. The String class has an equivalent class method, format(), that returns a String object rather than a PrintStream object.Using Strings static format() method allows you to create a formatted string that you can reuse, as opposed to a one-time print statement. For example, instead of:you can write:', '<br><code><pre class="prettyprint notranslate"> System.out.printf("The value of the float variable is " +                   "%f, while the value of the integer " +                   "variable is %d, and the string " +                   "is %s", floatVar, intVar, stringVar); </pre></code><br><br><code><pre class="prettyprint notranslate"> String fs; fs = String.format("The value of the float variable is " +                    "%f, while the value of the integer " +                    "variable is %d, and the string " +                    "is %s", floatVar, intVar, stringVar); System.out.println(fs); </pre></code><br>'),
(87, 'Java - Arrays', 'Java provides a data structure, the <b>array</b>, which stores a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables.This tutorial introduces how to declare array variables, create arrays, and process arrays using indexed variables.', ''),
(88, 'Declaring Array Variables:', 'To use an array in a program, you must declare a variable to reference the array, and you must specify the type of array the variable can reference. Here is the syntax for declaring an array variable:<b>Note:</b> The style <b>dataType[] arrayRefVar</b> is preferred. The style <b>dataType arrayRefVar[]</b> comes from the C/C++ language and was adopted in Java to accommodate C/C++ programmers.', '<br><code><pre class="prettyprint notranslate"> dataType[] arrayRefVar;   // preferred way.  or  dataType arrayRefVar[];  //  works but not preferred way. </pre></code><br>'),
(89, 'Example:', 'The following code snippets are examples of this syntax:', '<br><code><pre class="prettyprint notranslate"> double[] myList;         // preferred way.  or  double myList[];         //  works but not preferred way. </pre></code><br>'),
(90, 'Creating Arrays:', 'You can create an array by using the new operator with the following syntax:The above statement does two things:  <li><p>It creates an array using new dataType[arraySize]; </p></li> <li><p>It assigns the reference of the newly created array to the variable arrayRefVar.</p></li> Declaring an array variable, creating an array, and assigning the reference of the array to the variable can be combined in one statement, as shown below:Alternatively you can create arrays as follows:The array elements are accessed through the <b>index</b>. Array indices are 0-based; that is, they start from 0 to <b>arrayRefVar.length-1</b>.', '<br><code><pre class="prettyprint notranslate"> arrayRefVar = new dataType[arraySize]; </pre></code><br><br><code><pre class="prettyprint notranslate"> dataType[] arrayRefVar = new dataType[arraySize]; </pre></code><br><br><code><pre class="prettyprint notranslate"> dataType[] arrayRefVar = {value0, value1, ..., valuek}; </pre></code><br>'),
(91, 'Example:', 'Following statement declares an array variable, myList, creates an array of 10 elements of double type and assigns its reference to myList:Following picture represents array myList. Here, myList holds ten double values and the indices are from 0 to 9.', '<br><code><pre class="prettyprint notranslate"> double[] myList = new double[10]; </pre></code><br>'),
(92, 'Processing Arrays:', 'When processing array elements, we often use either for loop or foreach loop because all of the elements in an array are of the same type and the size of the array is known.', ''),
(93, 'Example:', 'Here is a complete example of showing how to create, initialize and process arrays:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class TestArray {     public static void main(String[] args) {       double[] myList = {1.9, 2.9, 3.4, 3.5};        // Print all the array elements       for (int i = 0; i &lt; myList.length; i++) {          System.out.println(myList[i] + " ");       }       // Summing all elements       double total = 0;       for (int i = 0; i &lt; myList.length; i++) {          total += myList[i];       }       System.out.println("Total is " + total);       // Finding the largest element       double max = myList[0];       for (int i = 1; i &lt; myList.length; i++) {          if (myList[i] &gt; max) max = myList[i];       }       System.out.println("Max is " + max);    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> 1.9 2.9 3.4 3.5 Total is 11.7 Max is 3.5 </pre></code><br>'),
(94, 'The foreach Loops:', 'JDK 1.5 introduced a new for loop known as foreach loop or enhanced for loop, which enables you to traverse the complete array sequentially without using an index variable. ', ''),
(95, 'Example:', 'The following code displays all the elements in the array myList:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class TestArray {     public static void main(String[] args) {       double[] myList = {1.9, 2.9, 3.4, 3.5};        // Print all the array elements       for (double element: myList) {          System.out.println(element);       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> 1.9 2.9 3.4 3.5 </pre></code><br>'),
(96, 'Passing Arrays to Methods:', 'Just as you can pass primitive type values to methods, you can also pass arrays to methods. For example, the following method displays the elements in an int array:You can invoke it by passing an array. For example, the following statement invokes the printArray method to display 3, 1, 2, 6, 4, and 2:', '<br><code><pre class="prettyprint notranslate"> public static void printArray(int[] array) {   for (int i = 0; i &lt; array.length; i++) {     System.out.print(array[i] + " ");   } } </pre></code><br><br><code><pre class="prettyprint notranslate"> printArray(new int[]{3, 1, 2, 6, 4, 2}); </pre></code><br>'),
(97, 'Returning an Array from a Method:', 'A method may also return an array. For example, the method shown below returns an array that is the reversal of another array:', '<br><code><pre class="prettyprint notranslate"> public static int[] reverse(int[] list) {   int[] result = new int[list.length];    for (int i = 0, j = result.length - 1; i &lt; list.length; i++, j--) {     result[j] = list[i];   }   return result; } </pre></code><br>'),
(98, 'Java - Date &amp; Time', 'Java provides the <b>Date</b> class available in <b>java.util</b> package, this class encapsulates the current date and time.The Date class supports two constructors as shown below.Below given are the methods of the date class.', ''),
(99, 'Getting Current Date &amp; Time', 'This is very easy to get current date and time in Java. You can use a simple Date object with <i>toString() </i> method to print current date and time as follows:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.Date;    public class DateDemo {    public static void main(String args[]) {        // Instantiate a Date object        Date date = new Date();                 // display time and date using toString()        System.out.println(date.toString());    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> on May 04 09:51:52 CDT 2009 </pre></code><br>'),
(100, 'Date Comparison:', 'There are following three ways to compare two dates: <li><p>You can use getTime( ) to obtain the number of milliseconds that have elapsed since midnight, January 1, 1970, for both objects and then compare these two values.</p></li> <li><p>You can use the methods before( ), after( ), and equals( ). Because the 12th of the month comes before the 18th, for example, new Date(99, 2, 12).before(new Date (99, 2, 18)) returns true.</p></li> <li><p>You can use the compareTo( ) method, which is defined by the Comparable interface and implemented by Date.</p></li> ', ''),
(101, 'Date Formatting using SimpleDateFormat:', 'SimpleDateFormat is a concrete class for formatting and parsing dates in a locale-sensitive manner. SimpleDateFormat allows you to start by choosing any user-defined patterns for date-time formatting. For example:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.*; import java.text.*;  public class DateDemo {    public static void main(String args[]) {        Date dNow = new Date( );       SimpleDateFormat ft =        new SimpleDateFormat ("E yyyy.MM.dd at hh:mm:ss a zzz");        System.out.println("Current Date: " + ft.format(dNow));    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Current Date: Sun 2004.07.18 at 04:14:09 PM PDT </pre></code><br>'),
(102, 'Simple DateFormat format codes:', 'To specify the time format, use a time pattern string. In this pattern, all ASCII letters are reserved as pattern letters, which are defined as the following:', ''),
(103, 'Date Formatting using printf:', 'Date and time formatting can be done very easily using <b>printf</b> method. You use a two-letter format, starting with <b>t</b> and ending in one of the letters of the table given below. For example:This would produce the following result:It would be a bit silly if you had to supply the date multiple times to format each part. For that reason, a format string can indicate the index of the argument to be formatted.The index must immediately follow the % and it must be terminated by a $. For example:This would produce the following result:Alternatively, you can use the &lt; flag. It indicates that the same argument as in the preceding format specification should be used again. For example:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.Date;  public class DateDemo {    public static void main(String args[]) {      // Instantiate a Date object      Date date = new Date();       // display time and date using toString()      String str = String.format("Current Date/Time : %tc", date );       System.out.printf(str);   } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Current Date/Time : Sat Dec 15 16:37:57 MST 2012 </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> import java.util.Date;    public class DateDemo {     public static void main(String args[]) {        // Instantiate a Date object        Date date = new Date();                 // display time and date using toString()        System.out.printf("%1$s %2$tB %2$td, %2$tY",                           "Due date:", date);    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Due date: February 09, 2004 </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> import java.util.Date;    public class DateDemo {     public static void main(String args[]) {        // Instantiate a Date object        Date date = new Date();                 // display formatted date        System.out.printf("%s %tB %&lt;te, %&lt;tY",                           "Due date:", date);    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Due date: February 09, 2004 </pre></code><br>'),
(104, 'Date and Time Conversion Characters:', 'There are other useful classes related to Date and time. For more details, you can refer to Java Standard documentation.', ''),
(105, 'Parsing Strings into Dates:', 'The SimpleDateFormat  class has some additional methods, notably parse( ) , which tries to parse a string according to the format stored in the given SimpleDateFormat object. For example:A sample run of the above program would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.*; import java.text.*;    public class DateDemo {     public static void main(String args[]) {       SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd");         String input = args.length == 0 ? "1818-11-11" : args[0];         System.out.print(input + " Parses as ");         Date t;         try {            t = ft.parse(input);            System.out.println(t);        } catch (ParseException e) {            System.out.println("Unparseable using " + ft);        }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> $ java DateDemo 1818-11-11 Parses as Wed Nov 11 00:00:00 GMT 1818 $ java DateDemo 2007-12-01 2007-12-01 Parses as Sat Dec 01 00:00:00 GMT 2007 </pre></code><br>'),
(106, 'Sleeping for a While:', 'You can sleep for any period of time from one millisecond up to the lifetime of your computer. For example, following program would sleep for 10 seconds:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.*;    public class SleepDemo {    public static void main(String args[]) {       try {           System.out.println(new Date( ) + "\n");           Thread.sleep(5*60*10);           System.out.println(new Date( ) + "\n");        } catch (Exception e) {            System.out.println("Got an exception!");        }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Sun May 03 18:04:41 GMT 2009  Sun May 03 18:04:51 GMT 2009 </pre></code><br>'),
(107, 'Measuring Elapsed Time:', 'Sometimes, you may need to measure point in time in milliseconds. So lets re-write above example once again:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.*;    public class DiffDemo {     public static void main(String args[]) {       try {          long start = System.currentTimeMillis( );          System.out.println(new Date( ) + "\n");          Thread.sleep(5*60*10);          System.out.println(new Date( ) + "\n");          long end = System.currentTimeMillis( );          long diff = end - start;          System.out.println("Difference is : " + diff);       } catch (Exception e) {          System.out.println("Got an exception!");       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Sun May 03 18:16:51 GMT 2009  Sun May 03 18:16:57 GMT 2009  Difference is : 5993 </pre></code><br>'),
(108, 'GregorianCalendar Class:', 'GregorianCalendar is a concrete implementation of a Calendar class that implements the normal Gregorian calendar with which you are familiar. I did not discuss Calendar class in this tutorial, you can look standard Java documentation for this.The <b>getInstance( )</b> method of Calendar returns a GregorianCalendar initialized with the current date and time in the default locale and time zone. GregorianCalendar defines two fields: AD and BC. These represent the two eras defined by the Gregorian calendar.There are also several constructors for GregorianCalendar objects:Here is the list of few useful support methods provided by GregorianCalendar class:', ''),
(109, 'Java - Regular Expressions', 'Java provides the java.util.regex package for pattern matching with regular expressions. Java regular expressions are very similar to the Perl programming language and very easy to learn.A regular expression is a special sequence of characters that helps you match or find other strings or sets of strings, using a specialized syntax held in a pattern. They can be used to search, edit, or manipulate text and data. The java.util.regex package primarily consists of the following three classes: <li><p><b>Pattern Class:</b> A Pattern object is a compiled representation of a regular expression. The Pattern class provides no public constructors. To create a pattern, you must first invoke one of its public static <b>compile()</b> methods, which will then return a Pattern object. These methods accept a regular expression as the first argument.</p></li> <li><p><b>Matcher Class:</b> A Matcher object is the engine that interprets the pattern and performs match operations against an input string. Like the Pattern class, Matcher defines no public constructors. You obtain a Matcher object by invoking the <b>matcher()</b> method on a Pattern object.</p></li> <li><p><b>PatternSyntaxException:</b> A PatternSyntaxException object is an unchecked exception that indicates a syntax error in a regular expression pattern.</p></li> ', ''),
(110, 'Capturing Groups:', 'Capturing groups are a way to treat multiple characters as a single unit. They are created by placing the characters to be grouped inside a set of parentheses. For example, the regular expression (dog) creates a single group containing the letters "d", "o", and "g".Capturing groups are numbered by counting their opening parentheses from left to right. In the expression ((A)(B(C))), for example, there are four such groups: <li><p>((A)(B(C)))</p></li> <li><p>(A)</p></li> <li><p>(B(C))</p></li> <li><p>(C)</p></li> To find out how many groups are present in the expression, call the groupCount method on a matcher object. The groupCount method returns an int showing the number of capturing groups present in the matchers pattern.There is also a special group, group 0, which always represents the entire expression. This group is not included in the total reported by groupCount.', ''),
(111, 'Example:', 'Following example illustrates how to find a digit string from the given alphanumeric string:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.regex.Matcher; import java.util.regex.Pattern;  public class RegexMatches {     public static void main( String args[] ){        // String to be scanned to find the pattern.       String line = "This order was placed for QT3000! OK?";       String pattern = "(.*)(\\d+)(.*)";        // Create a Pattern object       Pattern r = Pattern.compile(pattern);        // Now create matcher object.       Matcher m = r.matcher(line);       if (m.find( )) {          System.out.println("Found value: " + m.group(0) );          System.out.println("Found value: " + m.group(1) );          System.out.println("Found value: " + m.group(2) );       } else {          System.out.println("NO MATCH");       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Found value: This order was placed for QT3000! OK? Found value: This order was placed for QT300 Found value: 0 </pre></code><br>'),
(112, 'Regular Expression Syntax:', 'Here is the table listing down all the regular expression metacharacter syntax available in Java:', ''),
(113, 'Methods of the Matcher Class:', 'Here is a list of useful instance methods:', ''),
(114, 'Index Methods:', 'Index methods provide useful index values that show precisely where the match was found in the input string:', ''),
(115, 'Study Methods:', 'Study methods review the input string and return a Boolean indicating whether or not the pattern is found:', ''),
(116, 'Replacement Methods:', 'Replacement methods are useful methods for replacing text in an input string:', ''),
(117, 'The <i>start</i> and <i>end</i> Methods:', 'Following is the example that counts the number of times the word "cat" appears in the input string:This would produce the following result:You can see that this example uses word boundaries to ensure that the letters "c" "a" "t" are not merely a substring in a longer word. It also gives some useful information about where in the input string the match has occurred.The start method returns the start index of the subsequence captured by the given group during the previous match operation, and end returns the index of the last character matched, plus one.', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.regex.Matcher; import java.util.regex.Pattern;  public class RegexMatches {     private static final String REGEX = "\\bcat\\b";     private static final String INPUT =                                     "cat cat cat cattie cat";      public static void main( String args[] ){        Pattern p = Pattern.compile(REGEX);        Matcher m = p.matcher(INPUT); // get a matcher object        int count = 0;         while(m.find()) {          count++;          System.out.println("Match number "+count);          System.out.println("start(): "+m.start());          System.out.println("end(): "+m.end());       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> atch number 1 start(): 0 end(): 3 atch number 2 start(): 4 end(): 7 atch number 3 start(): 8 end(): 11 atch number 4 start(): 19 end(): 22 </pre></code><br>'),
(118, 'The <i>matches</i> and <i>lookingAt</i> Methods:', 'The matches and lookingAt methods both attempt to match an input sequence against a pattern. The difference, however, is that matches requires the entire input sequence to be matched, while lookingAt does not.Both methods always start at the beginning of the input string. Here is the example explaining the functionality:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.regex.Matcher; import java.util.regex.Pattern;  public class RegexMatches {     private static final String REGEX = "foo";     private static final String INPUT = "fooooooooooooooooo";     private static Pattern pattern;     private static Matcher matcher;      public static void main( String args[] ){        pattern = Pattern.compile(REGEX);        matcher = pattern.matcher(INPUT);         System.out.println("Current REGEX is: "+REGEX);        System.out.println("Current INPUT is: "+INPUT);         System.out.println("lookingAt(): "+matcher.lookingAt());        System.out.println("matches(): "+matcher.matches());    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Current REGEX is: foo Current INPUT is: fooooooooooooooooo lookingAt(): true matches(): false </pre></code><br>'),
(119, 'The <i>replaceFirst</i> and <i>replaceAll</i> Methods:', 'The replaceFirst and replaceAll methods replace text that matches a given regular expression. As their names indicate, replaceFirst replaces the first occurrence, and replaceAll replaces all occurrences.Here is the example explaining the functionality:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.regex.Matcher; import java.util.regex.Pattern;  public class RegexMatches {     private static String REGEX = "dog";     private static String INPUT = "The dog says meow. " +                                     "All dogs say meow.";     private static String REPLACE = "cat";      public static void main(String[] args) {        Pattern p = Pattern.compile(REGEX);        // get a matcher object        Matcher m = p.matcher(INPUT);         INPUT = m.replaceAll(REPLACE);        System.out.println(INPUT);    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> The cat says meow. All cats say meow. </pre></code><br>'),
(120, 'The <i>appendReplacement</i> and <i>appendTail</i> Methods:', 'The Matcher class also provides appendReplacement and appendTail methods for text replacement. Here is the example explaining the functionality:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.regex.Matcher; import java.util.regex.Pattern;  public class RegexMatches {    private static String REGEX = "a*b";    private static String INPUT = "aabfooaabfooabfoob";    private static String REPLACE = "-";    public static void main(String[] args) {       Pattern p = Pattern.compile(REGEX);       // get a matcher object       Matcher m = p.matcher(INPUT);       StringBuffer sb = new StringBuffer();       while(m.find()){          m.appendReplacement(sb,REPLACE);       }       m.appendTail(sb);       System.out.println(sb.toString());    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> -foo-foo-foo- </pre></code><br>'),
(121, 'Java - Methods', 'A Java method is a collection of statements that are grouped together to perform an operation. When you call the System.out.<b>println()</b> method, for example, the system actually executes several statements in order to display a message on the console.Now you will learn how to create your own methods with or without return values, invoke a method with or without parameters, and apply method abstraction in the program design.', ''),
(122, 'Creating Method:', 'Considering the following example to explain the syntax of a method:Here,  <ul class="list"> <li><p><b>public static</b> : modifier.</p></li> <li><p><b>int</b>: return type</p></li> <li><p><b>methodName</b>: name of the method </p></li> <li><p><b>a, b</b>: formal parameters</p></li> <li><p><b>int a, int b</b>: list of parameters</p></li> </ul>  Method definition consists of a method header and a method body. The same is shown below: <pre class="prettyprint notranslate"> modifier returnType nameOfMethod (Parameter List) {  // method body } </pre> The syntax shown above includes: <li><p><b>modifier:</b> It defines the access type of the method and it is optional to use.</p></li> <li><p><b>returnType:</b> Method may return a value. <li><p><b>nameOfMethod:</b> This is the method name. The method signature consists of the method name and the parameter list.</p></li> <li><p><b>Parameter List:</b> The list of parameters, it is the type, order, and number of parameters of a method. These are optional, method may contain zero parameters.</p></li> <li><p><b>method body:</b> The method body defines what the method does with statements.</p></li> </ul> <h2>Example:</h2> <p>Here is the source code of the above defined  method called max(). This method takes two parameters num1 and num2 and returns the maximum between the two:</p>  <pre class="prettyprint notranslate"> /** the snippet returns the minimum between two numbers */ public static int minFunction(int n1, int n2) {    int min;    if (n1 &gt; n2)       min = n2;    else       min = n1;     return min;  } </pre> <h2>Method Calling:</h2> <p>For using a method, it should be called. There are two ways in which a method is called i.e. method returns a value or returning nothing (no return value).</p> <p>The process of method calling is simple. When a program invokes a method, the program control gets transferred to the called method. This called method then returns control to the caller in two conditions, when: <ul class="list"> <li><p>return statement is executed.</p></li> <li><p>reaches the method ending closing brace.</p></li> </ul> <p>The methods returning void is considered as call to a statement. Lets consider an example:</p> <pre class="prettyprint notranslate"> System.out.println("This is tutorialspoint.com!"); </pre> <p>The method returning value can be understood by the following example:</p> <pre class="prettyprint notranslate"> int result = sum(6, 9); </pre> <h2>Example:</h2> <p>Following is the example to demonstrate how to define a method and how to call it:</p> <pre class="prettyprint notranslate tryit"> public class ExampleMinNumber{        public static void main(String[] args) {       int a = 11;       int b = 6;       int c = minFunction(a, b);       System.out.println("Minimum Value = " + c);    }     /** returns the minimum of two numbers */    public static int minFunction(int n1, int n2) {       int min;       if (n1 &gt; n2)          min = n2;       else          min = n1;        return min;     } } </pre> <p>This would produce the following result:</p> <pre class="prettyprint notranslate"> inimum value = 6 </pre> <h2>The void Keyword:</h2> <p>The void keyword allows us to create methods which do not return a value. Here, in the following example were considering a void method <i>methodRankPoints</i>. This method is a void method which does not return any value. Call to a void method must be a statement i.e. <i>methodRankPoints(255.7);</i>. It is a Java statement which ends with a semicolon as shown below.</p> <h2>Example:</h2> <pre class="prettyprint notranslate tryit"> public class ExampleVoid {     public static void main(String[] args) {       methodRankPoints(255.7);    }     public static void methodRankPoints(double points) {       if (points &gt;= 202.5) {          System.out.println("Rank:A1");       }       else if (points &gt;= 122.4) {          System.out.println("Rank:A2");       }       else {          System.out.println("Rank:A3");       }    } } </pre> <p>This would produce the following result:</p> <pre class="prettyprint notranslate"> Rank:A1 </pre> <h2>Passing Parameters by Value:</h2> <p> While working under calling process, arguments is to be passed. These should be in the same order as their respective parameters in the method specification. Parameters can be passed by value or by reference.</p> <p>Passing Parameters by Value means calling a method with a parameter. Through this the argument value is passed to the parameter.</p> <h2>Example:</h2> <p>The following program shows an example of passing parameter by value. The values of the arguments remains the same even after the method invocation.</p> <pre class="prettyprint notranslate tryit"> public class swappingExample {     public static void main(String[] args) {       int a = 30;       int b = 45;        System.out.println("Before swapping, a = " +                           a + " and b = " + b);        // Invoke the swap method       swapFunction(a, b);       System.out.println("\n**Now, Before and After swapping values will be same here**:");       System.out.println("After swapping, a = " +                          a + " and b is " + b);    }     public static void swapFunction(int a, int b) {           System.out.println("Before swapping(Inside), a = " + a                            + " b = " + b);       // Swap n1 with n2       int c = a;       a = b;       b = c;        System.out.println("After swapping(Inside), a = " + a                            + " b = " + b);    } } </pre> <p>This would produce the following result:</p> <pre class="prettyprint notranslate"> Before swapping, a = 30 and b = 45 Before swapping(Inside), a = 30 b = 45 After swapping(Inside), a = 45 b = 30  **Now, Before and After swapping values will be same here**: After swapping, a = 30 and b is 45 </pre>  <h2>Method Overloading:</h2> <p>When a class has two or more methods by same name but different parameters, it is known as method overloading. It is different from overriding. In overriding a method has same method name, type, number of parameters etc.</p> <p>Lets consider the example shown before for finding minimum numbers of integer type. If, lets say we want to find minimum number of double type. Then the concept of Overloading will be introduced to create two or more methods with the same name but different parameters.<p> <p></p> <p>The below example explains the same:</p> <pre class="prettyprint notranslate tryit"> public class ExampleOverloading{     public static void main(String[] args) {       int a = 11;       int b = 6;       double c = 7.3;       double d = 9.4;       int result1 = minFunction(a, b);       // same function name with different parameters       double result2 = minFunction(c, d);       System.out.println("Minimum Value = " + result1);       System.out.println("Minimum Value = " + result2);    }    // for integer    public static int minFunction(int n1, int n2) {       int min;       if (n1 &gt; n2)          min = n2;       else          min = n1;        return min;     }    // for double    public static double minFunction(double n1, double n2) {      double min;       if (n1 &gt; n2)          min = n2;       else          min = n1;        return min;     } } </pre> <p>This would produce the following result:</p> <pre class="prettyprint notranslate"> inimum Value = 6 inimum Value = 7.3 </pre> <p>Overloading methods makes program readable. Here, two methods are given same name but with different parameters. The minimum number from integer and double types is the result.</p>                  <h2>Using Command-Line Arguments:</h2> <p>Sometimes you will want to pass information into a program when you run it. This is accomplished by passing command-line arguments to main( ).</p> <p>A command-line argument is the information that directly follows the programs name on the command line when it is executed. To access the command-line arguments inside a Java program is quite easy.they are stored as strings in the String array passed to main( ).</p> <h2>Example:</h2> <p>The following program displays all of the command-line arguments that it is called with:</p> <pre class="prettyprint notranslate"> public class CommandLine {     public static void main(String args[]){        for(int i=0; i&lt;args.length; i++){          System.out.println("args[" + i + "]: " +                                            args[i]);       }    } } </pre> <p>Try executing this program as shown here:</p> <pre class="prettyprint notranslate"> $java CommandLine this is a command line 200 -100 </pre> <p>This would produce the following result:</p> <pre class="result notranslate"> args[0]: this args[1]: is args[2]: a args[3]: command args[4]: line args[5]: 200 args[6]: -100 </pre> <h2>The Constructors:</h2> <p>A constructor initializes an object when it is created. It has the same name as its class and is syntactically similar to a method. However, constructors have no explicit return type.</p> <p>Typically, you will use a constructor to give initial values to the instance variables defined by the class, or to perform any other startup procedures required to create a fully formed object.</p> <p>All classes have constructors, whether you define one or not, because Java automatically provides a default constructor that initializes all member variables to zero. However, once you define your own constructor, the default constructor is no longer used.</p> <h2>Example:</h2> <p>Here is a simple example that uses a constructor without parameters:</p> <pre class="prettyprint notranslate" id="cons1"> // A simple constructor. class MyClass {    int x;        // Following is the constructor    MyClass() {       x = 10;    } } </pre> <p>You would call constructor to initialize objects as follows:</p> <pre class="prettyprint notranslate tryit" title="cons1"> public class ConsDemo {     public static void main(String args[]) {       MyClass t1 = new MyClass();       MyClass t2 = new MyClass();       System.out.println(t1.x + " " + t2.x);    } } </pre> <h3>parametarized constructor</h3> <p>Most often, you will need a constructor that accepts one or more parameters. Parameters are added to a constructor in the same way that they are added to a method, just declare them inside the parentheses after the constructors name.</p> <h2>Example:</h2> <p>Here is a simple example that uses a constructor with parameter:</p> <pre class="prettyprint notranslate" id="cons2"> // A simple constructor. class MyClass {    int x;        // Following is the constructor    MyClass(int i ) {       x = i;    } } </pre> <p>You would call constructor to initialize objects as follows:</p> <pre class="prettyprint notranslate tryit" title="cons2"> public class ConsDemo {     public static void main(String args[]) {       MyClass t1 = new MyClass( 10 );       MyClass t2 = new MyClass( 20 );       System.out.println(t1.x + " " + t2.x);    } } </pre> <p>This would produce the following result:</p> <pre class="prettyprint notranslate"> 10 20 </pre>  <h2>The this keyword</h2> <p><b>this</b> is a keyword in Java which is used as a reference to the object of the current class, with in an instance method or a constructor. Using <i>this</i> you can refer the members of a class such as constructors, variables and methods.</p> <p><b>Note</b>The keyword <i>this</i> is used only within instance methods or constructors</p> <img src="/java/images/this.jpg" alt="Java Tutorial" /> <p>&nbsp;</p> In general the keyword <i>this</i> is used to : <ul class="list"> <li><p>Differentiate the instance variables from local variables if they have same names, within a constructor or a method.</p></li></ul> <pre class="prettyprint notranslate"> class Student{     int age;       Student(int age){    this.age=age;	    }  } </pre> <ul class="list"> <li><p>Call  one type of constructor( parametrized constructor or default ) from other in a class. It is known as explicit constructor invocation .</p></li></ul> <pre class="prettyprint notranslate"> class Student{     int age    Student(){    this(20);    }        Student(int age){    this.age=age;	    }  } </pre> ', '<br><code><pre class="prettyprint notranslate"> public static int methodName(int a, int b) {   // body } </pre></code><br>'),
(123, 'Example', 'Here is an example that uses <i>this</i> keyword to access the members of a class. Copy and paste the below given program in a file with name This_Example.java', '<br><code><pre class="prettyprint notranslate tryit"> public class This_Example { 	    //Instance variable num    int num=10; 	    This_Example(){       System.out.println("This is an example program on keyword this ");	    }     This_Example(int num){       //Invoking the default constructor       this();              //Assigning the local variable <i>num</i> to the instance variable <i>num</i>       this.num=num;	       }        public void greet(){       System.out.println("Hi Welcome to Tutorialspoint");    }           public void print(){       //Local variable num       int num=20;              //Printing the instance variable       System.out.println("value of local variable num is : "+num);              //Printing the local variable       System.out.println("value of instance variable num is : "+this.num);              //Invoking the greet method of a class       this.greet();         }        public static void main(String[] args){       //Instantiating the class       This_Example obj1=new This_Example();              //Invoking the print method       obj1.print(); 	         //Passing a new value to the num variable through parametrized constructor       This_Example obj2=new This_Example(30);              //Invoking the print method again       obj2.print();     }  }  </pre></code><br><br><code><pre class="result notranslate"> This is an example program on keyword this  value of local variable num is : 20 value of instance variable num is : 10 Hi Welcome to Tutorialspoint This is an example program on keyword this  value of local variable num is : 20 value of instance variable num is : 30 Hi Welcome to Tutorialspoint </pre></code><br>'),
(124, 'Variable Arguments(var-args):', 'JDK 1.5 enables you to pass a variable number of arguments of the same type to a method. The parameter in the method is declared as follows:In the method declaration, you specify the type followed by an ellipsis (...) Only one variable-length parameter may be specified in a method, and this parameter must be the last parameter. Any regular parameters must precede it.', '<br><code><pre class="prettyprint notranslate"> typeName... parameterName </pre></code><br>');
INSERT INTO `text` (`textid`, `topic`, `content`, `code`) VALUES
(125, 'Example:', 'This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class VarargsDemo {     public static void main(String args[]) {       // Call method with variable args   	  printMax(34, 3, 3, 2, 56.5);       printMax(new double[]{1, 2, 3});    }     public static void printMax( double... numbers) {    if (numbers.length == 0) {       System.out.println("No argument passed");       return;    }     double result = numbers[0];     for (int i = 1; i &lt;  numbers.length; i++)       if (numbers[i] &gt;  result)       result = numbers[i];       System.out.println("The max value is " + result);    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> The max value is 56.5 The max value is 3.0 </pre></code><br>'),
(126, 'Java - Files and I/O', 'The java.io package contains nearly every class you might ever need to perform input and output (I/O) in Java. All these streams represent an input source and an output destination. The stream in the java.io package supports many data  such as primitives, Object, localized characters, etc.', ''),
(127, 'Stream', 'A stream can be defined as a sequence of data. there are two kinds of Streams<ul class="list"> <li><p><b>InPutStream:</b> The InputStream is used to read data from a source.</p></li> <li><p><b>OutPutStream:</b> the OutputStream is used for writing data to a destination.</p></li> </ul> &nbsp;&nbsp;Java provides strong but flexible support for I/O related to Files and networks but this tutorial covers very basic functionality related to streams and I/O. We would see most commonly used example one by one:', ''),
(128, 'Byte Streams', 'Java byte streams are used to perform input and output of 8-bit bytes. Though there are many classes  related to byte streams but the most frequently used classes are , <b>FileInputStream</b> and <b>FileOutputStream</b>. Following is an example which makes use of these two classes to copy an input file into an output file:Now lets have a file <b>input.txt</b> with the following content:As a next step, compile above program and execute it, which will result in creating output.txt file with the same content as we have in input.txt. So lets put above code in CopyFile.java file and do the following:', '<br><code><pre class="prettyprint notranslate"> import java.io.*;  public class CopyFile {    public static void main(String args[]) throws IOException    {       FileInputStream in = null;       FileOutputStream out = null;        try {          in = new FileInputStream("input.txt");          out = new FileOutputStream("output.txt");                    int c;          while ((c = in.read()) != -1) {             out.write(c);          }       }finally {          if (in != null) {             in.close();          }          if (out != null) {             out.close();          }       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> This is test for copy file. </pre></code><br><br><code><pre class="prettyprint notranslate"> $javac CopyFile.java $java CopyFile </pre></code><br>'),
(129, 'Character Streams', 'Java <b>Byte</b> streams  are used to perform input and output of 8-bit bytes, where as Java <b>Character</b> streams are used to perform input and output for 16-bit unicode. Though there are many classes  related to character streams but the most frequently used classes are , <b>FileReader </b> and <b>FileWriter.</b>. Though internally FileReader uses FileInputStream and FileWriter uses FileOutputStream but here major difference is that FileReader reads two bytes at a time and  FileWriter writes two bytes at a time.We can re-write above example which makes use of these two classes to copy an input file (having unicode characters) into an output file:Now lets have a file <b>input.txt</b> with the following content:As a next step, compile above program and execute it, which will result in creating output.txt file with the same content as we have in input.txt. So lets put above code in CopyFile.java file and do the following:', '<br><code><pre class="prettyprint notranslate"> import java.io.*;  public class CopyFile {    public static void main(String args[]) throws IOException    {       FileReader in = null;       FileWriter out = null;        try {          in = new FileReader("input.txt");          out = new FileWriter("output.txt");                    int c;          while ((c = in.read()) != -1) {             out.write(c);          }       }finally {          if (in != null) {             in.close();          }          if (out != null) {             out.close();          }       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> This is test for copy file. </pre></code><br><br><code><pre class="prettyprint notranslate"> $javac CopyFile.java $java CopyFile </pre></code><br>'),
(130, 'Standard Streams', 'All the programming languages provide support for standard I/O where users program can take input from a keyboard and then produce output on the computer screen. If you are aware if C or C++ programming languages, then you must be aware of three standard  devices STDIN, STDOUT and STDERR. Similar way Java provides following three standard streams  <li><p><b>Standard Input:</b> This is used to feed the data to users program and usually a keyboard is used as standard input stream and represented as <b>System.in</b>.</p></li> <li><p><b>Standard Output:</b> This is used to output the data produced by the users program and usually a computer screen is used to standard output stream and represented as <b>System.out</b>.</p></li> <li><p><b>Standard Error:</b> This is used to output the error data produced by the users program and usually a computer screen is used to standard error stream and represented as <b>System.err</b>.</p></li> Following is a simple program which creates <b>InputStreamReader</b> to read standard input stream until the user types a "q":Lets keep above code in ReadConsole.java file and try to compile and execute it as below. This program continues reading and outputting same character until we press q:', '<br><code><pre class="prettyprint notranslate tryit"> import java.io.*;  public class ReadConsole {    public static void main(String args[]) throws IOException    {       InputStreamReader cin = null;        try {          cin = new InputStreamReader(System.in);          System.out.println("Enter characters, q to quit.");          char c;          do {             c = (char) cin.read();             System.out.print(c);          } while(c != q);       }finally {          if (cin != null) {             cin.close();          }       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> $javac ReadConsole.java $java ReadConsole Enter characters, q to quit. 1 1 e e q q </pre></code><br>'),
(131, 'Reading and Writing Files:', 'As described earlier, A stream can be defined as a sequence of data. The <b>InputStream</b> is used to read data from a source and the <b>OutputStream</b> is used for writing data to a destination.Here is a hierarchy of classes to deal with Input and Output streams.The two important streams are <b>FileInputStream</b> and <b>FileOutputStream</b>, which would be discussed in this tutorial:', ''),
(132, 'FileInputStream:', 'This stream is used for reading data from the files. Objects can be created using the keyword new and there are several types of constructors available.Following constructor takes a file name as a string to create an input stream object to read the file.:Following constructor takes a file object to create an input stream object to read the file. First we create a file object using File() method as follows:Once you have <i>InputStream</i> object in hand, then there is a list of helper methods which can be used to read to stream or to do other operations on the stream.There are other important input streams available, for more detail you can refer to the following links: <li><p><a href="/java/java_bytearrayinputstream.htm" title="ByteArrayInputStream">ByteArrayInputStream</a></p></li> <li><p><a href="/java/java_datainputstream.htm" title="DataInputStream">DataInputStream</a></p></li> ', '<br><code><pre class="prettyprint notranslate"> InputStream f = new FileInputStream("C:/java/hello"); </pre></code><br><br><code><pre class="prettyprint notranslate"> File f = new File("C:/java/hello"); InputStream f = new FileInputStream(f); </pre></code><br>'),
(133, 'FileOutputStream:', 'FileOutputStream is used to create a file and write data into it. The stream would create a file, if it doesnt already exist, before opening it for output.Here are two constructors which can be used to create a FileOutputStream object.Following constructor takes a file name as a string to create an input stream object to write the file:Following constructor takes a file object to create an output stream object to write the file. First, we create a file object using File() method as follows:Once you have <i>OutputStream</i> object in hand, then there is a list of helper methods, which can be used to write to stream or to do other operations on the stream.There are other important output streams available, for more detail you can refer to the following links: <li><p><a href="/java/java_bytearrayoutputstream.htm" title="ByteArrayOutputStream">ByteArrayOutputStream</a></p></li> <li><p><a href="/java/java_dataoutputstream.htm" title="DataOutputStream">DataOutputStream</a></p></li> ', '<br><code><pre class="prettyprint notranslate"> OutputStream f = new FileOutputStream("C:/java/hello")  </pre></code><br><br><code><pre class="prettyprint notranslate"> File f = new File("C:/java/hello"); OutputStream f = new FileOutputStream(f); </pre></code><br>'),
(134, 'Example:', 'Following is the example to demonstrate InputStream and OutputStream:The above code would create file test.txt and would write given numbers in binary format. Same would be output on the stdout screen.', '<br><code><pre class="prettyprint notranslate"> import java.io.*;  public class fileStreamTest{     public static void main(String args[]){        try{       byte bWrite [] = {11,21,3,40,5};       OutputStream os = new FileOutputStream("test.txt");       for(int x=0; x &lt; bWrite.length ; x++){          os.write( bWrite[x] ); // writes the bytes       }       os.close();             InputStream is = new FileInputStream("test.txt");       int size = is.available();        for(int i=0; i&lt; size; i++){          System.out.print((char)is.read() + "  ");       }       is.close();    }catch(IOException e){       System.out.print("Exception");    }	    } } </pre></code><br>'),
(135, 'File Navigation and I/O:', 'There are several other classes that we would be going through to get to know the basics of File Navigation and I/O. <li><p><a href="/java/java_file_class.htm" title="File Class">File Class</a></p></li> <li><p><a href="/java/java_filereader_class.htm" title="FileReader  Class">FileReader  Class</a></p></li> <li><p><a href="/java/java_filewriter_class.htm" title="FileWriter  Class">FileWriter  Class</a></p></li> ', ''),
(136, 'Directories in Java:', 'A directory is a File which can contains a list of other files and directories. You use <b>File</b> object to create directories, to list down files available in a directory. For complete detail check a list of all the methods which you can call on File object and what are related to directories.', ''),
(137, 'Creating Directories:', 'There are two useful <b>File</b> utility methods, which can be used to create directories: <li><p>The <b>mkdir( )</b> method creates a directory, returning true on success and false on failure. Failure indicates that the path specified in the File object already exists, or that the directory cannot be created because the entire path does not exist yet.</p></li> <li><p>The <b>mkdirs()</b> method creates both a directory and all the parents of the directory.</p></li> Following example creates "/tmp/user/java/bin" directory:Compile and execute above code to create "/tmp/user/java/bin".<b>Note:</b> Java  automatically takes care of path separators on UNIX and Windows as per conventions. If you use a forward slash (/) on a Windows version of Java, the path will still resolve correctly.', '<br><code><pre class="prettyprint notranslate"> import java.io.File;  public class CreateDir {    public static void main(String args[]) {       String dirname = "/tmp/user/java/bin";       File d = new File(dirname);       // Create directory now.       d.mkdirs();   } } </pre></code><br>'),
(138, 'Java - Exceptions', 'An exception (or exceptional event) is a problem that arises during the <b>execution</b> of a program. When an Exception occurs the normal flow of the program is disrupted and the program/Application terminates abnormally, which is not recommended, therefore these exceptions are to be handled. An exception can occur for many different reasons, below given are some scenarios where exception occurs. <li><p>A user has entered invalid data.</p></li> <li><p>A file that needs to be opened cannot be found.</p></li> <li><p>A network connection has been lost in the middle of communications or the JVM has run out of memory.</p></li> Some of these exceptions are caused by user error, others by programmer error, and others by physical resources that have failed in some manner.Based on these we have three categories of Exceptions  you need to understand them to know how exception handling works in Java,  <li><p><b>Checked exceptions:</b> A checked exception is an exception that occurs at the compile time, these are also called as compile time exceptions. These exceptions cannot simply be ignored at the time of compilation, the Programmer should take care of (handle) these exceptions.<p> </p> For example, if you use <b>FileReader</b> class in your program to read data from a file, if the file specified in its constructor doesnt exist, then an <i>FileNotFoundException </i>occurs, and compiler prompts the programmer to handle the exception.</p></li>&nbsp;<b>Note:</b> Since the methods <b>read()</b> and <b>close()</b> of FileReader class throws IOException, you can observe that compiler notifies to handle IOException, along with FileNotFoundException. <li><p><b>Unchecked exceptions:</b> An Unchecked  exception is an exception that occurs at the time of execution, these are also called as Runtime Exceptions, these include programming bugs, such as logic errors or improper use of an API. runtime exceptions are ignored at the time of compilation.</p> <p>For example, if you have declared an array of size 5 in your program, and trying to call the 6th element of the array then an <i>ArrayIndexOutOfBoundsExceptionexception</i> occurs.</p></li> If you compile and execute the above program you will get exception as shown below. <li><p><b>Errors:</b> These are not exceptions at all, but problems that arise beyond the control of the user or the programmer. Errors are typically ignored in your code because you can rarely do anything about an error. For example, if a stack overflow occurs, an error will arise. They are also ignored at the time of compilation.</p></li> ', '<br><code><pre class="prettyprint notranslate"> import java.io.File; import java.io.FileReader;  public class FilenotFound_Demo {     public static void main(String args[]){		       File file=new File("E://file.txt");       FileReader fr = new FileReader(file);     }     } </pre></code><br><br><code><pre class="prettyprint notranslate"> C:>javac FilenotFound_Demo.java FilenotFound_Demo.java:8: error: unreported exception FileNotFoundException; must be caught or declared to be thrown       FileReader fr = new FileReader(file);                       ^ 1 error </pre></code><br><br><code><pre class="prettyprint notranslate"> public class Unchecked_Demo {        public static void main(String args[]){       int num[]={1,2,3,4};       System.out.println(num[5]);    }  } </pre></code><br><br><code><pre class="prettyprint notranslate"> Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 5 	at Exceptions.Unchecked_Demo.main(Unchecked_Demo.java:8) </pre></code><br>'),
(139, 'Exception Hierarchy:', 'All exception classes are subtypes of the java.lang.Exception class. The exception class is a subclass of the Throwable class. Other than the exception class there is another subclass called Error which is derived from the Throwable class.Errors are abnormal conditions that happen in case of severe failures, these are not handled by the java programs. Errors are generated to indicate errors generated by the runtime environment. Example : JVM is out of Memory. Normally programs cannot recover from errors.The Exception class has two main subclasses: IOException class and RuntimeException Class.Here is a list of most common checked and unchecked <a href="/java/java_builtin_exceptions.htm">Javas Built-in Exceptions</a>.', ''),
(140, 'Exceptions Methods:', 'Following is the list of important medthods available in the Throwable class.', ''),
(141, 'Catching Exceptions:', 'A method catches an exception using a combination of the <b>try</b> and <b>catch</b> keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following:The code which is prone to exceptions is placed in the try block, when an exception occurs, that exception occurred is handled by catch block associated with it. Every try block should be immediately followed either by a catch block or finally block. A catch statement involves declaring the type of exception you are trying to catch. If an exception occurs in protected code, the catch block (or blocks) that follows the try is checked. If the type of exception that occurred is listed in a catch block, the exception is passed to the catch block much as an argument is passed into a method parameter.', '<br><code><pre class="prettyprint notranslate"> try {    //Protected code }catch(ExceptionName e1) {    //Catch block } </pre></code><br>'),
(142, 'Example:', 'The following is an array is declared with 2 elements. Then the code tries to access the 3rd element of the array which throws an exception.This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> // File Name : ExcepTest.java import java.io.*; public class ExcepTest{     public static void main(String args[]){       try{          int a[] = new int[2];          System.out.println("Access element three :" + a[3]);       }catch(ArrayIndexOutOfBoundsException e){          System.out.println("Exception thrown  :" + e);       }       System.out.println("Out of the block");    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3 Out of the block </pre></code><br>'),
(143, 'Multiple catch Blocks:', 'A try block can be followed by multiple catch blocks. The syntax for multiple catch blocks looks like the following:The previous statements demonstrate three catch blocks, but you can have any number of them after a single try. If an exception occurs in the protected code, the exception is thrown to the first catch block in the list. If the data type of the exception thrown matches ExceptionType1, it gets caught there. If not, the exception passes down to the second catch statement. This continues until the exception either is caught or falls through all catches, in which case the current method stops execution and the exception is thrown down to the previous method on the call stack.', '<br><code><pre class="prettyprint notranslate"> try {    //Protected code }catch(ExceptionType1 e1) {    //Catch block }catch(ExceptionType2 e2) {    //Catch block }catch(ExceptionType3 e3) {    //Catch block } </pre></code><br>'),
(144, 'Example:', 'Here is code segment showing how to use multiple try/catch statements.', '<br><code><pre class="prettyprint notranslate"> try {    file = new FileInputStream(fileName);    x = (byte) file.read(); }catch(IOException i) {    i.printStackTrace();    return -1; }catch(FileNotFoundException f) //Not valid! {    f.printStackTrace();    return -1; } </pre></code><br>'),
(145, 'Catching multiple type of exceptions', 'Since Java 7 you can handle more than one exceptions using a single catch block, this feature simplifies the code. Below given is the syntax of writing  ', '<br><code><pre class="prettyprint notranslate"> catch (IOException|FileNotFoundException ex) {    logger.log(ex);    throw ex; </pre></code><br>'),
(146, 'The throws/throw Keywords:', 'If a method does not handle a checked exception, the method must declare it using the <b>throws </b> keyword. The throws keyword appears at the end of a methods signature.You can throw an exception, either a newly instantiated one or an exception that you just caught, by using the <b>throw</b> keyword.The following method declares that it throws a RemoteException:A method can declare that it throws more than one exception, in which case the exceptions are declared in a list separated by commas. For example, the following method declares that it throws a RemoteException and an InsufficientFundsException:', '<br><code><pre class="prettyprint notranslate"> import java.io.*; public class className {    public void deposit(double amount) throws RemoteException    {       // Method implementation       throw new RemoteException();    }    //Remainder of class definition } </pre></code><br><br><code><pre class="prettyprint notranslate"> import java.io.*; public class className {    public void withdraw(double amount) throws RemoteException,                               InsufficientFundsException    {        // Method implementation    }    //Remainder of class definition } </pre></code><br>'),
(147, 'The finally block', 'The finally block follows a try block or a catch block. A finally block of code always executes, irrespective of occurrence of an Exception.Using a finally block allows you to run any cleanup-type statements that you want to execute, no matter what happens in the protected code.A finally block appears at the end of the catch blocks and has the following syntax:', '<br><code><pre class="prettyprint notranslate"> try {    //Protected code }catch(ExceptionType1 e1) {    //Catch block }catch(ExceptionType2 e2) {    //Catch block }catch(ExceptionType3 e3) {    //Catch block }finally {    //The finally block always executes. } </pre></code><br>'),
(148, 'Example:', 'This would produce the following result:Note the following: <li><p>A catch clause cannot exist without a try statement. </p></li> <li><p>It is not compulsory to have finally clauses when ever a try/catch block is present. </p></li> <li><p>The try block cannot be present without either catch clause or finally clause.</p></li> <li><p>Any code cannot be present in between the try, catch, finally blocks. </p></li> ', '<br><code><pre class="prettyprint notranslate tryit"> public class ExcepTest{     public static void main(String args[]){       int a[] = new int[2];       try{          System.out.println("Access element three :" + a[3]);       }catch(ArrayIndexOutOfBoundsException e){          System.out.println("Exception thrown  :" + e);       }       finally{          a[0] = 6;          System.out.println("First element value: " +a[0]);          System.out.println("The finally statement is executed");       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3 First element value: 6 The finally statement is executed </pre></code><br>'),
(149, 'The try-with-resources', 'Generally when we use any resources like streams, connections etc.. we have to close them explicitly using finally block. In the program given below we are reading data from a file using <b>FileReader</b> and we are closing it using finally block.<b>try-with-resources</b>, also referred as <b>automatic resource management</b>. is a new exception handling mechanism that was introduced in Java7, which automatically closes the resources used within the try catch block.To use this statement you simply need to declare the required resources within the parenthesis, the created resource will be closed automatically at the end of the block, below given is the syntax of try-with-resources statement. Below given is the program that reads the data in a file using try-with-resources statement.Following points are to be kept in mind while working with try-with resources statement. <li><p>To use a class with try-with-resources statement it should implement <b>AutoCloseable</b> interface and the <b>close()</b> method of it gets invoked automatically at runtime. </p></li> <li><p>You can declare more than one class in try-with-resources statement.</p></li> <li><p>while you declare multiple classes in the try block of try-with-resources statement these classes are closed in reverse order.</p></li> <li><p>Except the deceleration of resources within the parenthesis every thing is same as normal try/catch block of a try block.</p></li> <li><p>The resource declared in try gets instantiated just before the start of the try-block.</p></li> <li><p>The resource declared at the try block is implicitly declared as final. </p></li> ', '<br><code><pre class="prettyprint notranslate"> import java.io.File; import java.io.FileReader; import java.io.IOException;  public class ReadData_Demo {     public static void main(String args[]){       FileReader fr=null;		       try{          File file=new File("file.txt");          fr = new FileReader(file);  char [] a = new char[50];          fr.read(a); // reads the content to the array          for(char c : a)          System.out.print(c); //prints the characters one by one       }catch(IOException e){           e.printStackTrace();        }        finally{	           try{               fr.close();           }catch(IOException ex){		                ex.printStackTrace();            }        }     }  } </pre></code><br><br><code><pre class ="prettyprint notranslate"> try(FileReader fr=new FileReader("file path"))    {    //use the resource    }catch(){       //body of catch      }    } </pre></code><br><br><code><pre class ="prettyprint notranslate"> import java.io.FileReader; import java.io.IOException;  public class Try_withDemo {     public static void main(String args[]){       		       try(FileReader fr=new FileReader("E://file.txt")){          char [] a = new char[50];          fr.read(a); // reads the contentto the array          for(char c : a)          System.out.print(c); //prints the characters one by one       }catch(IOException e){           e.printStackTrace();        }       } } </pre></code><br>'),
(150, 'User-defined Exceptions:', 'You can create your own exceptions in Java. Keep the following points in mind when writing your own exception classes: <li><p>All exceptions must be a child of Throwable.</p></li> <li><p>If you want to write a checked exception that is automatically enforced by the Handle or Declare Rule, you need to extend the Exception class.</p></li> <li><p>If you want to write a runtime exception, you need to extend the RuntimeException class.</p></li> We can define our own Exception class as below:You just need to extend the predefined  <b>Exception</b> class to create your own Exception. These are considered to be checked exceptions. The following <b>InsufficientFundsException</b> class is a user-defined exception that extends the Exception class, making it a checked exception. An exception class is like any other class, containing useful fields and methods.', '<br><code><pre class="prettyprint notranslate"> class MyException extends Exception{ } </pre></code><br>'),
(151, 'Example:', 'To demonstrate using our user-defined exception, the following CheckingAccount class contains a withdraw() method that throws an InsufficientFundsException.The following BankDemo program demonstrates invoking the deposit() and withdraw() methods of CheckingAccount.Compile all the above three files and run BankDemo, this would produce the following result:', '<br><code><pre class="prettyprint notranslate" id="exception"> // File Name InsufficientFundsException.java import java.io.*;  public class InsufficientFundsException extends Exception {    private double amount;    public InsufficientFundsException(double amount)    {       this.amount = amount;    }     public double getAmount()    {       return amount;    } } </pre></code><br><br><code><pre class="prettyprint notranslate" id="account"> // File Name CheckingAccount.java import java.io.*;  public class CheckingAccount {    private double balance;    private int number;        public CheckingAccount(int number)    {       this.number = number;    }        public void deposit(double amount)    {       balance += amount;    }        public void withdraw(double amount) throws InsufficientFundsException    {       if(amount &lt;= balance)       {          balance -= amount;       }       else       {          double needs = amount - balance;          throw new InsufficientFundsException(needs);       }    }        public double getBalance()    {       return balance;    }        public int getNumber()    {       return number;    } } </pre></code><br><br><code><pre class="prettyprint notranslate tryit" title="exception, account"> // File Name BankDemo.java public class BankDemo {    public static void main(String [] args)    {       CheckingAccount c = new CheckingAccount(101);       System.out.println("Depositing $500...");       c.deposit(500.00);              try       {          System.out.println("\nWithdrawing $100...");          c.withdraw(100.00);          System.out.println("\nWithdrawing $600...");          c.withdraw(600.00);       }catch(InsufficientFundsException e)       {          System.out.println("Sorry, but you are short $" + e.getAmount());          e.printStackTrace();       }     } } </pre></code><br><br><code><pre class="result notranslate"> Depositing $500...  Withdrawing $100...  Withdrawing $600... Sorry, but you are short $200.0 InsufficientFundsException         at CheckingAccount.withdraw(CheckingAccount.java:25)         at BankDemo.main(BankDemo.java:13) </pre></code><br>'),
(152, 'Nested Classes', 'In Java, just like methods, variables of a class too can have another class as its member. Writing a class within another is allowed in Java. The class written within is called the <b>nested class</b>, and the class that holds the inner class is called the <b>outer class</b>.', ''),
(153, 'Syntax', 'The syntax to write a nested class is given below. Here the class <b>Outer_Demo</b> is the outer class and the class <b>Inner_Demo</b> is the nested class.Nested classes are divided into two types:  <li><p><b>Non-static nested classes: </b>These are the non-static members of a class. </p></li> <li><p><b>Static nested classes: </b>These are the static members of a class.</p></li> &nbsp;', '<br><code><pre class="prettyprint notranslate"> class Outer_Demo{    class Nested_Demo{       }    } </pre></code><br>'),
(154, 'Inner Classes (Non-static Nested Classes)', 'Inner classes are a security mechanism in Java. We know a class cannot be associated with the access modifier <b>private</b>, but if we have the class as a member of other class, then the inner class can be made private. And this is also used to access the private members of a class. Inner classes are of three types depending on how and where you define them. They are: <li>Inner Class</li> <li>Method-local Inner Classlass</li> <li>Anonymous Inner Class</li> ', ''),
(155, 'Inner Class', 'Creating an inner class is quite simple. You just need to write a class within a class. Unlike a class, an inner class can be private and once you declare an inner class private, it cannot be accessed from an object outside the class.Given below is the program to create an inner class and access it. In the given example, we make the inner class private and access the class through a method.Here you can observe that <b>Outer_Demo</b> is the outer class, <b>Inner_Demo</b> is the inner class, <b>display_Inner()</b> is the method inside which we are instantiating the inner class, and this method is invoked from the <b>main</b> method.If you compile and execute the above program, you will get the following result.As mentioned earlier, inner classes are also used to access the private members of a class. Suppose a class is having private members to access them. Write an inner class in it, return the private members from a method within the inner class, say, <b>getValue()</b>, and finally from another class (from which you want to access the private members) call the getValue() method of the inner class.   To instantiate the inner class, initially you have to instantiate the outer class. Thereafter, using the object of the outer class, you can instantiate the inner class as shown below.The following program shows how to access the private members of a class using inner class.If you compile and execute the above program, you will get the following result. <pre class="result notranslate"> The value of num in the class Test is: 175 </pre>  <h2>Method-local Inner Class</h2> In Java, we can write a class within a method and this will be a local type. Like local variables, the scope of the inner class is restricted within the method.A method-local inner class can be instantiated only within the method where the inner class is defined. The following program shows how to use a method-local inner class.If you compile and execute the above program, you will get the following result.', '<br><code><pre class="prettyprint notranslate"> class Outer_Demo{    int num;    //inner class    private class Inner_Demo{       public void print(){	             System.out.println("This is an inner class");       }    }    //Accessing he inner class from the method within    void display_Inner(){       Inner_Demo inner = new Inner_Demo();       inner.print();    } }     public class My_class{    public static void main(String args[]){       //Instantiating the outer class        Outer_Demo outer = new Outer_Demo();       //Accessing the display_Inner() method.       outer.display_Inner();    }  } </pre></code><br><br><code><pre class="result notranslate"> This is an inner class. </pre></code><br><br><code><pre class="prettyprint notranslate"> Outer_Demo outer=new Outer_Demo(); Outer_Demo.Inner_Demo inner=outer.new Inner_Demo(); </pre></code><br><br><code><pre class="prettyprint notranslate"> class Outer_Demo {    //private variable of the outer class    private int num= 175;      //inner class       public class Inner_Demo{       public int getNum(){          System.out.println("This is the getnum method of the inner class");          return num;       }    } }  public class My_class2{    public static void main(String args[]){       //Instantiating the outer class       Outer_Demo outer=new Outer_Demo();       //Instantiating the inner class       Outer_Demo.Inner_Demo inner=outer.new Inner_Demo();       System.out.println(inner.getNum());    } } </pre></code><br><br><code><pre class = "prettyprint notranslate"> public class Outerclass{        //instance method of the outer class     void my_Method(){       int num = 23;           //method-local inner class       class MethodInner_Demo{          public void print(){             System.out.println("This is method inner class "+num);	             }          }//end of inner class 	          //Accessing the inner class       MethodInner_Demo inner = new MethodInner_Demo();       inner.print();    }        public static void main(String args[]){       Outerclass outer = new Outerclass();       outer.my_Method();	   	       } } </pre></code><br><br><code><pre class="result notranslate"> This is method inner class 23 </pre></code><br>'),
(156, 'Anonymous Inner Class', 'An inner class declared without a class name is known as an <b>anonymous inner class</b>. In case of anonymous inner classes, we declare and instantiate them at the same time. Generally they are used whenever you need to override the method of a class or an interface. The syntax of an anonymous inner class is as follows:The following program shows how to override the method of a class using anonymous inner class.If you compile and execute the above program, you will get the following result.In the same way, you can override the methods of the concrete class as well as the interface using an anonymous inner class.Generally if a method accepts an object of an interface, an abstract class, or a concrete class, then we can implement the interface, extend the abstract class, and pass the object to the method. If it is a class, then we can directly pass it to the method.But in all the three cases, you can pass an anonymous inner class to the method. Here is the syntax of passing an anonymous inner class as a method argument:The following program shows how to pass an anonymous inner class as a method argument.If you compile and execute the above program, it gives you the following result.', '<br><code><pre  class="prettyprint notranslate"> AnonymousInner an_inner = new AnonymousInner(){    public void my_method(){    ........    ........    }	     }; </pre></code><br><br><code><pre  class="prettyprint notranslate"> abstract class AnonymousInner{    public abstract void mymethod(); }  public class Outer_class {    public static void main(String args[]){       AnonymousInner inner = new AnonymousInner(){          public void mymethod(){             System.out.println("This is an example of anonymous inner class");    	            }	           };       inner.mymethod();	    } } </pre></code><br><br><code><pre class="result notranslate"> This is an example of anonymous inner class </pre></code><br><br><code><pre class="prettyprint notranslate"> obj.my_Method(new My_Class(){    public void Do(){    .....    .....    } }); </pre></code><br><br><code><pre class="prettyprint notranslate"> //interface interface Message{    String greet();	 }  public class My_class {    //method which accepts the object of interface Message    public void displayMessage(Message m){       System.out.println(m.greet() +", This is an example of anonymous inner calss as an argument");	       }     public static void main(String args[]){       //Instantiating the class       My_class obj = new My_class(); 		       //Passing an anonymous inner class as an argument       obj.displayMessage(new Message(){          public String greet(){             return "Hello";  		             }       });    } } </pre></code><br><br><code><pre class="result notranslate"> Hello This is an example of anonymous inner class as an argument </pre></code><br>'),
(157, 'Java - Inheritance', 'Inheritance can be defined as the process where one class acquires the properties (methods and fields) of another. With the use of inheritance the information is made manageable in a hierarchical order.The class which inherits the properties of other is known as subclass (derived class, child class) and the class whose properties are inherited is known as superclass (base class, parent class).', ''),
(158, 'extends Keyword', '<b>extends</b> is the keyword used to inherit the properties of a class. Below given is the syntax of extends keyword.', '<br><code><pre class="prettyprint notranslate"> class Super{    .....    ..... }  class Sub extends Super{    .....    .....  } </pre></code><br>'),
(159, 'Sample Code', 'Below given is an example demonstrating Java inheritance. In this example you can observe two classes namely Calculation and My_Calculation.Using extends keyword the My_Calculation inherits the methods addition() and Subtraction() of Calculation class.Copy and paste the program given below in a file with name My_Calculation.javaCompile and execute the above code as shown belowAfter executing the program it will produce the following result.In the given program when an object to <b>My_Calculation</b> class is created, a copy of the contents of the super class is made with in it. That is why, using the object of the subclass you can access the members of a super class.The Superclass reference variable can hold the subclass object, but using that variable you can access only the members of the superclass, so to access the members of both classes it is recommended to always create reference variable to the subclass.If you consider the above program you can instantiate the class as given below as well. But using the superclass reference variable ( <b>cal</b> in this case ) you cannot call the method <b>multiplication()</b>, which belongs to the subclass My_Calculation.<b>Note</b> &minus; A subclass inherits all the members (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.', '<br><code><pre class="prettyprint notranslate tryit"> class Calculation{     int z; 	    public void addition(int x, int y){       z = x+y;       System.out.println("The sum of the given numbers:"+z);    } 	    public void Substraction(int x,int y){       z = x-y;       System.out.println("The difference between the given numbers:"+z);    }     }  public class My_Calculation extends Calculation{           public void multiplication(int x, int y){       z = x*y;       System.out.println("The product of the given numbers:"+z);    } 	    public static void main(String args[]){       int a = 20, b = 10;       My_Calculation demo = new My_Calculation();       demo.addition(a, b);       demo.Substraction(a, b);       demo.multiplication(a, b);          }  } </pre></code><br><br><code><pre class="result notranslate"> javac My_Calculation.java java My_Calculation </pre></code><br><br><code><pre class="result notranslate"> The sum of the given numbers:30 The difference between the given numbers:10 The product of the given numbers:200 </pre></code><br><br><code><pre class="prettyprint notranslate"> Calculation cal = new My_Calculation(); demo.addition(a, b); demo.Subtraction(a, b); </pre></code><br>'),
(160, 'The super keyword', 'The <b>super</b> keyword is similar to <b>this</b> keyword following are the scenarios where the super keyword is used. <li><p>It is used to <b>differentiate the members</b> of superclass from the members of subclass, if they have same names.</p></li> <li><p>It is used to <b>invoke the superclass</b> constructor from subclass.</p></li> If a class is inheriting the properties of another class. And if the members of the superclass have the names same as the sub class, to differentiate these variables we use super keyword as shown below.This section provides you a program that demonstrates the usage of the <b>super</b> keyword.In the given program you have two classes namely <i>Sub_class</i> and <i>Super_class</i>, both have a  method named display() with different implementations, and a variable named num with different values. We are invoking display() method of both classes and printing the value of the variable num of both classes, here you can observe that we have used super key word to differentiate the members of super class from sub class.Copy and paste the program in a file with name Sub_class.java.Compile and execute the above code using the following syntax.On executing the program you will get the following result &minus;If a class is inheriting the properties of another class, the subclass automatically acquires the default constructor of the super class. But if you want to call a parametrized constructor of the super class, you need to use the super keyword as shown below.The program given in this section demonstrates how to use the super keyword to invoke the parametrized constructor of the superclass. This program contains a super class and a sub class, where the super class contains a parametrized constructor which accepts a string value, and we used the super keyword to invoke the parametrized constructor of the super class.Copy and paste the below given program in a file with name Subclass.javaCompile and execute the above code using the following syntax.On executing the program you will get the following result &minus;', '<br><code><pre class="prettyprint notranslate"> super.variable super.method(); </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> class Super_class{     int num = 20;        //display method of superclass    public void display(){          System.out.println("This is the display method of superclass");    }	  }  public class Sub_class extends Super_class {     int num = 10;        //display method of sub class    public void display(){       System.out.println("This is the display method of subclass");    }        public void my_method(){ 	         //Instantiating subclass       Sub_class sub = new Sub_class(); 	         //Invoking the display() method of sub class       sub.display(); 	         //Invoking the display() method of superclass       super.display(); 	         //printing the value of variable num of subclass       System.out.println("value of the variable named num in sub class:"+ sub.num); 		         //printing the value of variable num of superclass       System.out.println("value of the variable named num in super class:"+ super.num);         }        public static void main(String args[]){       Sub_class obj = new Sub_class();       obj.my_method();           } } </pre></code><br><br><code><pre class="prettyprint notranslate"> javac Super_Demo java Super </pre></code><br><br><code><pre class="result notranslate"> This is the display method of subclass This is the display method of superclass value of the variable named num in sub class:10 value of the variable named num in super class:20 </pre></code><br><br><code><pre class="result notranslate"> super(values); </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> class Superclass{        int age;     Superclass(int age){       this.age = age; 		     }     public void getAge(){       System.out.println("The value of the variable named age in super class is: " +age);    }  }  public class Subclass extends Superclass {        Subclass(int age){       super(age);    }     public static void main(String argd[]){       Subclass s = new Subclass(24);       s.getAge();    }  } </pre></code><br><br><code><pre class="prettyprint notranslate"> javac Subclass java Subclass </pre></code><br><br><code><pre class="result notranslate"> The value of the variable named age in super class is: 24 </pre></code><br>'),
(161, 'IS-A Relationship', 'IS-A is a way of saying : This object is a type of that object. Let us see how the <b>extends</b> keyword is used to achieve inheritance.Now, based on the above example, In Object Oriented terms, the following are true &minus; <li><p>Animal is the superclass of Mammal class.</p></li> <li><p>Animal is the superclass of Reptile class.</p></li> <li><p>Mammal and Reptile are subclasses of Animal class.</p></li> <li><p>Dog is the subclass of both Mammal and Animal classes.</p></li> Now, if we consider the IS-A relationship, we can say &minus; <li><p>Mammal IS-A Animal</p></li> <li><p>Reptile IS-A Animal</p></li> <li><p>Dog IS-A Mammal</p></li> <li><p>Hence : Dog IS-A Animal as well</p></li> With use of the extends keyword the subclasses will be able to inherit all the properties of the superclass except for the private properties of the superclass.We can assure that Mammal is actually an Animal with the use of the instance operator.', '<br><code><pre class="prettyprint notranslate" id="animal"> public class Animal{ }  public class Mammal extends Animal{ }  public class Reptile extends Animal{ }  public class Dog extends Mammal{ } </pre></code><br>'),
(162, 'Example', 'This would produce the following result &minus;Since we have a good understanding of the <b>extends</b> keyword let us look into how the <b>implements </b> keyword is used to get the IS-A relationship.Generally, the <b>implements</b> keyword is used with classes to inherit the properties of an interface. Interfaces can never be extended by a class.', '<br><code><pre class="prettyprint notranslate tryit"> class Animal{ }  class Mammal extends Animal{ }  class Reptile extends Animal{ }  public class Dog extends Mammal{     public static void main(String args[]){        Animal a = new Animal();       Mammal m = new Mammal();       Dog d = new Dog();        System.out.println(m instanceof Animal);       System.out.println(d instanceof Mammal);       System.out.println(d instanceof Animal);    } } </pre></code><br><br><code><pre class="result notranslate"> true true true </pre></code><br>'),
(163, 'The instanceof Keyword', 'Let us use the <b>instanceof</b> operator to check determine whether Mammal is actually an Animal, and dog is actually an AnimalThis would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> interface Animal{}  class Mammal implements Animal{}  public class Dog extends Mammal{     public static void main(String args[]){        Mammal m = new Mammal();       Dog d = new Dog();        System.out.println(m instanceof Animal);       System.out.println(d instanceof Mammal);       System.out.println(d instanceof Animal);    } }  </pre></code><br><br><code><pre class="result notranslate"> true true true </pre></code><br>');
INSERT INTO `text` (`textid`, `topic`, `content`, `code`) VALUES
(164, 'HAS-A relationship', 'These relationships are mainly based on the usage. This determines whether a certain class <b>HAS-A </b> certain thing. This relationship helps to reduce duplication of code as well as bugs.Lets us look into an example &minus;This shows that class Van HAS-A Speed. By having a separate class for Speed, we do not have to put the entire code that belongs to speed inside the Van class., which makes it possible to reuse the Speed class in multiple applications.In Object-Oriented feature, the users do not need to bother about which object is doing the real work. To achieve this, the Van class hides the implementation details from the users of the Van class. So basically what happens is the users would ask the Van class to do a certain action and the Van class will either do the work by itself or ask another class to perform the action.', '<br><code><pre class="prettyprint notranslate"> public class Vehicle{} public class Speed{}  public class Van extends Vehicle{ 	private Speed sp; }  </pre></code><br>'),
(165, 'Java - Overriding', 'In the previous chapter, we talked about super classes and sub classes. If a class inherits a method from its super class, then there is a chance to override the method provided that it is not marked final.The benefit of overriding is: ability to define a behaviour thats specific to the subclass type which means a subclass can implement a parent class method based on its requirement.In object-oriented terms, overriding means to override the functionality of an existing method.', ''),
(166, 'Example:', 'Let us look at an example.This would produce the following result:In the above example, you can see that the even though <b>b</b> is a type of Animal it runs the move method in the Dog class. The reason for this is: In compile time, the check is made on the reference type. However, in the runtime, JVM figures out the object type and would run the method that belongs to that particular object.Therefore, in the above example, the program will compile properly since Animal class has the method move. Then, at the runtime, it runs the method specific for that object.Consider the following example :This would produce the following result:This program will throw a compile time error since bs reference type Animal doesnt have a method by the name of bark.', '<br><code><pre class="prettyprint notranslate tryit"> class Animal{     public void move(){       System.out.println("Animals can move");    } }  class Dog extends Animal{     public void move(){       System.out.println("Dogs can walk and run");    } }  public class TestDog{     public static void main(String args[]){       Animal a = new Animal(); // Animal reference and object       Animal b = new Dog(); // Animal reference but Dog object        a.move();// runs the method in Animal class        b.move();//Runs the method in Dog class    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Animals can move Dogs can walk and run </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> class Animal{     public void move(){       System.out.println("Animals can move");    } }  class Dog extends Animal{     public void move(){       System.out.println("Dogs can walk and run");    }    public void bark(){       System.out.println("Dogs can bark");    } }  public class TestDog{     public static void main(String args[]){       Animal a = new Animal(); // Animal reference and object       Animal b = new Dog(); // Animal reference but Dog object        a.move();// runs the method in Animal class       b.move();//Runs the method in Dog class       b.bark();    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> TestDog.java:30: cannot find symbol symbol  : method bark() location: class Animal                 b.bark();                  ^ </pre></code><br>'),
(167, 'Rules for method overriding:', ' <li><p>The argument list should be exactly the same as that of the overridden method.</p></li> <li><p>The return type should be the same or a subtype of the return type declared in the original overridden method in the superclass.</p></li> <li><p>The access level cannot be more restrictive than the overridden methods access level. For example: if the superclass method is declared public then the overridding method in the sub class cannot be either private or protected.</p></li> <li><p>Instance methods can be overridden only if they are inherited by the subclass.</p></li> <li><p>A method declared final cannot be overridden.</p></li> <li><p>A method declared static cannot be overridden but can be re-declared.</p></li> <li><p>If a method cannot be inherited, then it cannot be overridden.</p></li> <li><p>A subclass within the same package as the instances superclass can override any superclass method that is not declared private or final.</p></li> <li><p>A subclass in a different package can only override the non-final methods declared public or protected.</p></li> <li><p>An overriding method can throw any uncheck exceptions, regardless of whether the overridden method throws exceptions or not. However the overriding method should not throw checked exceptions that are new or broader than the ones declared by the overridden method. The overriding method can throw narrower or fewer exceptions than the overridden method.</p></li> <li><p>Constructors cannot be overridden.</p></li> ', ''),
(168, 'Java - Polymorphism', 'Polymorphism is the ability of an object to take on many forms. The most common use of polymorphism in OOP occurs when a parent class reference is used to refer to a child class object.Any Java object that can pass more than one IS-A test is considered to be polymorphic. In Java, all Java objects are polymorphic since any object will pass the IS-A test for their own type and for the class Object.It is important to know that the only possible way to access an object is through a reference variable. A reference variable can be of only one type. Once declared, the type of a reference variable cannot be changed.The reference variable can be reassigned to other objects provided that it is not declared final. The type of the reference variable would determine the methods that it can invoke on the object.A reference variable can refer to any object of its declared type or any subtype of its declared type. A reference variable can be declared as a class or interface type.', ''),
(169, 'Example:', 'Let us look at an example.Now, the Deer class is considered to be polymorphic since this has multiple inheritance. Following are true for the above example: <li><p>A Deer IS-A Animal</p></li> <li><p>A Deer IS-A Vegetarian</p></li> <li><p>A Deer IS-A Deer </p></li> <li><p>A Deer IS-A Object</p></li> When we apply the reference variable facts to a Deer object reference, the following declarations are legal:All the reference variables d,a,v,o refer to the same Deer object in the heap.', '<br><code><pre class="prettyprint notranslate"> public interface Vegetarian{} public class Animal{} public class Deer extends Animal implements Vegetarian{} </pre></code><br><br><code><pre class="prettyprint notranslate"> Deer d = new Deer(); Animal a = d; Vegetarian v = d; Object o = d; </pre></code><br>'),
(170, 'Java - Abstraction', 'As per dictionary, Abstraction is the quality of dealing with ideas rather than events. for example when you consider the case of e-mail, complex details such as what happens soon you send an e-mail, the protocol your email server uses are hidden from the user, therefore to send an e-mail you just need to type the content, mention the address of the receiver and click send.like wise in Object oriented programming  Abstraction is a process process of hiding the implementation details from the user, only the functionality will be provided to the user. In other words user will have the information on what the object does instead of how it does it.In Java Abstraction is achieved using Abstract classes, and Interfaces.', ''),
(171, 'Abstract Class ', 'A class which contains the <b>abstract</b> keyword in its declaration is known as abstract class. <li><p>Abstract classes may or may not contain <i>abstract methods</i> ie., methods with out body ( public void get(); )</p></li> <li><p>But, if a class have at least one abstract method, then the class <b>must</b> be declared abstract.</p></li> <li><p>If a class is declared abstract it cannot be instantiated.</p></li> <li><p>To use an abstract class you have to inherit it from another class, provide implementations to the abstract methods in it.</p></li> <li><p>If you inherit an abstract class you have to provide implementations to all the abstract methods in it.</p></li>  ', ''),
(172, 'Example', 'You can observe that except abstract methods the Employee class is same as normal class in Java. The class is now abstract, but it still has three fields, seven methods, and one constructor.Now you can try to instantiate the Employee class as shown below:When you compile the above class, it gives you the following error:', '<br><code><pre class="prettyprint notranslate" id="employee"> /* File name : Employee.java */ public abstract class Employee {    private String name;    private String address;    private int number;    public Employee(String name, String address, int number)    {       System.out.println("Constructing an Employee");       this.name = name;       this.address = address;       this.number = number;    }    public double computePay()    {      System.out.println("Inside Employee computePay");      return 0.0;    }    public void mailCheck()    {       System.out.println("Mailing a check to " + this.name        + " " + this.address);    }    public String toString()    {       return name + " " + address + " " + number;    }    public String getName()    {       return name;    }    public String getAddress()    {       return address;    }    public void setAddress(String newAddress)    {       address = newAddress;    }    public int getNumber()    {      return number;    } } </pre></code><br><br><code><pre class="prettyprint notranslate tryit" title="employee"> /* File name : AbstractDemo.java */ public class AbstractDemo {    public static void main(String [] args)    {       /* Following is not allowed and would raise error */       Employee e = new Employee("George W.", "Houston, TX", 43);        System.out.println("\n Call mailCheck using Employee reference--");       e.mailCheck();     } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Employee.java:46: Employee is abstract; cannot be instantiated       Employee e = new Employee("George W.", "Houston, TX", 43);                    ^ 1 error </pre></code><br>'),
(173, 'Inheriting the Abstract Class:', 'We can inherit the properties of Employee class just like concrete class as shown below:Here, you cannot instantiate the Employee class, but you can instantiate the Salary Class, and using this instance you can access the all the three fields and seven methods of Employee class as shown below.This produces the following result:', '<br><code><pre class="prettyprint notranslate" id="salary"> /* File name : Salary.java */ public class Salary extends Employee {    private double salary; //Annual salary    public Salary(String name, String address, int number, double       salary)    {        super(name, address, number);        setSalary(salary);    }    public void mailCheck()    {        System.out.println("Within mailCheck of Salary class ");        System.out.println("Mailing check to " + getName()        + " with salary " + salary);    }    public double getSalary()    {        return salary;    }    public void setSalary(double newSalary)    {        if(newSalary &gt;= 0.0)        {           salary = newSalary;        }    }    public double computePay()    {       System.out.println("Computing salary pay for " + getName());       return salary/52;    } } </pre></code><br><br><code><pre class="prettyprint notranslate tryit" title="employee, salary"> /* File name : AbstractDemo.java */ public class AbstractDemo {    public static void main(String [] args)    {       Salary s = new Salary("Mohd Mohtashim", "Ambehta, UP", 3, 3600.00);       Employee e = new Salary("John Adams", "Boston, MA", 2, 2400.00);        System.out.println("Call mailCheck using Salary reference --");       s.mailCheck();        System.out.println("\n Call mailCheck using Employee reference--");       e.mailCheck();     } } </pre></code><br><br><code><pre class="result notranslate"> Constructing an Employee Constructing an Employee Call mailCheck using  Salary reference -- Within mailCheck of Salary class ailing check to Mohd Mohtashim with salary 3600.0  Call mailCheck using Employee reference-- Within mailCheck of Salary class ailing check to John Adams with salary 2400. </pre></code><br>'),
(174, 'Java - Encapsulation', 'Encapsulation is one of the four fundamental OOP concepts. The other three are inheritance, polymorphism, and abstraction.Encapsulation in Java is a mechanism of wrapping the data (variables) and code acting on the data (methods) together as as single unit. In encapsulation the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class, therefore it is also known as data hiding.To achieve encapsulation in Java <li><p>Declare the variables of a class as private.</p></li> <li><p>Provide public setter and getter methods to modify and view the variables values.</p></li> ', ''),
(175, 'Example:', 'Below given is an example that demonstrates how to achieve  Encapsulation in Java:The public setXXX() and getXXX() methods are the access points of the instance variables of the EncapTest class. Normally, these methods are referred as getters and setters. Therefore any class that wants to access the variables should access them through these getters and setters.The variables of the EncapTest class can be accessed as below::This would produce the following result:', '<br><code><pre class="prettyprint notranslate" id="encaptest"> /* File name : EncapTest.java */ public class EncapTest{     private String name;    private String idNum;    private int age;     public int getAge(){       return age;    }     public String getName(){       return name;    }     public String getIdNum(){       return idNum;    }     public void setAge( int newAge){       age = newAge;    }     public void setName(String newName){       name = newName;    }     public void setIdNum( String newId){       idNum = newId;    } } </pre></code><br><br><code><pre class="prettyprint notranslate tryit" title="encaptest"> /* File name : RunEncap.java */ public class RunEncap{     public static void main(String args[]){       EncapTest encap = new EncapTest();       encap.setName("James");       encap.setAge(20);       encap.setIdNum("12343ms");        System.out.print("Name : " + encap.getName() + " Age : " + encap.getAge());     } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Name : James Age : 20 </pre></code><br>'),
(176, 'Java - Packages', 'Packages are used in Java in order to prevent naming conflicts, to control access, to make searching/locating and usage of classes, interfaces, enumerations and annotations easier, etc.A Package can be defined as a grouping of related types (classes, interfaces, enumerations and annotations ) providing access protection and name space management.Some of the existing packages in Java are:: <li><p><b>java.lang</b> - bundles the fundamental classes</p></li> <li><p><b>java.io</b> -  classes for input , output functions are bundled in this package</p></li> Programmers can define their own packages to bundle group of classes/interfaces, etc. It is a good practice to group related classes implemented by you so that a programmer can easily determine that the classes, interfaces, enumerations, annotations are related.Since the package creates a new namespace there wont be any name conflicts with names in other packages. Using packages, it is easier to provide access control and it is also easier to locate the related classes.', ''),
(177, 'Creating a package:', 'While creating a package, you should choose a name for the package and include a <b>package</b> statement along with that name at the top of every source file that contains the classes, interfaces, enumerations, and annotation types that you want to include in the package.The <b>package</b> statement should be the first line in the source file. There can be only one package statement in each source file, and it applies to all types in the file. If a package statement is not used then the class, interfaces, enumerations, and annotation types will  be placed in the current default package.To compile the Java programs with package statements you have to do use -d option as shown below.  <pre class="prettyprint notranslate"> javac -d <b>Destination_folder file_name</b>.java</pre>  Then a folder with the given package name is created in the specified destination, and the compiled class files will be placed in that folder  ', ''),
(178, 'Example:', 'Let us look at an example that creates a package called <b>animals</b>. It is a good practice to use names of packages with lower case letters to avoid any conflicts with the names of classes, interfaces.Below given package example contains interface named <i>animals</i>:Now, let us implement the above interface  in the same package <i>animals</i>:Now compile the java files as shown below:Now a package/folder with the name <b>animals</b> will be created in the current directory and these class files will be placed in it as shown below.&nbsp;You can execute the class file with in the package and get the result as shown below.', '<br><code><pre class="prettyprint notranslate" id="animal"> /* File name : Animal.java */ package animals; interface Animal {    public void eat();    public void travel(); } </pre></code><br><br><code><pre class="prettyprint notranslate tryit" title="animal"> package animals;  /* File name : MammalInt.java */ public class MammalInt implements Animal{     public void eat(){       System.out.println("Mammal eats");    }     public void travel(){       System.out.println("Mammal travels");    }      public int noOfLegs(){       return 0;    }     public static void main(String args[]){       MammalInt m = new MammalInt();       m.eat();       m.travel();    } }  </pre></code><br><br><code><pre class="result notranslate"> $ javac -d . Animal.java  $ javac -d . MammalInt.java </pre></code><br><br><code><pre class="result notranslate"> $ java animals.MammalInt ammal eats ammal travels</pre></code><br>'),
(179, 'The import Keyword:', 'If a class wants to use another class in the same package, the package name does not need to be used. Classes in the same package find each other without any special syntax.', ''),
(180, 'Example:', 'Here, a class named Boss is added to the payroll package that already contains Employee. The Boss can then refer to the Employee class without using the payroll prefix, as demonstrated by the following Boss class.What happens if the Employee class is not in the payroll package? The Boss class must then use one of the following techniques for referring to a class in a different package. <li><p>The fully qualified name of the class can be used. For example:</p></li>  <li><p>The package can be imported using the import keyword and the wild card (*). For example:</p></li>  <li><p>The class itself can be imported using the import keyword. For example:</p></li> <b>Note:</b> A class file can contain any number of import statements. The import statements must appear after the package statement and before the class declaration.', '<br><code><pre class="prettyprint notranslate"> package payroll;  public class Boss {    public void payEmployee(Employee e)    {       e.mailCheck();    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> payroll.Employee </pre></code><br><br><code><pre class="prettyprint notranslate"> import payroll.*; </pre></code><br><br><code><pre class="prettyprint notranslate"> import payroll.Employee; </pre></code><br>'),
(181, 'The Directory Structure of Packages:', 'Two major results occur when a class is placed in a package: <li><p>The name of the package becomes a part of the name of the class, as we just discussed in the previous section.</p></li> <li><p>The name of the package must match the directory structure where the corresponding bytecode resides.</p></li> Here is simple way of managing your files in Java:Put the source code for a class, interface, enumeration, or annotation type in a text file whose name is the simple name of the type and whose extension is <b>.java</b>. For example:Now, put the source file in a directory whose name reflects the name of the package to which the class belongs:Now, the qualified class name and  pathname would be as below: <li><p>Class name -&gt;  vehicle.Car</p></li> <li><p>Path name -&gt;   vehicleCar.java (in windows)</p></li> In general, a company uses its reversed Internet domain name for its package names.  Example: A companys Internet domain name is apple.com, then all its  package names would start with com.apple. Each component of the package name corresponds to a subdirectory. Example: The company had a com.apple.computers package that contained a Dell.java source file, it would be contained in a series of subdirectories like this:At the time of compilation, the compiler creates a different output file for each class, interface and enumeration defined in it. The base name of the output file is the name of the type, and its extension is <b> .class</b>For example:Now, compile this file as follows using -d option:This would put compiled files as follows:You can import all the classes or interfaces defined in <i>comapplecomputers</i> as follows:Like the .java source files, the compiled .class files should be in a series of directories that reflect the package name. However, the path to the .class files does not have to be the same as the path to the .java source files. You can arrange your source and class directories separately, as: By doing this, it is possible to give the classes directory to other programmers without revealing your sources. You also need to manage source and class files in this manner so that the compiler and the Java Virtual Machine (JVM) can find all the types your program uses. The full path to the classes directory, &lt;path-two&gt;classes, is called the class path, and is set with the CLASSPATH system variable. Both the compiler and the JVM construct the path to your .class files by adding the package name to the class path.Say &lt;path-two&gt;classes is the class path, and the package name is com.apple.computers, then the compiler and JVM will look for .class files in &lt;path-two&gt;classescomapplecompters.A class path may include several paths. Multiple paths should be separated by a semicolon (Windows) or colon (Unix). By default, the compiler and the JVM search the current directory and the JAR file containing the Java platform classes so that these directories are automatically in the class path.', '<br><code><pre class="prettyprint notranslate"> // File Name :  Car.java  package vehicle;  public class Car {    // Class implementation.    } </pre></code><br><br><code><pre class="prettyprint notranslate"> ....vehicleCar.java </pre></code><br><br><code><pre class="prettyprint notranslate"> ....comapplecomputersDell.java </pre></code><br><br><code><pre class="prettyprint notranslate"> // File Name: Dell.java  package com.apple.computers; public class Dell{        } class Ups{        } </pre></code><br><br><code><pre class="prettyprint notranslate"> $javac -d . Dell.java </pre></code><br><br><code><pre class="prettyprint notranslate"> .comapplecomputersDell.class .comapplecomputersUps.class </pre></code><br><br><code><pre class="prettyprint notranslate"> import com.apple.computers.*; </pre></code><br><br><code><pre class="prettyprint notranslate"> &lt;path-one&gt;sourcescomapplecomputersDell.java  &lt;path-two&gt;classescomapplecomputersDell.class </pre></code><br>'),
(182, 'Java - Data Structures', 'The data structures provided by the Java utility package are very powerful and perform a wide range of functions. These data structures consist of the following interface and classes: <li><p>Enumeration</p></li> <li><p>BitSet</p></li> <li><p>Vector</p></li> <li><p>Stack</p></li> <li><p>Dictionary</p></li> <li><p>Hashtable</p></li> <li><p>Properties</p></li> All these classes are now legacy and Java-2 has introduced a new framework called Collections Framework, which is discussed in next tutorial:', ''),
(183, 'The Enumeration:', 'The Enumeration interface isnt itself a data structure, but it is very important within the context of other data structures. The Enumeration interface defines a means to retrieve successive elements from a data structure.For example, Enumeration defines a method called nextElement that is used to get the next element in a data structure that contains multiple elements.To have more detail about this interface, check <a href="/java/java_enumeration_interface.htm">The Enumeration</a>.', ''),
(184, 'The BitSet', 'The BitSet class implements a group of bits or flags that can be set and cleared individually.This class is very useful in cases where you need to keep up with a set of Boolean values; you just assign a bit to each value and set or clear it as appropriate.To have more detail about this class, check <a href="/java/java_bitset_class.htm">The BitSet</a>.', ''),
(185, 'The Vector', 'The Vector class is similar to a traditional Java array, except that it can grow as necessary to accommodate new elements.Like an array, elements of a Vector object can be accessed via an index into the vector. The nice thing about using the Vector class is that you dont have to worry about setting it to a specific size upon creation; it shrinks and grows automatically when necessary.To have more detail about this class, check <a href="/java/java_vector_class.htm">The Vector</a>.', ''),
(186, 'The Stack', 'The Stack class implements a last-in-first-out (LIFO) stack of elements.You can think of a stack literally as a vertical stack of objects; when you add a new element, it gets stacked on top of the others.When you pull an element off the stack, it comes off the top. In other words, the last element you added to the stack is the first one to come back off.To have more detail about this class, check <a href="/java/java_stack_class.htm">The Stack</a>.', ''),
(187, 'The Dictionary', 'The Dictionary class is an abstract class that defines a data structure for mapping keys to values.This is useful in cases where you want to be able to access data via a particular key rather than an integer index.Since the Dictionary class is abstract, it provides only the framework for a key-mapped data structure rather than a specific implementation.To have more detail about this class, check <a href="/java/java_dictionary_class.htm">The Dictionary</a>.', ''),
(188, 'The Hashtable', 'The Hashtable class provides a means of organizing data based on some user-defined key structure.For example, in an address list hash table you could store and sort data based on a key such as ZIP code rather than on a persons name.The specific meaning of keys in regard to hash tables is totally dependent on the usage of the hash table and the data it contains.To have more detail about this class, check <a href="/java/java_hashtable_class.htm">The Hashtable</a>.', ''),
(189, 'Java Collections Framework', 'Prior to Java 2, Java provided ad hoc classes such as <b>Dictionary, Vector, Stack</b>, and <b>Properties</b> to store and manipulate groups of objects. Although these classes were quite useful, they lacked a central, unifying theme. Thus, the way that you used Vector was different from the way that you used Properties.The collections framework was designed to meet several goals. <li><p>The framework had to be high-performance. The implementations for the fundamental collections (dynamic arrays, linked lists, trees, and hashtables) are highly efficient.</p></li> <li><p>The framework had to allow different types of collections to work in a similar manner and with a high degree of interoperability.</p></li> <li><p>Extending and/or adapting a collection had to be easy.</p></li> Towards this end, the entire collections framework is designed around a set of standard interfaces. Several standard implementations such as <b>LinkedList, HashSet,</b> and <b>TreeSet</b>, of these interfaces are provided that you may use as-is and you may also implement your own collection, if you choose.A collections framework is a unified architecture for representing and manipulating collections. All collections frameworks contain the following: <li><p><b>Interfaces:</b> These are abstract data types that represent collections. Interfaces allow collections to be manipulated independently of the details of their representation. In object-oriented languages, interfaces generally form a hierarchy.</p></li> <li><p><b>Implementations, i.e., Classes:</b> These are the concrete implementations of the collection interfaces. In essence, they are reusable data structures.</p></li> <li><p><b>Algorithms:</b> These are the methods that perform useful computations, such as searching and sorting, on objects that implement collection interfaces. The algorithms are said to be polymorphic: that is, the same method can be used on many different implementations of the appropriate collection interface.</p></li> In addition to collections, the framework defines several map interfaces and classes. Maps store key/value pairs. Although maps are not <i>collections</i> in the proper use of the term, but they are fully integrated with collections.', ''),
(190, 'The Collection Interfaces:', 'The collections framework defines several interfaces. This section provides an overview of each interface:', ''),
(191, 'The Collection Classes:', 'Java provides a set of standard collection classes that implement Collection interfaces. Some of the classes provide full implementations that can be used as-is and others are abstract class, providing skeletal implementations that are used as starting points for creating concrete collections.The standard collection classes are summarized in the following table:The <i>AbstractCollection, AbstractSet, AbstractList, AbstractSequentialList</i> and <i>AbstractMap</i> classes provide skeletal implementations of the core collection interfaces, to minimize the effort required to implement them.The following legacy classes defined by java.util have been discussed in previous tutorial:', ''),
(192, 'The Collection Algorithms:', 'The collections framework defines several algorithms that can be applied to collections and maps. These algorithms are defined as static methods within the Collections class.Several of the methods can throw a <b>ClassCastException</b>, which occurs when an attempt is made to compare incompatible types, or an <b>UnsupportedOperationException</b>, which occurs when an attempt is made to modify an unmodifiable collection.Collections define three static variables: EMPTY_SET, EMPTY_LIST, and EMPTY_MAP. All are immutable.', ''),
(193, 'How to use an Iterator ?', 'Often, you will want to cycle through the elements in a collection. For example, you might want to display each element.The easiest way to do this is to employ an iterator, which is an object that implements either the Iterator or the ListIterator interface.Iterator enables you to cycle through a collection, obtaining or removing elements. ListIterator extends Iterator to allow bidirectional traversal of a list and the modification of elements.', ''),
(194, 'How to use a Comparator ?', 'Both TreeSet and TreeMap store elements in sorted order. However, it is the comparator that defines precisely what <i>sorted order</i> means.This interface lets us sort a given collection any number of different ways. Also this interface can be used to sort any instances of any class (even classes we cannot modify).', ''),
(195, 'Java - Generics', 'It would be nice if we could write a single sort method that could sort the elements in an Integer array, a String array or an array of any type that supports ordering.Java <b>Generic</b> methods and generic classes enable programmers to specify, with a single method declaration, a set of related methods or, with a single class declaration, a set of related types, respectively.Generics also provide compile-time type safety that allows programmers to catch invalid types at compile time.Using Java Generic concept, we might write a generic method for sorting an array of objects, then invoke the generic method with Integer arrays, Double arrays, String arrays and so on, to sort the array elements.', ''),
(196, 'Generic Methods:', 'You can write a single generic method declaration that can be called with arguments of different types. Based on the types of the arguments passed to the generic method, the compiler handles each method call appropriately. Following are the rules to define Generic Methods: <li><p>All generic method declarations have a type parameter section delimited by angle brackets (&lt; and &gt;) that precedes the methods return type ( &lt; E &gt; in the next example).</p></li> <li><p>Each type parameter section contains one or more type parameters separated by commas. A type parameter, also known as a type variable, is an identifier that specifies a generic type name.</p></li> <li><p>The type parameters can be used to declare the return type and act as placeholders for the types of the arguments passed to the generic method, which are known as actual type arguments.</p></li> <li><p>A generic methods body is declared like that of any other method. Note that type parameters can represent only reference types, not primitive types (like int, double and char). </p></li> ', ''),
(197, 'Example:', 'Following example illustrates how we can print array of different type using a single Generic method:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class GenericMethodTest {    // generic method printArray                             public static &lt; E &gt; void printArray( E[] inputArray )    {       // Display array elements                        for ( E element : inputArray ){                     System.out.printf( "%s ", element );          }          System.out.println();     }      public static void main( String args[] )     {         // Create arrays of Integer, Double and Character         Integer[] intArray = { 1, 2, 3, 4, 5 };         Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };         Character[] charArray = { H, E, L, L, O };          System.out.println( "Array integerArray contains:" );         printArray( intArray  ); // pass an Integer array          System.out.println( "\nArray doubleArray contains:" );         printArray( doubleArray ); // pass a Double array          System.out.println( "\nArray characterArray contains:" );         printArray( charArray ); // pass a Character array     }  } </pre></code><br><br><code><pre class="result notranslate"> Array integerArray contains: 1 2 3 4 5 6  Array doubleArray contains: 1.1 2.2 3.3 4.4   Array characterArray contains: H E L L O </pre></code><br>'),
(198, 'Bounded Type Parameters:', 'There may be times when youll want to restrict the kinds of types that are allowed to be passed to a type parameter. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. This is what bounded type parameters are for.To declare a bounded type parameter, list the type parameters name, followed by the extends keyword, followed by its upper bound.', ''),
(199, 'Example:', 'Following example illustrates how extends is used in a general sense to mean either "extends" (as in classes) or "implements" (as in interfaces). This example is Generic method to return the largest of three Comparable objects:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class MaximumTest {    // determines the largest of three Comparable objects    public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z)    {                             T max = x; // assume x is initially the largest              if ( y.compareTo( max ) &gt; 0 ){          max = y; // y is the largest so far       }       if ( z.compareTo( max ) &gt; 0 ){          max = z; // z is the largest now                        }       return max; // returns the largest object       }    public static void main( String args[] )    {       System.out.printf( "Max of %d, %d and %d is %d\n\n",                     3, 4, 5, maximum( 3, 4, 5 ) );        System.out.printf( "Maxm of %.1f,%.1f and %.1f is %.1f\n\n",                    6.6, 8.8, 7.7, maximum( 6.6, 8.8, 7.7 ) );        System.out.printf( "Max of %s, %s and %s is %s\n","pear",          "apple", "orange", maximum( "pear", "apple", "orange" ) );    } } </pre></code><br><br><code><pre class="result notranslate"> aximum of 3, 4 and 5 is 5  aximum of 6.6, 8.8 and 7.7 is 8.8  aximum of pear, apple and orange is pear </pre></code><br>'),
(200, 'Generic Classes:', 'A generic class declaration looks like a non-generic class declaration, except that the class name is followed by a type parameter section.As with generic methods, the type parameter section of a generic class can have one or more type parameters separated by commas. These classes are known as parameterized classes or parameterized types because they accept one or more parameters.', ''),
(201, 'Java - Serialization', 'Java provides a mechanism, called object serialization where an object can be represented as a sequence of bytes that includes the objects data as well as information about the objects type and the types of data stored in the object.After a serialized object has been written into a file, it can be read from the file and deserialized that is, the type information and bytes that represent the object and its data can be used to recreate the object in memory.Most impressive is that the entire process is JVM independent, meaning an object can be serialized on one platform and deserialized on an entirely different platform.Classes <b>ObjectInputStream</b> and <b>ObjectOutputStream</b> are high-level streams that contain the methods for serializing and deserializing an object.The ObjectOutputStream class contains many write methods for writing various data types, but one method in particular stands out:The above method serializes an Object and sends it to the output stream. Similarly, the ObjectInputStream class contains the following method for deserializing an object:This method retrieves the next Object out of the stream and deserializes it. The return value is Object, so you will need to cast it to its appropriate data type.To demonstrate how serialization works in Java, I am going to use the Employee class that we discussed early on in the book. Suppose that we have the following Employee class, which implements the Serializable interface:Notice that for a class to be serialized successfully, two conditions must be met: <li><p>The class must implement the java.io.Serializable interface.</p></li> <li><p>All of the fields in the class must be serializable. If a field is not serializable, it must be marked <b>transient</b>.</p></li> If you are curious to know if a Java Standard  Class is  serializable or not, check the documentation for the class. The test is simple: If the class implements java.io.Serializable, then it is serializable; otherwise, its not.', '<br><code><pre class="prettyprint notranslate"> public final void writeObject(Object x) throws IOException </pre></code><br><br><code><pre class="prettyprint notranslate"> public final Object readObject() throws IOException, ClassNotFoundException </pre></code><br><br><code><pre class="prettyprint notranslate"> public class Employee implements java.io.Serializable {    public String name;    public String address;    public transient int SSN;    public int number;        public void mailCheck()    {       System.out.println("Mailing a check to " + name + " " + address);    } } </pre></code><br>'),
(202, 'Serializing an Object:', 'The ObjectOutputStream class is used to serialize an Object. The following SerializeDemo program instantiates an Employee object and serializes it to a file.When the program is done executing, a file named employee.ser is created. The program does not generate any output, but study the code and try to determine what the program is doing.<b>Note:</b> When serializing an object to a file, the standard convention in Java is to give the file a <b>.ser </b> extension.', '<br><code><pre class="prettyprint notranslate"> import java.io.*;  public class SerializeDemo {    public static void main(String [] args)    {       Employee e = new Employee();       e.name = "Reyan Ali";       e.address = "Phokka Kuan, Ambehta Peer";       e.SSN = 11122333;       e.number = 101;              try       {          FileOutputStream fileOut =          new FileOutputStream("/tmp/employee.ser");          ObjectOutputStream out = new ObjectOutputStream(fileOut);          out.writeObject(e);          out.close();          fileOut.close();          System.out.printf("Serialized data is saved in /tmp/employee.ser");       }catch(IOException i)       {           i.printStackTrace();       }    } } </pre></code><br>'),
(203, 'Java - Networking', 'The term <i>network programming</i> refers to writing programs that execute across multiple devices (computers), in which the devices are all connected to each other using a network.The java.net package of the J2SE APIs contains a collection of classes and interfaces that provide the low-level communication details, allowing you to write programs that focus on solving the problem at hand.The java.net package provides support for the two common network protocols: <li><p><b>TCP:</b> TCP stands for Transmission Control Protocol, which allows for reliable communication between two applications. TCP is typically used over the Internet Protocol, which is referred to as TCP/IP.</p></li> <li><p><b>UDP:</b> UDP stands for User Datagram Protocol, a connection-less protocol that allows for packets of data to be transmitted between applications.</p></li> This tutorial gives good understanding on the following two subjects: <li><p><b>Socket Programming</b>: This is most widely used concept in Networking and it has been explained in very detail.</p></li> <li><p><b>URL Processing</b>: This would be covered separately. Click here to learn about <a href="/java/java_url_processing.htm" title="URL Processing">URL Processing</a> in Java language.</p></li> ', ''),
(204, 'Socket Programming:', 'Sockets provide the communication mechanism between two computers using TCP. A client program creates a socket on its end of the communication and attempts to connect that socket to a server.When the connection is made, the server creates a socket object on its end of the communication. The client and server can now communicate by writing to and reading from the socket.The java.net.Socket class represents a socket, and the java.net.ServerSocket class provides a mechanism for the server program to listen for clients and establish connections with them.The following steps occur when establishing a TCP connection between two computers using sockets: <li><p>The server instantiates a ServerSocket object, denoting which port number communication is to occur on.</p></li> <li><p>The server invokes the accept() method of the ServerSocket class. This method waits until a client connects to the server on the given port.</p></li> <li><p>After the server is waiting, a client instantiates a Socket object, specifying the server name and port number to connect to.</p></li> <li><p>The constructor of the Socket class attempts to connect the client to the specified server and port number. If communication is established, the client now has a Socket object capable of communicating with the server.</p></li> <li><p>On the server side, the accept() method returns a reference to a new socket on the server that is connected to the clients socket.</p></li> After the connections are established, communication can occur using I/O streams. Each socket has both an OutputStream and an InputStream. The clients OutputStream is connected to the servers InputStream, and the clients InputStream is connected to the servers OutputStream.TCP is a twoway communication protocol, so data can be sent across both streams at the same time. There are following usefull classes providing complete set of methods to implement sockets.', ''),
(205, 'ServerSocket Class Methods:', 'The <b>java.net.ServerSocket</b> class is used by server applications to obtain a port and listen for client requests The ServerSocket class has four constructors:If the ServerSocket constructor does not throw an exception, it means that your application has successfully bound to the specified port and is ready for client requests.Here are some of the common methods of the ServerSocket class:When the ServerSocket invokes accept(), the method does not return until a client connects. After a client does connect, the ServerSocket creates a new Socket on an unspecified port and returns a reference to this new Socket. A TCP connection now exists between the client and server, and communication can begin.', ''),
(206, 'Socket Class Methods:', 'The <b>java.net.Socket</b> class represents the socket that both the client and server use to communicate with each other. The client obtains a Socket object by instantiating one, whereas the server obtains a Socket object from the return value of the accept() method.The Socket class has five constructors that a client uses to connect to a server:When the Socket constructor returns, it does not simply instantiate a Socket object but it actually attempts to connect to the specified server and port.Some methods of interest in the Socket class are listed here. Notice that both the client and server have a Socket object, so these methods can be invoked by both the client and server.', ''),
(207, 'InetAddress Class Methods:', 'This class represents an Internet Protocol (IP) address. Here are following usefull methods which you would need while doing socket programming:', ''),
(208, 'Socket Client Example:', 'The following GreetingClient is a client program that connects to a server by using a socket and sends a greeting, and then waits for a response.', '<br><code><pre class="prettyprint notranslate"> // File Name GreetingClient.java  import java.net.*; import java.io.*;  public class GreetingClient {    public static void main(String [] args)    {       String serverName = args[0];       int port = Integer.parseInt(args[1]);       try       {          System.out.println("Connecting to " + serverName + 		 " on port " + port);          Socket client = new Socket(serverName, port);          System.out.println("Just connected to "  		 + client.getRemoteSocketAddress());          OutputStream outToServer = client.getOutputStream();          DataOutputStream out = new DataOutputStream(outToServer);          out.writeUTF("Hello from "                       + client.getLocalSocketAddress());          InputStream inFromServer = client.getInputStream();          DataInputStream in =                         new DataInputStream(inFromServer);          System.out.println("Server says " + in.readUTF());          client.close();       }catch(IOException e)       {          e.printStackTrace();       }    } } </pre></code><br>'),
(209, 'Java - Sending Email', 'To send an e-mail using your Java Application is simple enough but to start with you should have <b>JavaMail API</b> and <b>Java Activation Framework (JAF)</b> installed on your machine. <li><p>You can download  latest version of <a href="http://java.sun.com/products/javamail/" target="_blank">JavaMail (Version 1.2)</a> from Javas standard website.</p></li> <li><p>You can download  latest version of <a href="http://java.sun.com/products/javabeans/glasgow/jaf.html" target="_blank">JAF (Version 1.1.1)</a> from Javas standard website.</p></li> Download and unzip these files, in the newly created top level directories you will find a number of jar files for both the applications.  You need to add <b>mail.jar</b> and <b>activation.jar</b> files in your CLASSPATH.', '');
INSERT INTO `text` (`textid`, `topic`, `content`, `code`) VALUES
(210, 'Send a Simple E-mail:', 'Here is an example to send a simple e-mail from your machine. Here it is assumed that your <b>localhost </b> is connected to the internet and capable enough to send an email.Compile and run this program to send a simple e-mail:If you want to send an e-mail to multiple recipients then following methods would be used to specify multiple e-mail IDs:Here is the description of the parameters: <li><p><b>type:</b> This would be set to TO, CC or BCC. Here CC represents Carbon Copy and BCC represents Black Carbon Copy. Example <i>Message.RecipientType.TO</i></p></li> <li><p><b>addresses:</b> This is the array of email ID. You would need to use InternetAddress() method while specifying email IDs</p></li> ', '<br><code><pre class="prettyprint notranslate"> // File Name SendEmail.java  import java.util.*; import javax.mail.*; import javax.mail.internet.*; import javax.activation.*;  public class SendEmail {    public static void main(String [] args)    {           // Recipients email ID needs to be mentioned.       String to = "abcd@gmail.com";        // Senders email ID needs to be mentioned       String from = "web@gmail.com";        // Assuming you are sending email from localhost       String host = "localhost";        // Get system properties       Properties properties = System.getProperties();        // Setup mail server       properties.setProperty("mail.smtp.host", host);        // Get the default Session object.       Session session = Session.getDefaultInstance(properties);        try{          // Create a default MimeMessage object.          MimeMessage message = new MimeMessage(session);           // Set From: header field of the header.          message.setFrom(new InternetAddress(from));           // Set To: header field of the header.          message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));           // Set Subject: header field          message.setSubject("This is the Subject Line!");           // Now set the actual message          message.setText("This is actual message");           // Send message          Transport.send(message);          System.out.println("Sent message successfully....");       }catch (MessagingException mex) {          mex.printStackTrace();       }    } } </pre></code><br><br><code><pre class="result notranslate"> $ java SendEmail Sent message successfully.... </pre></code><br><br><code><pre class="prettyprint notranslate"> void addRecipients(Message.RecipientType type, Address[] addresses)throws MessagingException </pre></code><br>'),
(211, 'Send an HTML E-mail:', 'Here is an example to send an HTML email from your machine. Here it is assumed that your <b>localhost </b> is connected to the internet and capable enough to send an email.This example is very similar to previous one, except here we are using setContent() method to set content whose second argument is "text/html" to specify that the HTML content is included in the message.Using this example, you can send as big as HTML content you like.Compile and run this program to send an HTML e-mail:', '<br><code><pre class="prettyprint notranslate"> // File Name SendHTMLEmail.java  import java.util.*; import javax.mail.*; import javax.mail.internet.*; import javax.activation.*;  public class SendHTMLEmail {    public static void main(String [] args)    {              // Recipients email ID needs to be mentioned.       String to = "abcd@gmail.com";        // Senders email ID needs to be mentioned       String from = "web@gmail.com";        // Assuming you are sending email from localhost       String host = "localhost";        // Get system properties       Properties properties = System.getProperties();        // Setup mail server       properties.setProperty("mail.smtp.host", host);        // Get the default Session object.       Session session = Session.getDefaultInstance(properties);        try{          // Create a default MimeMessage object.          MimeMessage message = new MimeMessage(session);           // Set From: header field of the header.          message.setFrom(new InternetAddress(from));           // Set To: header field of the header.          message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));           // Set Subject: header field          message.setSubject("This is the Subject Line!");           // Send the actual HTML message, as big as you like          message.setContent("&lt;h1&gt;This is actual message&lt;/h1&gt;", "text/html" );           // Send message          Transport.send(message);          System.out.println("Sent message successfully....");       }catch (MessagingException mex) {          mex.printStackTrace();       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> $ java SendHTMLEmail Sent message successfully.... </pre></code><br>'),
(212, 'Send Attachment in E-mail:', 'Here is an example to send an email with attachment from your machine. Here it is assumed that your <b>localhost </b> is connected to the internet and capable enough to send an email.Compile and run this program to send an HTML e-mail:', '<br><code><pre class="prettyprint notranslate"> // File Name SendFileEmail.java  import java.util.*; import javax.mail.*; import javax.mail.internet.*; import javax.activation.*;  public class SendFileEmail {    public static void main(String [] args)    {              // Recipients email ID needs to be mentioned.       String to = "abcd@gmail.com";        // Senders email ID needs to be mentioned       String from = "web@gmail.com";        // Assuming you are sending email from localhost       String host = "localhost";        // Get system properties       Properties properties = System.getProperties();        // Setup mail server       properties.setProperty("mail.smtp.host", host);        // Get the default Session object.       Session session = Session.getDefaultInstance(properties);        try{          // Create a default MimeMessage object.          MimeMessage message = new MimeMessage(session);           // Set From: header field of the header.          message.setFrom(new InternetAddress(from));           // Set To: header field of the header.          message.addRecipient(Message.RecipientType.TO,                                   new InternetAddress(to));           // Set Subject: header field          message.setSubject("This is the Subject Line!");           // Create the message part           BodyPart messageBodyPart = new MimeBodyPart();           // Fill the message          messageBodyPart.setText("This is message body");                    // Create a multipar message          Multipart multipart = new MimeMultipart();           // Set text message part          multipart.addBodyPart(messageBodyPart);           // Part two is attachment          messageBodyPart = new MimeBodyPart();          String filename = "file.txt";          DataSource source = new FileDataSource(filename);          messageBodyPart.setDataHandler(new DataHandler(source));          messageBodyPart.setFileName(filename);          multipart.addBodyPart(messageBodyPart);           // Send the complete message parts          message.setContent(multipart );           // Send message          Transport.send(message);          System.out.println("Sent message successfully....");       }catch (MessagingException mex) {          mex.printStackTrace();       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> $ java SendFileEmail Sent message successfully.... </pre></code><br>'),
(213, 'Java - Multithreading', 'Java is a<i>multi threaded programming language</i> which means we can develop multi threaded program using Java. A multi threaded program contains two or more parts that can run concurrently and each part  can handle different task at the same time making optimal use of the available resources specially when your computer has multiple CPUs.By definition multitasking is when multiple processes share common processing resources such as a CPU. Multi threading extends the idea of multitasking into applications where you can subdivide specific operations within a single application into individual threads. Each of the threads can run in parallel. The OS divides processing time not only among different applications, but also among each thread within an application.Multi threading enables you to write in a way where multiple activities can proceed concurrently in the same program.', ''),
(214, 'Life Cycle of a Thread:', 'A thread goes through various stages in its life cycle. For example, a thread is born, started, runs, and then dies. Following diagram shows complete life cycle of a thread.Above-mentioned stages are explained here: <li><p><b>New:</b> A new thread begins its life cycle in the new state. It remains in this state until the program starts the thread. It is also referred to as a born thread.</p></li> <li><p><b>Runnable:</b> After a newly born thread is started, the thread becomes runnable. A thread in this state is considered to be executing its task.</p></li> <li><p><b>Waiting:</b> Sometimes, a thread transitions to the waiting state while the thread waits for another thread to perform a task.A thread transitions back to the runnable state only when another thread signals the waiting thread to continue executing.</p></li> <li><p><b>Timed waiting:</b> A runnable thread can enter the timed waiting state for a specified interval of time. A thread in this state transitions back to the runnable state when that time interval expires or when the event it is waiting for occurs.</p></li> <li><p><b>Terminated ( Dead ): </b> A runnable thread enters the terminated state when it completes its task or otherwise terminates.</p></li> ', ''),
(215, 'Thread Priorities:', 'Every Java thread has a priority that helps the operating system determine the order in which threads are scheduled.Java thread priorities are in the range between MIN_PRIORITY (a constant of 1) and MAX_PRIORITY (a constant of 10). By default, every thread is given priority NORM_PRIORITY (a constant of 5).Threads with higher priority are more important to a program and should be allocated processor time before lower-priority threads. However, thread priorities cannot guarantee the order in which threads execute and very much platform dependent.', ''),
(216, 'Create Thread by Implementing Runnable Interface:', 'If your class is intended to be executed as a thread then you can achieve this by implementing <b>Runnable</b> interface. You will need to follow three basic steps:As a first step you need to implement a  run() method provided by  <b>Runnable</b> interface. This method provides entry point for the thread and you will put you complete business logic inside this method. Following is simple syntax of run() method:At second step you will instantiate a <b>Thread</b> object using the following constructor:Where, <i>threadObj</i> is an instance of a class that implements the <b>Runnable</b> interface and <b>threadName</b> is the name given to the new thread.Once Thread object is created, you can start it by calling <b>start( )</b> method, which executes a call to run( ) method.  Following is simple syntax of start() method:', '<br><code><pre class="prettyprint notranslate"> public void run( ) </pre></code><br><br><code><pre class="prettyprint notranslate"> Thread(Runnable threadObj, String threadName); </pre></code><br><br><code><pre class="prettyprint notranslate"> void start( ); </pre></code><br>'),
(217, 'Example:', 'Here is an example that creates a new thread and starts it running:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> class RunnableDemo implements Runnable {    private Thread t;    private String threadName;        RunnableDemo( String name){        threadName = name;        System.out.println("Creating " +  threadName );    }    public void run() {       System.out.println("Running " +  threadName );       try {          for(int i = 4; i &gt; 0; i--) {             System.out.println("Thread: " + threadName + ", " + i);             // Let the thread sleep for a while.             Thread.sleep(50);          }      } catch (InterruptedException e) {          System.out.println("Thread " +  threadName + " interrupted.");      }      System.out.println("Thread " +  threadName + " exiting.");    }        public void start ()    {       System.out.println("Starting " +  threadName );       if (t == null)       {          t = new Thread (this, threadName);          t.start ();       }    }  }  public class TestThread {    public static void main(String args[]) {           RunnableDemo R1 = new RunnableDemo( "Thread-1");       R1.start();              RunnableDemo R2 = new RunnableDemo( "Thread-2");       R2.start();    }    } </pre></code><br><br><code><pre class="prettyprint notranslate"> Creating Thread-1 Starting Thread-1 Creating Thread-2 Starting Thread-2 Running Thread-1 Thread: Thread-1, 4 Running Thread-2 Thread: Thread-2, 4 Thread: Thread-1, 3 Thread: Thread-2, 3 Thread: Thread-1, 2 Thread: Thread-2, 2 Thread: Thread-1, 1 Thread: Thread-2, 1 Thread Thread-1 exiting. Thread Thread-2 exiting. </pre></code><br>'),
(218, 'Create Thread by Extending Thread Class:', 'The second way to create a thread is to create a new class that extends <b>Thread</b> class using the following two simple steps. This approach provides more flexibility in handling multiple threads created using available methods in Thread class.You will need to override <b>run( )</b> method available in Thread class. This method provides entry point for the thread and you will put you complete business logic inside this method. Following is simple syntax of run() method:Once Thread object is created, you can start it by calling <b>start( )</b> method, which executes a call to run( ) method.  Following is simple syntax of start() method:', '<br><code><pre class="prettyprint notranslate"> public void run( ) </pre></code><br><br><code><pre class="prettyprint notranslate"> void start( ); </pre></code><br>'),
(219, 'Example:', 'Here is the preceding program rewritten to extend Thread:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> class ThreadDemo extends Thread {    private Thread t;    private String threadName;        ThreadDemo( String name){        threadName = name;        System.out.println("Creating " +  threadName );    }    public void run() {       System.out.println("Running " +  threadName );       try {          for(int i = 4; i &gt; 0; i--) {             System.out.println("Thread: " + threadName + ", " + i);             // Let the thread sleep for a while.             Thread.sleep(50);          }      } catch (InterruptedException e) {          System.out.println("Thread " +  threadName + " interrupted.");      }      System.out.println("Thread " +  threadName + " exiting.");    }        public void start ()    {       System.out.println("Starting " +  threadName );       if (t == null)       {          t = new Thread (this, threadName);          t.start ();       }    }  }  public class TestThread {    public static void main(String args[]) {           ThreadDemo T1 = new ThreadDemo( "Thread-1");       T1.start();              ThreadDemo T2 = new ThreadDemo( "Thread-2");       T2.start();    }    } </pre></code><br><br><code><pre class="prettyprint notranslate"> Creating Thread-1 Starting Thread-1 Creating Thread-2 Starting Thread-2 Running Thread-1 Thread: Thread-1, 4 Running Thread-2 Thread: Thread-2, 4 Thread: Thread-1, 3 Thread: Thread-2, 3 Thread: Thread-1, 2 Thread: Thread-2, 2 Thread: Thread-1, 1 Thread: Thread-2, 1 Thread Thread-1 exiting. Thread Thread-2 exiting. </pre></code><br>'),
(220, 'Thread Methods:', 'Following is the list of important methods available in the Thread class.The previous methods are invoked on a particular Thread object. The following methods in the Thread class are static. Invoking one of the static methods performs the operation on the currently running thread.', ''),
(221, 'Example:', 'The following ThreadClassDemo program demonstrates some of these methods of the Thread class. Consider a class <b>DisplayMessage</b> which implements <b>Runnable</b>:Following is another class which extends Thread class:Following is the main program which makes use of above defined classes:This would produce the following result. You can try this example again and again and you would get different result every time.', '<br><code><pre class="prettyprint notranslate"> // File Name : DisplayMessage.java // Create a thread to implement Runnable public class DisplayMessage implements Runnable {    private String message;    public DisplayMessage(String message)    {       this.message = message;    }    public void run()    {       while(true)       {          System.out.println(message);       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> // File Name : GuessANumber.java // Create a thread to extentd Thread public class GuessANumber extends Thread {    private int number;    public GuessANumber(int number)    {       this.number = number;    }    public void run()    {       int counter = 0;       int guess = 0;       do       {           guess = (int) (Math.random() * 100 + 1);           System.out.println(this.getName()                        + " guesses " + guess);           counter++;       }while(guess != number);       System.out.println("** Correct! " + this.getName()                        + " in " + counter + " guesses.**");    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> // File Name : ThreadClassDemo.java public class ThreadClassDemo {    public static void main(String [] args)    {       Runnable hello = new DisplayMessage("Hello");       Thread thread1 = new Thread(hello);       thread1.setDaemon(true);       thread1.setName("hello");       System.out.println("Starting hello thread...");       thread1.start();              Runnable bye = new DisplayMessage("Goodbye");       Thread thread2 = new Thread(bye);       thread2.setPriority(Thread.MIN_PRIORITY);       thread2.setDaemon(true);       System.out.println("Starting goodbye thread...");       thread2.start();        System.out.println("Starting thread3...");       Thread thread3 = new GuessANumber(27);       thread3.start();       try       {          thread3.join();       }catch(InterruptedException e)       {          System.out.println("Thread interrupted.");       }       System.out.println("Starting thread4...");       Thread thread4 = new GuessANumber(75);        	  thread4.start();       System.out.println("main() is ending...");    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Starting hello thread... Starting goodbye thread... Hello Hello Hello Hello Hello Hello Goodbye Goodbye Goodbye Goodbye Goodbye ....... </pre></code><br>'),
(222, 'Java - Applet Basics', 'An applet is a Java program that runs in a Web browser. An applet can be a fully functional Java application because it has the entire Java API at its disposal.There are some important differences between an applet and a standalone Java application, including the following: <li><p>An applet is a Java class that extends the java.applet.Applet class.</p></li> <li><p>A main() method is not invoked on an applet, and an applet class will not define main().</p></li> <li><p>Applets are designed to be embedded within an HTML page.</p></li> <li><p>When a user views an HTML page that contains an applet, the code for the applet is downloaded to the users machine.</p></li> <li><p>A JVM is required to view an applet. The JVM can be either a plug-in of the Web browser or a separate runtime environment.</p></li> <li><p>The JVM on the users machine creates an instance of the applet class and invokes various methods during the applets lifetime.</p></li> <li><p>Applets have strict security rules that are enforced by the Web browser. The security of an applet is often referred to as sandbox security, comparing the applet to a child playing in a sandbox with various rules that must be followed.</p></li> <li><p>Other classes that the applet needs can be downloaded in a single Java Archive (JAR) file.</p></li> ', ''),
(223, 'Life Cycle of an Applet:', 'Four methods in the Applet class give you the framework on which you build any serious applet: <li><p><b>init:</b> This method is intended for whatever initialization is needed for your applet. It is called after the param tags inside the applet tag have been processed.</p></li> <li><p><b>start:</b> This method is automatically called after the browser calls the init method. It is also called whenever the user returns to the page containing the applet after having gone off to other pages.</p></li> <li><p><b>stop:</b> This method is automatically called when the user moves off the page on which the applet sits. It can, therefore, be called repeatedly in the same applet. </p></li> <li><p><b>destroy:</b> This method is only called when the browser shuts down normally. Because applets are meant to live on an HTML page, you should not normally leave resources behind after a user leaves the page that contains the applet.</p></li> <li><p><b>paint:</b> Invoked immediately after the start() method, and also any time the applet needs to repaint itself in the browser. The paint() method is actually inherited from the java.awt.</p></li> ', ''),
(224, 'A "Hello, World" Applet:', 'The following is a simple applet named HelloWorldApplet.java:These import statements bring the classes into the scope of our applet class: <li><p>java.applet.Applet.</p></li> <li><p>java.awt.Graphics.</p></li> Without those import statements, the Java compiler would not recognize the classes Applet and Graphics, which the applet class refers to.', '<br><code><pre class="prettyprint notranslate"> import java.applet.*; import java.awt.*;  public class HelloWorldApplet extends Applet {    public void paint (Graphics g)    {       g.drawString ("Hello World", 25, 50);    } } </pre></code><br>'),
(225, 'The Applet CLASS:', 'Every applet is an extension of the <i>java.applet.Applet class</i>. The base Applet class provides methods that a derived Applet class may call to obtain information and services from the browser context.These include methods that do the following: <li><p>Get applet parameters</p></li> <li><p>Get the network location of the HTML file that contains the applet</p></li> <li><p>Get the network location of the applet class directory</p></li> <li><p>Print a status message in the browser</p></li> <li><p>Fetch an image</p></li> <li><p>Fetch an audio clip</p></li> <li><p>Play an audio clip</p></li> <li><p>Resize the applet</p></li> Additionally, the Applet class provides an interface by which the viewer or browser obtains information about the applet and controls the applets execution. The viewer may: <li><p>request information about the author, version and copyright of the applet</p></li> <li><p>request a description of the parameters the applet recognizes</p></li> <li><p>initialize the applet</p></li> <li><p>destroy the applet</p></li> <li><p>start the applets execution</p></li> <li><p>stop the applets execution</p></li> The Applet class provides default implementations of each of these methods. Those implementations may be overridden as necessary.The "Hello, World" applet is complete as it stands. The only method overridden is the paint method.', ''),
(226, 'Invoking an Applet:', 'An applet may be invoked by embedding directives in an HTML file and viewing the file through an applet viewer or Java-enabled browser.The &lt;applet&gt; tag is the basis for embedding an applet in an HTML file. Below is an example that invokes the "Hello, World" applet:<b>Note:</b> You can refer to <a href="/html/html_applet_tag.htm" title="HTML Applet Tag" target="_blank">HTML Applet Tag</a> to understand more about calling applet from HTML.The code attribute of the &lt;applet&gt; tag is required. It specifies the Applet class to run. Width and height are also required to specify the initial size of the panel in which an applet runs. The applet directive must be closed with a &lt;/applet&gt; tag.If an applet takes parameters, values may be passed for the parameters by adding &lt;param&gt; tags between &lt;applet&gt; and &lt;/applet&gt;. The browser ignores text and other tags between the applet tags.Non-Java-enabled browsers do not process &lt;applet&gt; and &lt;/applet&gt;. Therefore, anything that appears between the tags, not related to the applet, is visible in non-Java-enabled browsers.The viewer or browser looks for the compiled Java code at the location of the document. To specify otherwise, use the codebase attribute of the &lt;applet&gt; tag as shown:If an applet resides in a package other than the default, the holding package must be specified in the code attribute using the period character (.) to separate package/class components. For example:', '<br><code><pre class="prettyprint notranslate"> &lt;html&gt; &lt;title&gt;The Hello, World Applet&lt;/title&gt; &lt;hr&gt; &lt;applet code="HelloWorldApplet.class" width="320" height="120"&gt; If your browser was Java-enabled, a "Hello, World" message would appear here. &lt;/applet&gt; &lt;hr&gt; &lt;/html&gt; </pre></code><br><br><code><pre class="prettyprint notranslate"> &lt;applet codebase="http://amrood.com/applets" code="HelloWorldApplet.class" width="320" height="120"&gt; </pre></code><br><br><code><pre class="prettyprint notranslate"> &lt;applet code="mypackage.subpackage.TestApplet.class"             width="320" height="120"&gt; </pre></code><br>'),
(227, 'Getting Applet Parameters:', 'The following example demonstrates how to make an applet respond to setup parameters specified in the document. This applet displays a checkerboard pattern of black and a second color.The second color and the size of each square may be specified as parameters to the applet within the document.CheckerApplet gets its parameters in the init() method. It may also get its parameters in the paint() method. However, getting the values and saving the settings once at the start of the applet, instead of at every refresh, is convenient and efficient.The applet viewer or browser calls the init() method of each applet it runs. The viewer calls init() once, immediately after loading the applet. (Applet.init() is implemented to do nothing.) Override the default implementation to insert custom initialization code.The Applet.getParameter() method fetches a parameter given the parameters name (the value of a parameter is always a string). If the value is numeric or other non-character data, the string must be parsed.The following is a skeleton of CheckerApplet.java:Here are CheckerApplets init() and private parseSquareSize() methods:The applet calls parseSquareSize() to parse the squareSize parameter. parseSquareSize() calls the library method Integer.parseInt(), which parses a string and returns an integer. Integer.parseInt() throws an exception whenever its argument is invalid.Therefore, parseSquareSize() catches exceptions, rather than allowing the applet to fail on bad input.The applet calls parseColor() to parse the color parameter into a Color value. parseColor() does a series of string comparisons to match the parameter value to the name of a predefined color. You need to implement these methods to make this applet works.', '<br><code><pre class="prettyprint notranslate"> import java.applet.*; import java.awt.*; public class CheckerApplet extends Applet {    int squareSize = 50;// initialized to default size    public void init () {}    private void parseSquareSize (String param) {}    private Color parseColor (String param) {}    public void paint (Graphics g) {} } </pre></code><br><br><code><pre class="prettyprint notranslate"> public void init () {    String squareSizeParam = getParameter ("squareSize");    parseSquareSize (squareSizeParam);    String colorParam = getParameter ("color");    Color fg = parseColor (colorParam);    setBackground (Color.black);    setForeground (fg); } private void parseSquareSize (String param) {    if (param == null) return;    try {       squareSize = Integer.parseInt (param);    }    catch (Exception e) {      // Let default value remain    } } </pre></code><br>'),
(228, 'Specifying Applet Parameters:', 'The following is an example of an HTML file with a CheckerApplet embedded in it. The HTML file specifies both parameters to the applet by means of the &lt;param&gt; tag.<b>Note:</b> Parameter names are not case sensitive.', '<br><code><pre class="prettyprint notranslate"> &lt;html&gt; &lt;title&gt;Checkerboard Applet&lt;/title&gt; &lt;hr&gt; &lt;applet code="CheckerApplet.class" width="480" height="320"&gt; &lt;param name="color" value="blue"&gt; &lt;param name="squaresize" value="30"&gt; &lt;/applet&gt; &lt;hr&gt; &lt;/html&gt; </pre></code><br>'),
(229, 'Application Conversion to Applets:', 'It is easy to convert a graphical Java application (that is, an application that uses the AWT and that you can start with the java program launcher) into an applet that you can embed in a web page.Here are the specific steps for converting an application to an applet. <li><p>Make an HTML page with the appropriate tag to load the applet code.</p></li> <li><p>Supply a subclass of the JApplet class. Make this class public. Otherwise, the applet cannot be loaded.</p></li> <li><p>Eliminate the main method in the application. Do not construct a frame window for the application. Your application will be displayed inside the browser.</p></li> <li><p>Move any initialization code from the frame window constructor to the init method of the applet. You dont need to explicitly construct the applet object.the browser instantiates it for you and calls the init method.</p></li> <li><p>Remove the call to setSize; for applets, sizing is done with the width and height parameters in the HTML file.</p></li> <li><p>Remove the call to setDefaultCloseOperation. An applet cannot be closed; it terminates when the browser exits.</p></li> <li><p>If the application calls setTitle, eliminate the call to the method. Applets cannot have title bars. (You can, of course, title the web page itself, using the HTML title tag.)</p></li> <li><p>Dont call setVisible(true). The applet is displayed automatically.</p></li> ', ''),
(230, 'Event Handling:', 'Applets inherit a group of event-handling methods from the Container class.  The Container class defines several methods, such as processKeyEvent and processMouseEvent, for handling particular types of events, and then one catch-all method called processEvent.In order to react an event, an applet must override the appropriate event-specific method.Now, let us call this applet as follows:Initially, the applet will display "initializing the applet. Starting the applet." Then once you click inside the rectangle "mouse clicked" will be displayed as well.', '<br><code><pre class="prettyprint notranslate"> import java.awt.event.MouseListener; import java.awt.event.MouseEvent; import java.applet.Applet; import java.awt.Graphics;  public class ExampleEventHandling extends Applet  			 implements MouseListener {      StringBuffer strBuffer;      public void init() { 	addMouseListener(this); 	strBuffer = new StringBuffer();         addItem("initializing the apple ");     }      public void start() {         addItem("starting the applet ");     }      public void stop() {         addItem("stopping the applet ");     }      public void destroy() {         addItem("unloading the applet");     }      void addItem(String word) {         System.out.println(word);         strBuffer.append(word);         repaint();     }      public void paint(Graphics g) { 	//Draw a Rectangle around the applets display area.         g.drawRect(0, 0,  		   getWidth() - 1, 		   getHeight() - 1);  	//display the string inside the rectangle.         g.drawString(strBuffer.toString(), 10, 20);     }          public void mouseEntered(MouseEvent event) {     }     public void mouseExited(MouseEvent event) {     }     public void mousePressed(MouseEvent event) {     }     public void mouseReleased(MouseEvent event) {     }      public void mouseClicked(MouseEvent event) { 	addItem("mouse clicked! ");     } } </pre></code><br><br><code><pre class="prettyprint notranslate"> &lt;html&gt; &lt;title&gt;Event Handling&lt;/title&gt; &lt;hr&gt; &lt;applet code="ExampleEventHandling.class"  width="300" height="300"&gt; &lt;/applet&gt; &lt;hr&gt; &lt;/html&gt; </pre></code><br>'),
(231, 'Displaying Images:', 'An applet can display images of the format GIF, JPEG, BMP, and others. To display an image within the applet, you use the drawImage() method found in the java.awt.Graphics class.Following is the example showing all the steps to show images:Now, let us call this applet as follows:', '<br><code><pre class="prettyprint notranslate"> import java.applet.*; import java.awt.*; import java.net.*; public class ImageDemo extends Applet {   private Image image;   private AppletContext context;   public void init()   {       context = this.getAppletContext();       String imageURL = this.getParameter("image");       if(imageURL == null)       {          imageURL = "java.jpg";       }       try       {          URL url = new URL(this.getDocumentBase(), imageURL);          image = context.getImage(url);       }catch(MalformedURLException e)       {          e.printStackTrace();          // Display in browser status bar          context.showStatus("Could not load image!");       }    }    public void paint(Graphics g)    {       context.showStatus("Displaying image");       g.drawImage(image, 0, 0, 200, 84, null);       g.drawString("www.javalicense.com", 35, 100);    }   } </pre></code><br><br><code><pre class="prettyprint notranslate"> &lt;html&gt; &lt;title&gt;The ImageDemo applet&lt;/title&gt; &lt;hr&gt; &lt;applet code="ImageDemo.class" width="300" height="200"&gt; &lt;param name="image" value="java.jpg"&gt; &lt;/applet&gt; &lt;hr&gt; &lt;/html&gt; </pre></code><br>'),
(232, 'Java Documentation Comments', 'The Java language supports three types of comments:This tutorial is all about explaining Javadoc. We will see how we can make use of Javadoc for generating useful documentation for our Java code.', ''),
(233, 'What is Javadoc?', 'Javadoc is a tool which comes with JDK and it is used for generating Java code documentation in HTML format from Java source code which has required documentation in a predefined format.Following is a simple example where red part of the code represents Java comments:You can include required HTML tags inside the description part, For example, below example makes use of &lt;h1&gt;....&lt;/h1&gt; for heading and &lt;p&gt; has been used for creating paragraph break:', '<br><code><pre class="prettyprint notranslate"> /** * The HelloWorld program implements an application that * simply displays "Hello World!" to the standard output. * * @author  Zara Ali * @version 1.0 * @since   2014-03-31  */ public class HelloWorld {     public static void main(String[] args) {         /* Prints Hello, World! on standard output.         System.out.println("Hello World!");     } } </pre></code><br><br><code><pre class="prettyprint notranslate"> /** * &lt;h1&gt;Hello, World!&lt;/h1&gt; * The HelloWorld program implements an application that * simply displays "Hello World!" to the standard output. * &lt;p&gt; * Giving proper comments in your program makes it more * user friendly and it is assumed as a high quality code. *  * * @author  Zara Ali * @version 1.0 * @since   2014-03-31  */ public class HelloWorld {     public static void main(String[] args) {         /* Prints Hello, World! on standard output.         System.out.println("Hello World!");     } } </pre></code><br>'),
(234, 'The javadoc Tags:', 'The javadoc tool recognizes the following tags:', ''),
(235, 'What is Java?', 'Java is: <li>Object Oriented </li> <li>Platform independent:</li> <li>Simple</li> <li>Secure</li> <li>Architectural- neutral</li> <li>Portable</li> <li>Robust</li> <li>Multi-threaded </li> <li>Interpreted </li> <li>High Performance</li> <li>Distributed </li> <li>Dynamic</li> ', ''),
(236, 'Java Environment Setup:', 'Java SE is freely available from the link <a href="http://java.sun.com/javase/downloads/index_jdk5.jsp" target="_blank">Download Java</a>. So you download a version based on your operating system.You can refer to installation guide for a complete detail.', ''),
(237, 'Java Basic Syntax:', ' <li><p><b>Object -</b> Objects have states and behaviors. Example: A dog has states-color, name, breed as well as behaviors -wagging, barking, eating. An object is an instance of a class. </p></li> <li><p><b>Class -</b> A class can be defined as a template/ blue print that describe the behaviors/states that object of its type support.</p></li> <li><p><b>Methods -</b> A method is basically a behavior. A class can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.</p></li> <li><p><b>Instant Variables -</b> Each object has its unique set of instant variables. An objects state is created by the values assigned to these instant variables.</p></li> ', ''),
(238, 'First Java Program:', 'Let us look at a simple code that would print the words <i>Hello World</i>.About Java programs, it is very important to keep in mind the following points. <li><p><b>Case Sensitivity - </b> Java is case sensitive which means identifier <b>Hello</b> and <b>hello</b> would have different meaning in Java.</p></li> <li><p><b>Class Names - </b> For all class names the first letter should be in Upper Case. <br /><br /> If several words are used to form a name of the class each inner words first letter should be in Upper Case.<br /><br /> Example <i>class MyFirstJavaClass </i></p></li> <li><p><b>Method Names - </b> All method names should start with a Lower Case letter.  <br /><br /> If several words are  used to form the name of the method, then each inner words first letter should be in Upper Case.<br /><br /> Example <i>public void myMethodName()</i></p></li> <li><p><b>Program File Name - </b> Name of the program file should exactly match the class name.  <br /><br /> When saving the file you should save it using the class name (Remember java is case sensitive) and append .java to the end of the name. (if the file name and the class name do not match your program will not compile).<br /><br /> Example : Assume MyFirstJavaProgram is the class  name. Then the file should be saved as <i>MyFirstJavaProgram.java</i></p></li> <li><p><b>public static void main(String args[]) -</b> java program processing starts from the main() method which is a mandatory part of every java program..</p></li> ', '<br><code><pre class="prettyprint notranslate"> public class MyFirstJavaProgram{     /* This is my first java program.       * This will print Hello World as the output     */      public static void main(String []args){        System.out.println("Hello World"); // prints Hello World     } }  </pre></code><br>'),
(239, 'Java Identifiers:', 'All Java components require names. Names used for classes, variables and methods are called identifiers.In java there are several points to remember about identifiers. They are as follows: <li><p>All identifiers should begin with a letter (A to Z or a to z ), currency character ($) or an underscore (_).</p></li> <li><p>After the first character identifiers can have any combination of characters.</p></li> <li><p>A key word cannot be used as an identifier.</p></li> <li><p>Most importantly identifiers are case sensitive.</p></li> <li><p>Examples of legal identifiers:age, $salary, _value,  __1_value</p></li> <li><p>Examples of illegal identifiers : 123abc, -salary</p></li> ', ''),
(240, 'Java Modifiers:', 'Like other languages, it is possible to modify classes, methods, etc., by using modifiers. There are two categories of modifiers. <li><p><b>Access Modifiers : </b> default, public , protected, private</p></li> <li><p><b>Non-access Modifiers : </b> final, abstract, strictfp</p></li> We will be looking into more details about modifiers in the next section.', ''),
(241, 'Java Variables:', 'We would see following type of variables in Java: <li>Local Variables</li> <li>Class Variables (Static Variables)</li> <li>Instance Variables (Non static variables)</li> ', ''),
(242, 'Java Arrays:', 'Arrays are objects that store multiple variables of the same type. However an Array itself is an object on the heap. We will look into how to declare, construct and initialize in the upcoming chapters.', ''),
(243, 'Java Enums:', 'Enums were introduced in Java 5.0. Enums restrict a variable to have one of only a few predefined values. The values in this enumerated list are called enums.With the use of enums it is possible to reduce the number of bugs in your code. For example if we consider an application for a fresh juice shop it would be possible to restrict the glass size to small, medium and Large. This would make sure that it would not allow anyone to order any size other than the small, medium or large.', ''),
(244, 'Example:', '<b>Note:</b> enums can be declared as their own or inside a class. Methods, variables, constructors can be defined inside enums as well.', '<br><code><pre class="prettyprint notranslate"> class FreshJuice{     enum FreshJuiceSize{ SMALL, MEDIUM, LARGE }    FreshJuiceSize size; }  public class FreshJuiceTest{     public static void main(String args[]){       FreshJuice juice = new FreshJuice();       juice.size = FreshJuice. FreshJuiceSize.MEDIUM ;       System.out.println("Size :" + juice.size);    } } </pre></code><br>'),
(245, 'Java Keywords:', 'The following list shows the reserved words in Java. These reserved words may not be used as constant or variable or any other identifier names.', ''),
(246, 'Comments in Java', 'Java supports single line and multi-line comments very similar to c and c++. All characters available inside any comment are ignored by Java compiler.', '<br><code><pre class="prettyprint notranslate"> public class MyFirstJavaProgram{     /* This is my first java program.     * This will print Hello World as the output     * This is an example of multi-line comments.     */      public static void main(String []args){        // This is an example of single line comment        /* This is also an example of single line comment. */        System.out.println("Hello World");      } }  </pre></code><br>'),
(247, 'Data Types in Java', 'There are two data types available in Java: <li><p>Primitive Data Types</p></li> <li><p>Reference/Object Data Types</p></li> ', ''),
(248, 'Primitive Data Types:', 'There are eight primitive data types supported by Java. Primitive data types are predefined by the language and named by a key word. Let us now look into detail about the eight primitive data types. <li>byte</li> <li>short</li> <li>int</li> <li>long</li> <li>float</li> <li>double</li> <li>boolean</li> <li>char</li> ', ''),
(249, 'Reference Data Types:', ' <li><p>Reference variables are created using defined constructors of the classes. They are used to access objects. These variables are declared to be of a specific type that cannot be changed. For example, Employee, Puppy etc.</p></li>  <li><p>Class objects, and various type of array variables come under reference data type.</p></li> <li><p>Default value of any reference variable is null.</p></li>  <li><p>A reference variable can be used to refer to any object of the declared type or any compatible type.</p></li>  <li><p>Example : Animal animal = new Animal("giraffe");</p></li>  ', ''),
(250, 'Java Literals:', 'A literal is a source code representation of a fixed value. They are represented directly in the code without any computation.Literals can be assigned to any primitive type variable. For example:String literals in Java are specified like they are in most other languages by enclosing a sequence of characters between a pair of double quotes. Examples of string literals are:Java language supports few special escape sequences for String and char literals as well. They are:', '<br><code><pre class="prettyprint notranslate"> byte a = 68; char a = A </pre></code><br><br><code><pre class="prettyprint notranslate"> "Hello World" "two\nlines" ""This is in quotes"" </pre></code><br>'),
(251, 'Java Access Modifiers:', 'Java provides a number of access modifiers to set access levels for classes, variables, methods and constructors. The four access levels are: <li><p>Visible to the package. the default. No modifiers are needed.</p></li> <li><p>Visible to the class only (private).</p></li> <li><p>Visible to the world (public).</p></li> <li><p>Visible to the package and all subclasses (protected).</p></li> ', ''),
(252, 'Java Basic Operators:', 'Java provides a rich set of operators to manipulate variables. We can divide all the Java operators into the following groups:', ''),
(253, 'Misc Operators', 'There are few other operators supported by Java Language.', ''),
(254, 'Conditional Operator ( ? : ):', 'Conditional operator is also known as the ternary operator. This operator consists of three operands and is used to evaluate boolean expressions. The goal of the operator is to decide which value should be assigned to the variable. The operator is written as :', '<br><code><pre class="prettyprint notranslate"> variable x = (expression) ? value if true : value if false </pre></code><br>'),
(255, 'instanceOf Operator:', 'This operator is used only for object reference variables. The operator checks whether the object is of a particular type(class type or interface type).  instanceOf operator is wriiten as:', '<br><code><pre class="prettyprint notranslate"> ( Object reference variable ) instanceOf  (class/interface type) </pre></code><br>'),
(256, 'The while Loop:', 'A while loop is a control structure that allows you to repeat a task a certain number of times.', ''),
(257, 'Syntax:', 'The syntax of a while loop is:', '<br><code><pre class="prettyprint notranslate"> while(Boolean_expression) {    //Statements } </pre></code><br>'),
(258, 'The do...while Loop:', 'A do...while loop is similar to a while loop, except that a do...while loop is guaranteed to execute at least one time.', ''),
(259, 'Syntax:', 'The syntax of a do...while loop is:', '<br><code><pre class="prettyprint notranslate"> do {    //Statements }while(Boolean_expression); </pre></code><br>'),
(260, 'The for Loop:', 'A for loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times.A for loop is useful when you know how many times a task is to be repeated.', ''),
(261, 'Syntax:', 'The syntax of a for loop is:', '<br><code><pre class="prettyprint notranslate"> for(initialization; Boolean_expression; update) {    //Statements } </pre></code><br>'),
(262, 'Enhanced for loop in Java:', 'As of java 5 the enhanced for loop was introduced. This is mainly used for Arrays.', ''),
(263, 'Syntax:', 'The syntax of enhanced for loop is:', '<br><code><pre class="prettyprint notranslate"> for(declaration : expression) {    //Statements } </pre></code><br>'),
(264, 'The break Keyword:', 'The <i>break</i> keyword is used to stop the entire loop. The break keyword must be used inside any loop or a switch statement.The break keyword will stop the execution of the innermost loop and start executing the next line of code after the block.', ''),
(265, 'The continue Keyword:', 'The <i>continue</i> keyword can be used in any of the loop control structures. It causes the loop to immediately jump to the next iteration of the loop. <li><p>In a for loop, the continue keyword causes flow of control to immediately jump to the update statement.</p></li> <li><p>In a while loop or do/while loop, flow of control immediately jumps to the Boolean expression.</p></li> ', ''),
(266, 'Syntax:', 'The syntax of a continue is a single statement inside any loop:', '<br><code><pre class="prettyprint notranslate"> continue; </pre></code><br>'),
(267, 'The if Statement:', 'An if statement consists of a Boolean expression followed by one or more statements.', ''),
(268, 'Syntax:', 'The syntax of an if statement is:', '<br><code><pre class="prettyprint notranslate"> if(Boolean_expression) {    //Statements will execute if the Boolean expression is true } </pre></code><br>'),
(269, 'The if...else Statement:', 'An if statement can be followed by an optional <i>else</i> statement, which executes when the Boolean expression is false.', ''),
(270, 'Syntax:', 'The syntax of a if...else is:', '<br><code><pre class="prettyprint notranslate"> if(Boolean_expression){    //Executes when the Boolean expression is true }else{    //Executes when the Boolean expression is false } </pre></code><br>'),
(271, 'The if...else if...else Statement:', 'An if statement can be followed by an optional <i>else if...else</i> statement, which is very usefull to test various conditions using single if...else if statement.', ''),
(272, 'Syntax:', 'The syntax of a if...else is:', '<br><code><pre class="prettyprint notranslate"> if(Boolean_expression 1){    //Executes when the Boolean expression 1 is true }else if(Boolean_expression 2){    //Executes when the Boolean expression 2 is true }else if(Boolean_expression 3){    //Executes when the Boolean expression 3 is true }else {    //Executes when the one of the above condition is true. } </pre></code><br>'),
(273, 'Nested if...else Statement:', 'It is always legal to nest if-else statements. When using if , else if , else statements there are few points to keep in mind. <li><p>An if can have zero or one elses and it must come after any else ifs.</p></li> <li><p>An if can have zero to many else ifs and they must come before the else.</p></li> <li><p>Once an else if succeeds, none of he remaining else ifs or elses will be tested.</p></li> ', '');
INSERT INTO `text` (`textid`, `topic`, `content`, `code`) VALUES
(274, 'Syntax:', 'The syntax for a nested if...else is as follows:', '<br><code><pre class="prettyprint notranslate"> if(Boolean_expression 1){    //Executes when the Boolean expression 1 is true    if(Boolean_expression 2){       //Executes when the Boolean expression 2 is true    } } </pre></code><br>'),
(275, 'The switch Statement:', 'A <i>switch</i> statement allows a variable to be tested for equality against a list of values. Each value is called a case, and the variable being switched on is checked for each case.', ''),
(276, 'Syntax:', 'The syntax of enhanced for loop is:', '<br><code><pre class="prettyprint notranslate"> switch(expression){     case value :        //Statements        break; //optional     case value :        //Statements        break; //optional     //You can have any number of case statements.     default : //Optional        //Statements } </pre></code><br>'),
(277, 'Java Methods:', 'A Java method is a collection of statements that are grouped together to perform an operation. When you call the System.out.println method, for example, the system actually executes several statements in order to display a message on the console.In general, a method has the following syntax:A method definition consists of a method header and a method body. Here are all the parts of a method: <li><p><b>Modifiers:</b> The modifier, which is optional, tells the compiler how to call the method. This defines the access type of the method.</p></li> <li><p><b>Return Type:</b> A method may return a value. The returnValueType is the data type of the value the method returns. Some methods perform the desired operations without returning a value. In this case, the returnValueType is the keyword <b>void</b>.</p></li> <li><p><b>Method Name:</b> This is the actual name of the method. The method name and the parameter list together constitute the method signature.</p></li> <li><p><b>Parameters:</b> A parameter is like a placeholder. When a method is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of the parameters of a method. Parameters are optional; that is, a method may contain no parameters.</p></li> <li><p><b>Method Body:</b> The method body contains a collection of statements that define what the method does.</p></li> ', '<br><code><pre class="prettyprint notranslate"> modifier returnValueType methodName(list of parameters) {   // Method body; } </pre></code><br>'),
(278, 'Java Classes &amp; Objects:', ' <li><p><b>Object -</b> Objects have states and behaviors. Example: A dog has states-color, name, breed as well as behaviors -wagging, barking, eating. An object is an instance of a class. </p></li> <li><p><b>Class -</b> A class can be defined as a template/ blue print that describe the behaviors/states that object of its type support.</p></li> A sample of a class is given below:A class can contain any of the following variable types. <li><p><b>Local variables . </b>variables defined inside methods, constructors or blocks are called local variables. The variable will be declared and initialized within the method and the variable will be destroyed when the method has completed.</p></li> <li><p><b>Instance variables . </b>Instance variables are variables within a class but outside any method. These variables are instantiated when the class is loaded. Instance variables can be accessed from inside any method, constructor or blocks of that particular class.</p></li> <li><p><b>Class variables . </b> Class variables are variables declared with in a class, outside any method, with the static keyword.</p></li> ', '<br><code><pre class="prettyprint notranslate"> public class Dog{    String breed;    int age;    String color;     void barking(){    }        void hungry(){    }        void sleeping(){    } } </pre></code><br>'),
(279, 'Exceptions Handling:', 'A method catches an exception using a combination of the <b>try</b> and <b>catch</b> keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following:', '<br><code><pre class="prettyprint notranslate"> try {    //Protected code }catch(ExceptionName e1) {    //Catch block } </pre></code><br>'),
(280, 'Multiple catch Blocks:', 'A try block can be followed by multiple catch blocks. The syntax for multiple catch blocks looks like the following:', '<br><code><pre class="prettyprint notranslate"> try {    //Protected code }catch(ExceptionType1 e1) {    //Catch block }catch(ExceptionType2 e2) {    //Catch block }catch(ExceptionType3 e3) {    //Catch block } </pre></code><br>'),
(281, 'The throws/throw Keywords:', 'If a method does not handle a checked exception, the method must declare it using the <b>throws</b> keyword. The throws keyword appears at the end of a methods signature.You can throw an exception, either a newly instantiated one or an exception that you just caught, by using the <b>throw</b> keyword. Try to understand the different in throws and throw keywords.', ''),
(282, 'Java - Useful Resources', 'The following resources contain additional information on Java. Please use them to get more in-depth knowledge on this topic.', ''),
(283, 'Useful Links on Java', ' <li><p><a target="_blank" rel="nofollow" href="http://java.sun.com/docs/books/tutorial/index.html">The Java<sup><font size="-2">TM</font></sup> Tutorials</a> &minus; The Java Tutorials are practical guides for programmers who want to use the Java programming language to create applications.</p></li> <li><p><a target="_blank" rel="nofollow" href="http://java.sun.com/j2se/1.4.2/docs/index.html">Java<sup><font size="-2">TM</font></sup> 2 SDK, Standard Edition </a> &minus; Official site for Java<sup><font size="-2">TM</font></sup> 2 SDK, Standard Edition </p></li> <li><p><a target="_blank" rel="nofollow" href="http://www.java.com/en/download/index.jsp">Free Java Download</a> &minus; Download Java for your desktop computer now!</p></li> <li><p><a target="_blank" rel="nofollow" href="http://java.sun.com/reference/docs/">Sun Developer Network</a> &minus; Sun Microsystems official website listing down all the API documentation, latest Java Technologies, Books and other resource.</p></li> ', ''),
(284, 'Java - Overview', 'Java programming language was originally developed by Sun Microsystems which was initiated by James Gosling and released in 1995 as core component of Sun Microsystems Java platform (Java 1.0 [J2SE]).The latest release of the Java Standard Edition is Java SE 8. With the advancement of Java and its widespread popularity, multiple configurations were built to suite various types of platforms. Ex: J2EE for Enterprise Applications, J2ME for Mobile Applications.The new J2 versions were renamed as Java SE, Java EE and Java ME respectively. Java is guaranteed to be <b>Write Once, Run Anywhere.</b>Java is: <li><p><b>Object Oriented:</b> In Java, everything is an Object. Java can be easily extended since it is based on the Object model.</p></li> <li><p><b>Platform independent:</b> Unlike many other programming languages including C and C++, when Java is compiled, it is not compiled into platform specific machine, rather into platform independent byte code. This byte code is distributed over the web and interpreted by virtual Machine (JVM) on whichever platform it is being run.</p></li> <li><p><b>Simple:</b> Java is designed to be easy to learn. If you understand the basic concept of OOP Java would be easy to master.</p></li> <li><p><b>Secure:</b> With Javas secure feature it enables to develop virus-free, tamper-free systems. Authentication techniques are based on public-key encryption.</p></li> <li><p><b>Architectural-neutral: </b>Java compiler generates an architecture-neutral object file format which makes the compiled code to be executable on many processors, with the presence of Java runtime system.</p></li> <li><p><b>Portable:</b> Being architectural-neutral and having no implementation dependent aspects of the specification makes Java portable. Compiler in Java is written in ANSI C with a clean portability boundary which is a POSIX subset.</p></li> <li><p><b>Robust:</b> Java makes an effort to eliminate error prone situations by emphasizing mainly on compile time error checking and runtime checking.</p></li> <li><p><b>Multithreaded:</b> With Javas multithreaded feature it is possible to write programs that can do many tasks simultaneously. This design feature allows developers to construct smoothly running interactive applications.</p></li> <li><p><b>Interpreted:</b> Java byte code is translated on the fly to native machine instructions and is not stored anywhere. The development process is more rapid and analytical since the linking is an incremental and light weight process. </p></li> <li><p><b>High Performance:</b> With the use of Just-In-Time compilers, Java enables high performance.</p></li> <li><p><b>Distributed:</b> Java is designed for the distributed environment of the internet.</p></li> <li><p><b>Dynamic:</b> Java is considered to be more dynamic than C or C++ since it is designed to adapt to an evolving environment. Java programs can carry extensive amount of run-time information that can be used to verify and resolve accesses to objects on run-time.</p></li> ', ''),
(285, 'History of Java:', 'James Gosling initiated the Java language project in June 1991 for use in one of his many set-top box projects. The language, initially called Oak after an oak tree that stood outside Goslings office, also went by the name Green and ended up later being renamed as Java, from a list of random words.Sun released the first public implementation as Java 1.0 in 1995. It promised <b>Write Once, Run Anywhere</b>(WORA), providing no-cost run-times on popular platforms. On 13 November 2006, Sun released much of Java as free and open source software under the terms of the GNU General Public License (GPL).On 8 May 2007, Sun finished the process, making all of Javas core code free and open-source, aside from a small portion of code to which Sun did not hold the copyright.', ''),
(286, 'Tools you will need:', 'For performing the examples discussed in this tutorial, you will need a Pentium 200-MHz computer with a minimum of 64 MB of RAM (128 MB of RAM recommended).You also will need the following softwares: <li><p>Linux 7.1 or Windows xp/7/8 operating system.</p></li> <li><p>Java JDK 8 </p></li> <li><p>Microsoft Notepad or any other text editor</p></li> This tutorial will provide the necessary skills to create GUI, networking, and Web applications using Java.', ''),
(287, 'Try It Option:', 'We have provided you an option to compile and execute available code online. Just click on <b>Try it</b> button avaiable at top-right corner of the code window to compile and execute available code. There are certain examples which can not be executed online, so we have skipped those examples.There may be a case that you do not see the result of the compiled/executed code, in such case you can re-try to compile and execute the code using <b>execute</b> button available in compliation pop-up window.', '<br><code><pre class="prettyprint notranslate tryit"> public class MyFirstJavaProgram {      public static void main(String []args) {        System.out.println("Hello World");     } }  </pre></code><br>'),
(288, 'What is Java?', 'Java is: <li>Object Oriented </li> <li>Platform independent:</li> <li>Simple</li> <li>Secure</li> <li>Architectural- neutral</li> <li>Portable</li> <li>Robust</li> <li>Multi-threaded </li> <li>Interpreted </li> <li>High Performance</li> <li>Distributed </li> <li>Dynamic</li> ', ''),
(289, 'Java Environment Setup:', 'Java SE is freely available from the link <a href="http://java.sun.com/javase/downloads/index_jdk5.jsp" target="_blank">Download Java</a>. So you download a version based on your operating system.You can refer to installation guide for a complete detail.', ''),
(290, 'Java Basic Syntax:', ' <li><p><b>Object -</b> Objects have states and behaviors. Example: A dog has states-color, name, breed as well as behaviors -wagging, barking, eating. An object is an instance of a class. </p></li> <li><p><b>Class -</b> A class can be defined as a template/ blue print that describe the behaviors/states that object of its type support.</p></li> <li><p><b>Methods -</b> A method is basically a behavior. A class can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.</p></li> <li><p><b>Instant Variables -</b> Each object has its unique set of instant variables. An objects state is created by the values assigned to these instant variables.</p></li> ', ''),
(291, 'First Java Program:', 'Let us look at a simple code that would print the words <i>Hello World</i>.About Java programs, it is very important to keep in mind the following points. <li><p><b>Case Sensitivity - </b> Java is case sensitive which means identifier <b>Hello</b> and <b>hello</b> would have different meaning in Java.</p></li> <li><p><b>Class Names - </b> For all class names the first letter should be in Upper Case. <br /><br /> If several words are used to form a name of the class each inner words first letter should be in Upper Case.<br /><br /> Example <i>class MyFirstJavaClass </i></p></li> <li><p><b>Method Names - </b> All method names should start with a Lower Case letter.  <br /><br /> If several words are  used to form the name of the method, then each inner words first letter should be in Upper Case.<br /><br /> Example <i>public void myMethodName()</i></p></li> <li><p><b>Program File Name - </b> Name of the program file should exactly match the class name.  <br /><br /> When saving the file you should save it using the class name (Remember java is case sensitive) and append .java to the end of the name. (if the file name and the class name do not match your program will not compile).<br /><br /> Example : Assume MyFirstJavaProgram is the class  name. Then the file should be saved as <i>MyFirstJavaProgram.java</i></p></li> <li><p><b>public static void main(String args[]) -</b> java program processing starts from the main() method which is a mandatory part of every java program..</p></li> ', '<br><code><pre class="prettyprint notranslate"> public class MyFirstJavaProgram{     /* This is my first java program.       * This will print Hello World as the output     */      public static void main(String []args){        System.out.println("Hello World"); // prints Hello World     } }  </pre></code><br>'),
(292, 'Java Identifiers:', 'All Java components require names. Names used for classes, variables and methods are called identifiers.In java there are several points to remember about identifiers. They are as follows: <li><p>All identifiers should begin with a letter (A to Z or a to z ), currency character ($) or an underscore (_).</p></li> <li><p>After the first character identifiers can have any combination of characters.</p></li> <li><p>A key word cannot be used as an identifier.</p></li> <li><p>Most importantly identifiers are case sensitive.</p></li> <li><p>Examples of legal identifiers:age, $salary, _value,  __1_value</p></li> <li><p>Examples of illegal identifiers : 123abc, -salary</p></li> ', ''),
(293, 'Java Modifiers:', 'Like other languages, it is possible to modify classes, methods, etc., by using modifiers. There are two categories of modifiers. <li><p><b>Access Modifiers : </b> default, public , protected, private</p></li> <li><p><b>Non-access Modifiers : </b> final, abstract, strictfp</p></li> We will be looking into more details about modifiers in the next section.', ''),
(294, 'Java Variables:', 'We would see following type of variables in Java: <li>Local Variables</li> <li>Class Variables (Static Variables)</li> <li>Instance Variables (Non static variables)</li> ', ''),
(295, 'Java Arrays:', 'Arrays are objects that store multiple variables of the same type. However an Array itself is an object on the heap. We will look into how to declare, construct and initialize in the upcoming chapters.', ''),
(296, 'Java Enums:', 'Enums were introduced in Java 5.0. Enums restrict a variable to have one of only a few predefined values. The values in this enumerated list are called enums.With the use of enums it is possible to reduce the number of bugs in your code. For example if we consider an application for a fresh juice shop it would be possible to restrict the glass size to small, medium and Large. This would make sure that it would not allow anyone to order any size other than the small, medium or large.', ''),
(297, 'Example:', '<b>Note:</b> enums can be declared as their own or inside a class. Methods, variables, constructors can be defined inside enums as well.', '<br><code><pre class="prettyprint notranslate"> class FreshJuice{     enum FreshJuiceSize{ SMALL, MEDIUM, LARGE }    FreshJuiceSize size; }  public class FreshJuiceTest{     public static void main(String args[]){       FreshJuice juice = new FreshJuice();       juice.size = FreshJuice. FreshJuiceSize.MEDIUM ;       System.out.println("Size :" + juice.size);    } } </pre></code><br>'),
(298, 'Java Keywords:', 'The following list shows the reserved words in Java. These reserved words may not be used as constant or variable or any other identifier names.', ''),
(299, 'Comments in Java', 'Java supports single line and multi-line comments very similar to c and c++. All characters available inside any comment are ignored by Java compiler.', '<br><code><pre class="prettyprint notranslate"> public class MyFirstJavaProgram{     /* This is my first java program.     * This will print Hello World as the output     * This is an example of multi-line comments.     */      public static void main(String []args){        // This is an example of single line comment        /* This is also an example of single line comment. */        System.out.println("Hello World");      } }  </pre></code><br>'),
(300, 'Data Types in Java', 'There are two data types available in Java: <li><p>Primitive Data Types</p></li> <li><p>Reference/Object Data Types</p></li> ', ''),
(301, 'Primitive Data Types:', 'There are eight primitive data types supported by Java. Primitive data types are predefined by the language and named by a key word. Let us now look into detail about the eight primitive data types. <li>byte</li> <li>short</li> <li>int</li> <li>long</li> <li>float</li> <li>double</li> <li>boolean</li> <li>char</li> ', ''),
(302, 'Reference Data Types:', ' <li><p>Reference variables are created using defined constructors of the classes. They are used to access objects. These variables are declared to be of a specific type that cannot be changed. For example, Employee, Puppy etc.</p></li>  <li><p>Class objects, and various type of array variables come under reference data type.</p></li> <li><p>Default value of any reference variable is null.</p></li>  <li><p>A reference variable can be used to refer to any object of the declared type or any compatible type.</p></li>  <li><p>Example : Animal animal = new Animal("giraffe");</p></li>  ', ''),
(303, 'Java Literals:', 'A literal is a source code representation of a fixed value. They are represented directly in the code without any computation.Literals can be assigned to any primitive type variable. For example:String literals in Java are specified like they are in most other languages by enclosing a sequence of characters between a pair of double quotes. Examples of string literals are:Java language supports few special escape sequences for String and char literals as well. They are:', '<br><code><pre class="prettyprint notranslate"> byte a = 68; char a = A </pre></code><br><br><code><pre class="prettyprint notranslate"> "Hello World" "two\nlines" ""This is in quotes"" </pre></code><br>'),
(304, 'Java Access Modifiers:', 'Java provides a number of access modifiers to set access levels for classes, variables, methods and constructors. The four access levels are: <li><p>Visible to the package. the default. No modifiers are needed.</p></li> <li><p>Visible to the class only (private).</p></li> <li><p>Visible to the world (public).</p></li> <li><p>Visible to the package and all subclasses (protected).</p></li> ', ''),
(305, 'Java Basic Operators:', 'Java provides a rich set of operators to manipulate variables. We can divide all the Java operators into the following groups:', ''),
(306, 'Misc Operators', 'There are few other operators supported by Java Language.', ''),
(307, 'Conditional Operator ( ? : ):', 'Conditional operator is also known as the ternary operator. This operator consists of three operands and is used to evaluate boolean expressions. The goal of the operator is to decide which value should be assigned to the variable. The operator is written as :', '<br><code><pre class="prettyprint notranslate"> variable x = (expression) ? value if true : value if false </pre></code><br>'),
(308, 'instanceOf Operator:', 'This operator is used only for object reference variables. The operator checks whether the object is of a particular type(class type or interface type).  instanceOf operator is wriiten as:', '<br><code><pre class="prettyprint notranslate"> ( Object reference variable ) instanceOf  (class/interface type) </pre></code><br>'),
(309, 'The while Loop:', 'A while loop is a control structure that allows you to repeat a task a certain number of times.', ''),
(310, 'Syntax:', 'The syntax of a while loop is:', '<br><code><pre class="prettyprint notranslate"> while(Boolean_expression) {    //Statements } </pre></code><br>'),
(311, 'The do...while Loop:', 'A do...while loop is similar to a while loop, except that a do...while loop is guaranteed to execute at least one time.', ''),
(312, 'Syntax:', 'The syntax of a do...while loop is:', '<br><code><pre class="prettyprint notranslate"> do {    //Statements }while(Boolean_expression); </pre></code><br>'),
(313, 'The for Loop:', 'A for loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times.A for loop is useful when you know how many times a task is to be repeated.', ''),
(314, 'Syntax:', 'The syntax of a for loop is:', '<br><code><pre class="prettyprint notranslate"> for(initialization; Boolean_expression; update) {    //Statements } </pre></code><br>'),
(315, 'Enhanced for loop in Java:', 'As of java 5 the enhanced for loop was introduced. This is mainly used for Arrays.', ''),
(316, 'Syntax:', 'The syntax of enhanced for loop is:', '<br><code><pre class="prettyprint notranslate"> for(declaration : expression) {    //Statements } </pre></code><br>'),
(317, 'The break Keyword:', 'The <i>break</i> keyword is used to stop the entire loop. The break keyword must be used inside any loop or a switch statement.The break keyword will stop the execution of the innermost loop and start executing the next line of code after the block.', ''),
(318, 'The continue Keyword:', 'The <i>continue</i> keyword can be used in any of the loop control structures. It causes the loop to immediately jump to the next iteration of the loop. <li><p>In a for loop, the continue keyword causes flow of control to immediately jump to the update statement.</p></li> <li><p>In a while loop or do/while loop, flow of control immediately jumps to the Boolean expression.</p></li> ', ''),
(319, 'Syntax:', 'The syntax of a continue is a single statement inside any loop:', '<br><code><pre class="prettyprint notranslate"> continue; </pre></code><br>'),
(320, 'The if Statement:', 'An if statement consists of a Boolean expression followed by one or more statements.', ''),
(321, 'Syntax:', 'The syntax of an if statement is:', '<br><code><pre class="prettyprint notranslate"> if(Boolean_expression) {    //Statements will execute if the Boolean expression is true } </pre></code><br>'),
(322, 'The if...else Statement:', 'An if statement can be followed by an optional <i>else</i> statement, which executes when the Boolean expression is false.', ''),
(323, 'Syntax:', 'The syntax of a if...else is:', '<br><code><pre class="prettyprint notranslate"> if(Boolean_expression){    //Executes when the Boolean expression is true }else{    //Executes when the Boolean expression is false } </pre></code><br>'),
(324, 'The if...else if...else Statement:', 'An if statement can be followed by an optional <i>else if...else</i> statement, which is very usefull to test various conditions using single if...else if statement.', ''),
(325, 'Syntax:', 'The syntax of a if...else is:', '<br><code><pre class="prettyprint notranslate"> if(Boolean_expression 1){    //Executes when the Boolean expression 1 is true }else if(Boolean_expression 2){    //Executes when the Boolean expression 2 is true }else if(Boolean_expression 3){    //Executes when the Boolean expression 3 is true }else {    //Executes when the one of the above condition is true. } </pre></code><br>'),
(326, 'Nested if...else Statement:', 'It is always legal to nest if-else statements. When using if , else if , else statements there are few points to keep in mind. <li><p>An if can have zero or one elses and it must come after any else ifs.</p></li> <li><p>An if can have zero to many else ifs and they must come before the else.</p></li> <li><p>Once an else if succeeds, none of he remaining else ifs or elses will be tested.</p></li> ', ''),
(327, 'Syntax:', 'The syntax for a nested if...else is as follows:', '<br><code><pre class="prettyprint notranslate"> if(Boolean_expression 1){    //Executes when the Boolean expression 1 is true    if(Boolean_expression 2){       //Executes when the Boolean expression 2 is true    } } </pre></code><br>'),
(328, 'The switch Statement:', 'A <i>switch</i> statement allows a variable to be tested for equality against a list of values. Each value is called a case, and the variable being switched on is checked for each case.', ''),
(329, 'Syntax:', 'The syntax of enhanced for loop is:', '<br><code><pre class="prettyprint notranslate"> switch(expression){     case value :        //Statements        break; //optional     case value :        //Statements        break; //optional     //You can have any number of case statements.     default : //Optional        //Statements } </pre></code><br>'),
(330, 'Java Methods:', 'A Java method is a collection of statements that are grouped together to perform an operation. When you call the System.out.println method, for example, the system actually executes several statements in order to display a message on the console.In general, a method has the following syntax:A method definition consists of a method header and a method body. Here are all the parts of a method: <li><p><b>Modifiers:</b> The modifier, which is optional, tells the compiler how to call the method. This defines the access type of the method.</p></li> <li><p><b>Return Type:</b> A method may return a value. The returnValueType is the data type of the value the method returns. Some methods perform the desired operations without returning a value. In this case, the returnValueType is the keyword <b>void</b>.</p></li> <li><p><b>Method Name:</b> This is the actual name of the method. The method name and the parameter list together constitute the method signature.</p></li> <li><p><b>Parameters:</b> A parameter is like a placeholder. When a method is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of the parameters of a method. Parameters are optional; that is, a method may contain no parameters.</p></li> <li><p><b>Method Body:</b> The method body contains a collection of statements that define what the method does.</p></li> ', '<br><code><pre class="prettyprint notranslate"> modifier returnValueType methodName(list of parameters) {   // Method body; } </pre></code><br>'),
(331, 'Java Classes &amp; Objects:', ' <li><p><b>Object -</b> Objects have states and behaviors. Example: A dog has states-color, name, breed as well as behaviors -wagging, barking, eating. An object is an instance of a class. </p></li> <li><p><b>Class -</b> A class can be defined as a template/ blue print that describe the behaviors/states that object of its type support.</p></li> A sample of a class is given below:A class can contain any of the following variable types. <li><p><b>Local variables . </b>variables defined inside methods, constructors or blocks are called local variables. The variable will be declared and initialized within the method and the variable will be destroyed when the method has completed.</p></li> <li><p><b>Instance variables . </b>Instance variables are variables within a class but outside any method. These variables are instantiated when the class is loaded. Instance variables can be accessed from inside any method, constructor or blocks of that particular class.</p></li> <li><p><b>Class variables . </b> Class variables are variables declared with in a class, outside any method, with the static keyword.</p></li> ', '<br><code><pre class="prettyprint notranslate"> public class Dog{    String breed;    int age;    String color;     void barking(){    }        void hungry(){    }        void sleeping(){    } } </pre></code><br>'),
(332, 'Exceptions Handling:', 'A method catches an exception using a combination of the <b>try</b> and <b>catch</b> keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following:', '<br><code><pre class="prettyprint notranslate"> try {    //Protected code }catch(ExceptionName e1) {    //Catch block } </pre></code><br>'),
(333, 'Multiple catch Blocks:', 'A try block can be followed by multiple catch blocks. The syntax for multiple catch blocks looks like the following:', '<br><code><pre class="prettyprint notranslate"> try {    //Protected code }catch(ExceptionType1 e1) {    //Catch block }catch(ExceptionType2 e2) {    //Catch block }catch(ExceptionType3 e3) {    //Catch block } </pre></code><br>'),
(334, 'The throws/throw Keywords:', 'If a method does not handle a checked exception, the method must declare it using the <b>throws</b> keyword. The throws keyword appears at the end of a methods signature.You can throw an exception, either a newly instantiated one or an exception that you just caught, by using the <b>throw</b> keyword. Try to understand the different in throws and throw keywords.', ''),
(335, 'Java - Useful Resources', 'The following resources contain additional information on Java. Please use them to get more in-depth knowledge on this topic.', ''),
(336, 'Useful Links on Java', ' <li><p><a target="_blank" rel="nofollow" href="http://java.sun.com/docs/books/tutorial/index.html">The Java<sup><font size="-2">TM</font></sup> Tutorials</a> &minus; The Java Tutorials are practical guides for programmers who want to use the Java programming language to create applications.</p></li> <li><p><a target="_blank" rel="nofollow" href="http://java.sun.com/j2se/1.4.2/docs/index.html">Java<sup><font size="-2">TM</font></sup> 2 SDK, Standard Edition </a> &minus; Official site for Java<sup><font size="-2">TM</font></sup> 2 SDK, Standard Edition </p></li> <li><p><a target="_blank" rel="nofollow" href="http://www.java.com/en/download/index.jsp">Free Java Download</a> &minus; Download Java for your desktop computer now!</p></li> <li><p><a target="_blank" rel="nofollow" href="http://java.sun.com/reference/docs/">Sun Developer Network</a> &minus; Sun Microsystems official website listing down all the API documentation, latest Java Technologies, Books and other resource.</p></li> ', ''),
(337, 'Java - Overview', 'Java programming language was originally developed by Sun Microsystems which was initiated by James Gosling and released in 1995 as core component of Sun Microsystems Java platform (Java 1.0 [J2SE]).The latest release of the Java Standard Edition is Java SE 8. With the advancement of Java and its widespread popularity, multiple configurations were built to suite various types of platforms. Ex: J2EE for Enterprise Applications, J2ME for Mobile Applications.The new J2 versions were renamed as Java SE, Java EE and Java ME respectively. Java is guaranteed to be <b>Write Once, Run Anywhere.</b>Java is: <li><p><b>Object Oriented:</b> In Java, everything is an Object. Java can be easily extended since it is based on the Object model.</p></li> <li><p><b>Platform independent:</b> Unlike many other programming languages including C and C++, when Java is compiled, it is not compiled into platform specific machine, rather into platform independent byte code. This byte code is distributed over the web and interpreted by virtual Machine (JVM) on whichever platform it is being run.</p></li> <li><p><b>Simple:</b> Java is designed to be easy to learn. If you understand the basic concept of OOP Java would be easy to master.</p></li> <li><p><b>Secure:</b> With Javas secure feature it enables to develop virus-free, tamper-free systems. Authentication techniques are based on public-key encryption.</p></li> <li><p><b>Architectural-neutral: </b>Java compiler generates an architecture-neutral object file format which makes the compiled code to be executable on many processors, with the presence of Java runtime system.</p></li> <li><p><b>Portable:</b> Being architectural-neutral and having no implementation dependent aspects of the specification makes Java portable. Compiler in Java is written in ANSI C with a clean portability boundary which is a POSIX subset.</p></li> <li><p><b>Robust:</b> Java makes an effort to eliminate error prone situations by emphasizing mainly on compile time error checking and runtime checking.</p></li> <li><p><b>Multithreaded:</b> With Javas multithreaded feature it is possible to write programs that can do many tasks simultaneously. This design feature allows developers to construct smoothly running interactive applications.</p></li> <li><p><b>Interpreted:</b> Java byte code is translated on the fly to native machine instructions and is not stored anywhere. The development process is more rapid and analytical since the linking is an incremental and light weight process. </p></li> <li><p><b>High Performance:</b> With the use of Just-In-Time compilers, Java enables high performance.</p></li> <li><p><b>Distributed:</b> Java is designed for the distributed environment of the internet.</p></li> <li><p><b>Dynamic:</b> Java is considered to be more dynamic than C or C++ since it is designed to adapt to an evolving environment. Java programs can carry extensive amount of run-time information that can be used to verify and resolve accesses to objects on run-time.</p></li> ', ''),
(338, 'History of Java:', 'James Gosling initiated the Java language project in June 1991 for use in one of his many set-top box projects. The language, initially called Oak after an oak tree that stood outside Goslings office, also went by the name Green and ended up later being renamed as Java, from a list of random words.Sun released the first public implementation as Java 1.0 in 1995. It promised <b>Write Once, Run Anywhere</b>(WORA), providing no-cost run-times on popular platforms. On 13 November 2006, Sun released much of Java as free and open source software under the terms of the GNU General Public License (GPL).On 8 May 2007, Sun finished the process, making all of Javas core code free and open-source, aside from a small portion of code to which Sun did not hold the copyright.', ''),
(339, 'Tools you will need:', 'For performing the examples discussed in this tutorial, you will need a Pentium 200-MHz computer with a minimum of 64 MB of RAM (128 MB of RAM recommended).You also will need the following softwares: <li><p>Linux 7.1 or Windows xp/7/8 operating system.</p></li> <li><p>Java JDK 8 </p></li> <li><p>Microsoft Notepad or any other text editor</p></li> This tutorial will provide the necessary skills to create GUI, networking, and Web applications using Java.', ''),
(340, 'Try It Option:', 'We have provided you an option to compile and execute available code online. Just click on <b>Try it</b> button avaiable at top-right corner of the code window to compile and execute available code. There are certain examples which can not be executed online, so we have skipped those examples.There may be a case that you do not see the result of the compiled/executed code, in such case you can re-try to compile and execute the code using <b>execute</b> button available in compliation pop-up window.', '<br><code><pre class="prettyprint notranslate tryit"> public class MyFirstJavaProgram {      public static void main(String []args) {        System.out.println("Hello World");     } }  </pre></code><br>');

-- --------------------------------------------------------

--
-- Table structure for table `textbook`
--

CREATE TABLE `textbook` (
  `textid` int(11) NOT NULL,
  `topic` text NOT NULL,
  `content` text NOT NULL,
  `code` text NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `textbook`
--

INSERT INTO `textbook` (`textid`, `topic`, `content`, `code`) VALUES
(1, 'Annotations - Introduction', 'In Java, an annotation is a language construct that was introduced in J2SE 1.5 that provides a mechanism for including metadata directly in the source code.Annotations can provide metadata for java classes, attributes, and methods. Syntactically, annotations can be viewed as special kind of modifier and can be used anywhere that other modifiers (such as public, static, or final) can be usedOne of the main forces of adding this feature to Java was the wide spread use of XML descriptors to add additional information, metadata for Java classes. Frameworks like EJB, JSF, Spring, Hibernate were heavily using external XML descriptors. The problem of those external descriptors is that those files are out of reach of the Java compiler and for that reason compiler type checking could not be used. A small spelling mistake bug in a huge XML descriptor file is hard to locate and fixed. The Java annotations on the other hand use the Java compiler type checking features, so annotation names spelling mistakes will be caught by the Java compiler.In summary, annotations can be...', ''),
(2, 'Arithmetic expressions - Using bitwise operators within Java', 'Java has besides arithmetic operators a set of bit operators to manipulate the bits in a number, and a set of logical operators. The bitwise logical operators areBesides these logical bitwise functions, there are also operators to assign numbers to variables (x = -5):The shift operators are used to shift the bits to the left or right, which is also a quick way to multiply/divide by two:', ''),
(3, 'Arithmetic expressions', 'In order to do arithmetic in Java, one must first declare at least one variable. Typically one declares a variable and assigns it a value before any arithmetic is done. Heres an example of declaring an integer variable:After creating a variable, one can manipulate its value by using Javas operators: + (addition), - (subtraction), * (multiplication), / (integer division), % (modulo or remainder), ++ (pre- & postincrement by one), -- (pre- & postdecrement by one).The division operator rounds towards zero: 5/2 is 2, and -5/2 is -2. The remainder operator has the same sign as the left operand; it is defined such that ((a/b)*b) + (a%b) is always equal to a. The preincrement, predecrement, postincrement, and postdecrement operators are special: they also change the value of the variable, by adding or subtracting one. The only difference is that preincrement/decrement returns the new value of the variable; postincrement returns the original value of the variable.When using several operators in the same expression, one must consider Javas order of precedence. Java uses the standard PEMDAS (Parenthesis, Exponents, Multiplication and Division, Addition and Subtraction) order. When there are multiple instances of the same precedence, Java reads from left to right. Consider what the output of the following code would be:The following chart shows how Java would compute this expression: Besides performing mathematical functions, there are also operators to assign numbers to variables (each example again uses the variable initialized as x = 5):', ''),
(4, 'ArrayList - Initializing', 'The ArrayList class supports three constructors. The first constructor builds an empty array list.:The following constructor builds an array list that is initialized with the elements of the collection c.The following constructor builds an array list that has the specified initial capacity. The capacity is the size of the underlying array that is used to store the elements.The capacity grows automatically as elements are added to an array list.', ''),
(5, 'ArrayList - Methods', 'ArrayList defines following methods:Adding Element and Size of ArrayListOutput for Adding Element and Size of ArrayListDifferent Method in ArrayListOutput for Different Method in ArrayListSome more ArrayList methods:', ''),
(6, 'ArrayList', 'The ArrayList class extends AbstractList and implements the List interface. ArrayList supports dynamic arrays that can grow as needed.Standard Java arrays are of a fixed length. After arrays are created, they cannot grow or shrink, which means that you must know in advance how many elements an array will hold.Array lists are created with an initial size. When this size is exceeded, the collection is automatically enlarged. When objects are removed, the array may be shrunk.', ''),
(7, 'Arrays - Fundamentals', 'In Java, an array is an object. This object has a given type for the contained primitive types or objects (int, char, String, ...). An array can be declared in several ways:Those syntaxes are identical but the first one is recommended. It can also be instantiated in several ways:At line 1, we instantiate an array of 10 items with non-initialized items. At line 2, we instantiate an array of 10 given items. It will each be given an index according to its order. We can know the size of the array using the length attribute:Arrays are allocated at runtime, so the specified size in an array creation expression may be a variable (rather than a constant expression as in C). However, the size of an instantiated array never changes. If you need to change the size, you have to create a new instance. Items can be accessed by their index. Beware! The first index is 0:If you attempt to access to a too high index or negative index, you will get an ArrayIndexOutOfBoundsException.', ''),
(8, 'Arrays - Multidimensional Array', 'Going further any number of dimensional array can be defined.or', ''),
(9, 'Arrays - Two-Dimensional Arrays', 'Actually, there are no two-dimensional arrays in Java. However, an array can contain any class of object, including an array:Its not exactly equivalent to two-dimensional arrays because the size of the sub-arrays may vary. The sub-array reference can even be null. Consider:Note that the length of a two-dimensional array is the number of one-dimensional arrays it contains. In the above example, weirdTwoDimArray.length is 3, whereas weirdTwoDimArray[2].length is 5.In the code section 3.58, we defined an array that has three elements, each element contains an array having 5 elements. We could create the array having the 5 elements first and use that one in the initialize block.', ''),
(10, 'Arrays', 'An array is similar to a table of objects or primitive types, keyed by index. You may have noticed the strange parameter of the default main() method (String[] args) since the beginning of the book. It is an array. Lets handle this parameter:In the code listing 3.15, the array is args. It is an array of String objects (here those objects are the words that have been typed by the user at the program launching). At line 4, One contained object is accessed using its index in the array. You can see that its value is printed on the standard output. Note that the strings have been put in the array with the right order.', ''),
(11, 'Basic IO - Understanding input and output', 'The Java platform is an isolated entity, a space on your OS in a way, where everything outside this system is its environment. The interaction between the system and its environment is a two-way dialog of sorts. Either the system receives messages from its environment, or it conveys its messages to the same. When a message is received by the system, it is called an input, its opposite is an output. On a whole, this communication is termed input/output abbreviated as I/O.The following chapters are designed to introduce basic input and output in Java, including reading text input from the keyboard, outputting text to the monitor, and reading/writing files from the file system. More advanced user interaction using Graphics and Graphical User Interface (GUI) programs is taken up in the later section on Swing.Writing to the screen is very easy, and can be accomplished using one of two methods:As of version 1.5.0, Java provides a class in the java.util package called Scanner that simplifies keyboard input.Alternatively, one could write a method to handle keyboard input:Note that the code above shouldnt be used in most applications, as it creates new Objects every time the method is run. A better alternative would be to create a separate class file to handle keyboard input.', ''),
(12, 'Basic IO', 'This section covers the Java platform classes used for basic input and output. But before we begin we need to have a concrete understanding of what input and output means in programming. To grasp this concept, think of the Java platform as a system.', ''),
(13, 'Basic Synchronization', 'In a multi-threaded environment, when more than one thread can access and modify a resource, the outcome could be unpredictable. For example, lets have a counter variable that is incremented by more than one thread.Beware! Synchronization is an ambiguous term. It doesnt consist of making all threads executing the same code section at the same time. It is the opposite. It prevents any two threads from executing the same code section at the same time. It synchronizes the end of one processing with the beginning of a second processing.The above code is built up by the following sub-operations:Lets say that two threads need to execute that code, and if the initial value of the counter variable is zero, we expect after the operations the value to be 2.In the above case Thread 1 operation is lost, because Thread 2 overwrites its value. Wed like Thread 2 to wait until Thread 1 finishes the operation. See below:', ''),
(14, 'Boolean expressions - Boolean operators', 'The Java boolean operators are based on the operations of the boolean algebra. The boolean operators operate directly on boolean values.Here is a list of four common boolean operators in Java:The boolean NOT operator ("!") inverts the value of a boolean expression. The boolean AND operator ("&&") will result in true if and only if the values on both sides of the operator are true. The boolean inclusive OR operator ("||") will result in true if either or both of the values on the sides of the operator is true. The boolean exclusive XOR operator ("^") will result in true if one and only of the values on the sides of the operator is true.To show how these operators are used, here is an example:Here are the truth tables for the boolean operators:In Java, boolean logic has a useful property called short circuiting. This means that expressions will only be evaluated as far as necessary. In the expression (a && b), if a is false, then b will not be evaluated because the expression will be false no matter what. Here is an example that shows that the second expression is not automatically checked:To disable this property, you can use & instead of && and | instead of || but its not recommended.', ''),
(15, 'Boolean expressions - Comparative operators', 'Java has several operators that can be used to compare variables. For example, how would you tell if one variable has a greater value than another? The answer: use the "greater-than" operator.Here is a list of the comparative operators in Java:To see how these operators are used, look at this example:Comparative operators can be used on any primitive types (except boolean), but only the "equals" and "does not equal" operators work on objects. This is because the less-than/greater-than operators cannot be applied to objects, but the equivalency operators can.', ''),
(16, 'Boolean expressions', 'Boolean values are values that evaluate to either true or false, and are represented by the boolean data type. Boolean expressions are very similar to mathematical expressions, but instead of using mathematical operators such as "+" or "-", you use comparative or boolean operators such as "==" or "!".', ''),
(17, 'Canvas - Get, set, draw!', 'Now that the basic structure of our program has been laid out, we need to explore how drawing is actually done by writing Java code. Move to the next section and try your hand at drawing basic shapes and lines. But whilst you are still fresh to the concept of a Canvas, why not test your knowledge. Try answering these questions below.', ''),
(18, 'Canvas - Overriding the paint(Graphics) method', 'Below is an example on how you need to override the above method. For this very example, the component class that we would be using would be the Canvas class. For more information about the Canvas class, see the section on Understanding the Canvas class', ''),
(19, 'Canvas - Understanding the Canvas class', 'Code listing 9.1 shows the simplicity and power of the syntax for enabling the graphics functions within Java. Lets begin by understanding what a Canvas class does. A Canvas class is a derivative or a sub-class of the Component class and when placed over a Frame, displays as a blank area.For the purpose of drawing graphics, you may use any other class derived from the Component class, for instance, JPanel or even JTextField or JButton. Why we use the Canvas class is purely to grasp the idea of drawing in Java.Let us refine the above code for the class to be executable and the Canvas to be displayed. For this we will add an entry-point method namely the main(String[]) method in its body and calling a JFrame class to load the canvas on.The following code now helps our class to be executable and displays the canvas on top of the frame as it displays. Running this class would result in an empty frame, however it should be clear that the canvas is sitting atop it and is merely not displaying any drawings yet.', ''),
(20, 'Canvas', 'An essential part of programming in Java requires you to build exciting new user interfaces for yourselves. Components that come built into the Java framework are regular UI elements, however for a more rich experience, you need controls of your own. Take, for instance, a charting application. No charting tool comes built into a Java API. You need to manually draw the chart yourself.Coding drawing, to begin with, is pretty daunting but once you know the basics of Graphics programming in Java, you can create elegant graphics and art in no time. But the question that arises in ones mind is what to draw on. The answer to this question is simpler than it seems. You can start drawing on any component in the Java framework. Whether it be a panel, window or even a button.Let me break it down for you. A component in the Java language is a class that has been derived from the Component class. Each component has a method with a signature paint(Graphics) which can be overridden to manually draw something atop it.', ''),
(21, 'Checked Exceptions', 'A checked exception is an exception that must be either caught or declared in a method where it can be thrown. For example, the java.io.IOException is a checked exception. To understand what is a checked exception, consider the following code:This code wont compile as it throws or can throw a checked exception without catching it or declare it. Two different modifications can resolve the situation: to catching it or to declare it by the throws keyword.In the Java class hierarchy, an exception is a checked exception if it inherits from java.lang.Exception, but not from java.lang.RuntimeException. All the application or business logic exceptions should be checked exceptions.It is possible that a method declares that it can throw an exception, but actually it does not. Still, the caller has to deal with it. The checked exception declaration has a domino effect. Any methods that will use the previous method will also have to handle the checked exception, and so on.So the compiler for the Java programming language checks, at compile time, that a program contains handlers for all application exceptions, by analyzing each method body. If, by executing the method body, an exception can be thrown to the caller, that exception must be declared. How does the compiler know whether a method body can throw an exception? That is easy. Inside the method body, there are calls to other methods; the compiler looks at each of their method signature, what exceptions they declared to throw.', ''),
(22, 'Classes, Objects and Types - Instantiation and constructors', 'In order to get from class to object, we "build" our object by instantiation. Instantiation simply means to create an instance of a class. Instance and object are very similar terms and are sometimes interchangeable, but remember that an instance refers to a specific object, which was created from a class.This instantiation is brought about by one of the classs methods, called a constructor. As its name implies, a constructor builds the object based on the blueprint. Behind the scenes, this means that computer memory is being allocated for the instance, and values are being assigned to the data members.In general there are four constructor types: default, non-default, copy, and cloning.A default constructor will build the most basic instance. Generally, this means assigning all the fields values like null, zero, or an empty string. Nothing would stop you, however, from your default sports car color from being red, but this is generally bad programming style. Another programmer would be confused if your basic car came out red instead of say, colorless.A non-default constructor is designed to create an object instance with prescribed values for most, if not all, of the objects fields. The car is red, goes from 0-60 in 12 seconds, tops out at 190mph, etc.A copy constructor is not included in the Java language, however one can easily create a constructor that do the same as a copy constructor. Its important to understand what it is. As the name implies, a copy constructor creates a new instance to be a duplicate of an already existing one. In Java, this can be also accomplished by creating the instance with the default constructor, and then using the assignment operator to equivocate them. This is not possible in all languages though, so just keep the terminology under your belt.Java has the concepts of cloning object, and the end results are similar to copy constructor. Cloning an object is faster than creation with the new keyword, because all the object memory is copied at once to destination cloned object. This is possible by implementing the Cloneable interface, which allows the method Object.clone() to perform a field-by-field copy.', ''),
(23, 'Classes, Objects and Types - Methods in the Object class', 'Methods in the java.lang.Object class are inherited, and thus shared in common by all classes.The java.lang.Object.clone() method returns a new object that is a copy of the current object. Classes must implement the marker interface java.lang.Cloneable to indicate that they can be cloned.The java.lang.Object.equals(java.lang.Object) method compares the object to another object and returns a boolean result indicating if the two objects are equal. Semantically, this method compares the contents of the objects whereas the equality comparison operator "==" compares the object references. The equals method is used by many of the data structure classes in the java.util package. Some of these data structure classes also rely on the Object.hashCode methodsee the hashCode method for details on the contract between equals and hashCode. Implementing equals() isnt always as easy as it seems, see Secrets of equals() for more information.The java.lang.Object.finalize() method is called exactly once before the garbage collector frees the memory for object. A class overrides finalize to perform any clean up that must be performed before an object is reclaimed. Most objects do not need to override finalize.There is no guarantee when the finalize method will be called, or the order in which the finalize method will be called for multiple objects. If the JVM exits without performing garbage collection, the OS may free the objects, in which case the finalize method doesnt get called.The finalize method should always be declared protected to prevent other classes from calling the finalize method.The java.lang.Object.getClass() method returns the java.lang.Class object for the class that was used to instantiate the object. The class object is the base class of reflection in Java. Additional reflection support is provided in the java.lang.reflect package.The java.lang.Object.hashCode() method returns an integer (int). This integer can be used to distinguish objects although not completely. It quickly separates most of the objects and those with the same hash code are separated later in another way. It is used by the classes that provide associative arrays, for instance, those that implement the java.util.Map interface . They use the hash code to store the object in the associative array. A good hashCode implementation will return a hash code:The second point means that two different objects can have the same hash code so two objects with the same hash code are not necessarily the same!Since associative arrays depend on both the equals and hashCode methods, there is an important contract between these two methods that must be maintained if the objects are to be inserted into a Map:In order to maintain this contract, a class that overrides the equals method must also override the hashCode method, and vice versa, so that hashCode is based on the same properties (or a subset of the properties) as equals.A further contract that the map has with the object is that the results of the hashCode and equals methods will not change once the object has been inserted into the map. For this reason, it is generally a good practice to base the hash function on immutable properties of the object.The java.lang.Object.toString() method returns a java.lang.String that contains a text representation of the object. The toString method is implicitly called by the compiler when an object operand is used with the string concatenation operators (+ and +=).Every object has two wait lists for threads associated with it. One wait list is used by the synchronized keyword to acquire the mutex lock associated with the object. If the mutex lock is currently held by another thread, the current thread is added to the list of blocked threads waiting on the mutex lock. The other wait list is used for signaling between threads accomplished through the wait and notify and notifyAll methods.Use of wait/notify allows efficient coordination of tasks between threads. When one thread needs to wait for another thread to complete an operation, or needs to wait until an event occurs, t', ''),
(24, 'Classes, Objects and Types - Methods in the Object class', 'he thread can suspend its execution and wait to be notified when the event occurs. This is in contrast to polling, where the thread repeatedly sleeps for a short period of time and then checks a flag or other condition indicator. Polling is both more computationally expensive, as the thread has to continue checking, and less responsive since the thread wont notice the condition has changed until the next time to check.There are three overloaded versions of the wait method to support different ways to specify the timeout value: java.lang.Object.wait(), java.lang.Object.wait(long) and java.lang.Object.wait(long, int). The first method uses a timeout value of zero (0), which means that the wait does not timeout; the second method takes the number of milliseconds as a timeout; the third method takes the number of nanoseconds as a timeout, calculated as 1000000 * timeout + nanos.The thread calling wait is blocked (removed from the set of executable threads) and added to the objects wait list. The thread remains in the objects wait list until one of three events occurs:The wait method must be called inside of a block or method synchronized on the object. This insures that there are no race conditions between wait and notify. When the thread is placed in the wait list, the thread releases the objects mutex lock. After the thread is removed from the wait list and added to the set of executable threads, it must acquire the objects mutex lock before continuing execution.The java.lang.Object.notify() and java.lang.Object.notifyAll() methods remove one or more threads from an objects wait list and add them to the set of executable threads. notify removes a single thread from the wait list, while notifyAll removes all threads from the wait list. Which thread is removed by notify is unspecified and dependent on the JVM implementation.The notify methods must be called inside of a block or method synchronized on the object. This insures that there are no race conditions between wait and notify.', ''),
(25, 'Classes, Objects and Types - Type', 'When an object is created, a reference to the object is also created. The object can not be accessed directly in Java, only through this object reference. This object reference has a type assigned to it. We need this type when passing the object reference to a method as a parameter. Java does strong type checking.Type is basically a list of features/operations, that can be performed through that object reference. The object reference type is basically a contract that guarantees that those operations will be there at run time.When a car is created, it comes with a list of features/operations listed in the user manual that guarantees that those will be there when the car is used.When you create an object from a class by default its type is the same as its class. It means that all the features/operations the class defined are there and available, and can be used. See below:You can assign this to a variable having the same type as the class:You can assign the created object reference to the class, super class, or to an interface the class implements:In the car analogy, the created car may have different Type of drivers. We create separate user manuals for them, Average user manual, Power user manual, Child user manual, or Handicapped user manual. Each type of user manual describes only those features/operations appropriate for the type of driver. The Power driver may have additional gears to switch to higher speeds, that are not available to other type of users...When the car key is passed from an adult to a child we replacing the user manuals, that is called Type Casting.In Java, casts can occur in three ways:', ''),
(26, 'Classes, Objects and Types', 'An object is composed of fields and methods. The fields, also called data members, characteristics, attributes, or properties, describe the state of the object. The methods generally describe the actions associated with a particular object. Think of an object as a noun, its fields as adjectives describing that noun, and its methods as the verbs that can be performed by or on that noun.For example, a sports car is an object. Some of its fields might be its height, weight, acceleration, and speed. An objects fields just hold data about that object. Some of the methods of the sports car could be "drive", "park", "race", etc. The methods really dont mean much unless associated with the sports car, and the same goes for the fields.The blueprint that lets us build our sports car object is called a class. A class doesnt tell us how fast our sports car goes, or what color it is, but it does tell us that our sports car will have a field representing speed and color, and that they will be say, a number and a word (or hex color code), respectively. The class also lays out the methods for us, telling the car how to park and drive, but these methods cant take any action with just the blueprint they need an object to have an effect.In Java, a class is located in a file similar to its own name. If you want to have a class called SportsCar, its source file needs to be SportsCar.java. The class is created by placing the following in the source file:The class doesnt do anything yet, as you will need to add methods and field variables first.The objects are different from the primitive types because:', ''),
(27, 'Client Server - Socket Connection Example', 'In this page there is an example for socket connection.Java language was developed having network computing in mind. For this reason it is very easy to create a server program. A server is a piece of code that runs all the time listening on a particular port on the computer for incoming request. When a request arrives, it starts a new thread to service the request. See the following example:A client code for a server/service is usually an API that a user application uses to interface to the server. With the help of a client API the user application does not have to know how to connect to the server to get services.The following is the client class for the above server:', ''),
(28, 'Client Server', 'In 1990s, the trend was moving away from Mainframe computing to Client/Server, as the price of Unix servers dropped. The database access and some business logic were centralized on the back-end server, collecting data from the user program was installed on the front-end users "client" computers. In the Java world there are three main ways the front-end and the back-end could simply communicate.', ''),
(29, 'Coding conventions', 'The Java code conventions are defined by Oracle in the coding conventions document. In short, these conventions ask the user to use camel case when defining classes, methods, or variables. Classes start with a capital letter and should be nouns, like CalendarDialogView. For methods, the names should be verbs in imperative form, like getBrakeSystemType, and should start with a lowercase letter.It is important to get used to and follow coding conventions, so that code written by multiple programmers will appear the same. Projects may re-define the standard code conventions to better fit their needs. Examples include a list of allowed abbreviations, as these can often make the code difficult to understand for other designers. Documentation should always acompany code, .One example from the coding conventions is how to define a constant. Constants should be written with capital letters in Java, where the words are separated by an underscore (_) character. In the Java coding conventions, a constant is a static final field in a class.The reason for this diversion is that Java is not 100% object-oriented and discerns between "simple" and "complex" types. These will be handled in detail in the following sections. An example for a simple type is the byte type. An example for a complex type is a class. A subset of the complex types are classes that cannot be modified after creation, like a String, which is a concatenation of characters.For instance, consider the following "constants":', ''),
(30, 'Collection - Collection classes', 'There is no direct implementation for the java.util.Collection interface. The Collection interface has five sub interfaces.A set collection contains unique elements, so duplicates are not allowed. It is similar to a mathematical Set. When adding a new item to a set, the set calls the method int hashCode() of the item and compare it to the hash code of all the already inserted items. If the hash code has not been found, the item is added. If it is, the set now call the boolean equals(Object obj); method with all the set items. If all calls returns false, the item is inserted. If not, the item is not inserted.Set cannot have duplicates in it. You may wonder how duplicates are detected when we are adding an object to the Set. We have to see if that object exists in the Set or not. It is not enough to check the object references, the objects values have to be checked as well.To do that, fortunately, each java object has the boolean equals(Object obj), method available inherited from Object. You need to override it. That method will be called by the Set implementation to compare the two objects to see if they are equal or not.There is a problem, though. What if I put two different type of objects to the Set. I put an Apple and an Orange. They can not be compared. Calling the equals() method would cause a ClassCastException. There are two solutions to this:Note:The SortedSet interface is the same as the Set interface plus the elements in the SortedSet are sorted. It extends the Set Interface. All elements in the SortedSet must implement the Comparable Interface, furthermore all elements must be mutually comparable.Note that the ordering maintained by a sorted set must be consistent with equals if the sorted set is to correctly implement the Set interface. This is so because the Set interface is defined in terms of the equals operation, but a sorted set performs all element comparisons using its compare method, so two elements that are deemed equal by this method are, from the standpoint of the sorted set, equal.The SortedSet interface has additional methods due to the sorted nature of the Set. Those are:In a list collection, the elements are put in a certain order, and can be accessed by an index. Duplicates are allowed, the same element can be added twice to a list. It has the following implementations:Each node is related to an item of the linked list. To remove an element from the linked list the pointers need to be rearranged. After removing Node 2:', ''),
(31, 'Collection - Custom collection', 'The Java JDK collection implementations are quite powerful and good, so it is unlikely that you will need to write your own. The usage of the different collections are the same but the implementations are different. If the existing collection implementations do not meet your needs, you can write your version of the implementation. Your version of the implementation just needs to implement the same java.util.Collection interface, then you can switch to using your implementation and the code that is using the collection does not need to be changed.Use the Collection interface if you need to keep related (usually the same type of) objects together in a collection where you can:The advantages of using the Collection interface are:The Collection interface defines the following basic operations:Note that in addAll() we can add any type of collection. This is the beauty of using the Collection interface. You can have a LinkedList and just call the addAll(list) method, passing in a list. You can pass in a Vector, an ArrayList, a HashSet, a TreeSet, a YourImpOfCollection, ... All those different types of collection will be magically converted to a LinkedList.Lets have a closer look at this magic. The conversion is easy because the Collection interface defines a standard way of looping through the elements. The following code is a possible implementation of addAll() method of the LinkedList.The above code just iterates through the passed in collection and adds the elements to the linked list. You do not have to do that, since that is already defined. What you might need to code for is to loop through a Customer collection:Notice two things:', ''),
(32, 'Collection - Generics', 'Objects put into a collection are upcasted to Object class. It means that you need to cast the object reference back when you get an element out from the collection. It also means that you need to know the type of the object when you take it out. If a collection contains different types of objects, we will have difficulty finding out the type of the objects obtained from a collection at run time. Lets use a collection with any objects in it:This error could have been fixed earlier, at compile time, using generic types.The Generics has been added since JDK version 1.5. It is an enhancement to the type system of the Java language. All collection implementations since 1.5 now have one parameterized type <E> added. The E refers to an Element type. When a collection is created, the actual Element type will replace the E. In the collection, the objects are now upcasted to E class.ageList is a collection that can contain only Integer objects as elements. No casting is required when we take out an element.Generics is not mandatory but it is often used with the collection classes.', ''),
(33, 'Collection - Queue', 'The Queue interface provides additional insertion, extraction, and inspection operations. There are FIFO (first in, first out) and LIFO (last in, first out) queues. This interface adds the following operations to the Collection interface:', ''),
(34, 'Collection - Synchronization', 'Synchronization is important when you are running several threads. Beware, synchronization does not mean that your collection is thread-safe. A thread-safe collection is also called a concurrent collection. Most of the popular collection classes have implementations for both single thread and multiple thread environments. The non-synchronized implementations are always faster. You can use the non-synchronized implementations in multiple thread environments, when you make sure that only one thread updates the collection at any given time.A new Java JDK package was introduced at Java 1.5, that is java.util.concurrent. This package supplies a few Collection implementations designed for use in multi-threaded environments.The following table lists all the synchronized collection classes:', ''),
(35, 'Collection', 'The most basic collection interface is called Collection. This interface gives the user a generic usage of a collection. All collections need to have the same basic operations. Those are:When you put an object in a collection, this object is not actually in the collection. Only its object reference is added to the collection. This means that if an object is changed after it was put in an collection, the object in the collection also changes. The code listing 5.2 computes the seven next days from tomorrow and store each date in a list to read it after. See what happens:Each collection items were said to be updated to a different date but they all have been updated to the last one. It means that each update has updated all the collection items. And this is the case. The currentDate has been used to fill all the collection items. The collection didnt keep trace of the added values (one of the seven dates) but the added object references (currentDate). So the collection contains the same object seven times! To avoid this issue, we should have coded it this way:Now each time we add an item to the collection, it is a different instance. All the items evolve separately. To add an object in a collection and avoid this item to be changed each time the source object is changed, you have to copy or clone the object before you add it to the collection.', ''),
(36, 'Comments - Comments and unicode', 'Be aware that Java still interprets Unicode sequences within comments. For example, the Unicode sequence u002au002f (whose codepoints correspond to */) is processed early in the Java compilers lexical scanning of the source file, even before comments are processed, so this is a valid star-slash comment in Java:and is lexically equivalent to(The * character is Unicode 002A and the / character is Unicode 002F.)Similar caveats apply to newline characters in slash-slash comments.For example:That is because u000a is Unicode for a new line, making the compiler think that you have added a new line when you havent.', ''),
(37, 'Comments - Javadoc comments', 'Javadoc comments are a special case of slash-star comments.', ''),
(38, 'Comments - Syntax', 'The comments in Java use the same syntax as in C++.An end-of-line comment starts with two slashes and ends with the end of the line. This syntax can be used on a single line too.A comment on several lines is framed with / + * and * + /.By convention, subsequent lines of slash-star comments begin with a star aligned under the star in the open comment sequence, but this is not required. Never nest a slash-star comment in another slash-star comment. If you accidentally nest such comments, you will probably get a syntax error from the compiler soon after the first star-slash sequence.If you need to have the sequence */ inside a comment you can use html numeric entities: *&#47;.Slash-star comments may also be placed between any Java tokens, though not recommended:However, comments are not parsed as comments when they occur in string literals.It results in a 33 character string.', ''),
(39, 'Comments', 'A comment allows to insert text that will not be compiled nor interpreted. It can appear anywhere in the source code where whitespaces are allowed.It is useful for explaining what the source code does by:It can also be used to make the compiler ignore a portion of code: temporary code for debugging, code under development...', ''),
(40, 'Comparing Objects - Comparing for reference equality', 'The == operator can be used to check if two object references point to the same object.', ''),
(41, 'Comparing Objects - Comparing for value equality', 'To be able to compare two Java objects of the same class the boolean equals(Object obj) method must be overriden and implemented by the class.The implementor decides which values must be equal to consider two objects to be equal. For example in the below class, the name and the address must be equal but not the description.After the equals() method is overriden, two objects from the same class can be compared like this:Note that equal objects must have equal hash codes. Therefore, when overriding the equals method, you must also override the hashCode method. Failure to do so violates the general contract for the hashCode method, and any classes that use the hash code, such as HashMap will not function properly.', ''),
(42, 'Comparing Objects', 'In Java, we can distinguish two kinds of equality.If two objects are equal in reference, they are equal in value too.', ''),
(43, 'Compilation - Ant', 'The best way to build your application is to use a build tool. This checks all the needed dependencies and compiles only the needed class for the build. Ant tool is one of the best and the most popular build tools currently available. Ant is a build management tool designed to replace MAKE as the tool for automated builds of large Java applications. Like Java, and unlike MAKE, Ant is designed to be platform independent.Using Ant you would build your application from the command line by typing:The build.xml file contains all the information needed to build the application.Building a Java application requires certain tasks to be performed defined in a build.xml file. Those tasks may include not only compiling the code, but also copying code, packaging the program to a Jar, creating EJBs, running automated tests, doing ftp for the code to remote site, and so on. For some tasks a condition can be assigned, for example to compile only changed code, or do the task if that was not already done so. Tasks dependency can also be specified, which will make sure that the order of executions of the tasks are in the right order. For example, when compiling the code before packaging it to a jar, the package-to-jar task depends on the compilation task.The build.xml file is generally kept in the root directory of the java project. Ant parses this file and executes the tasks therein. Below we give an example build.xml file.Ant tool is written in Java and is open source, so it can be extended if there is a task youd like to be done during the build that is not in the predefined tasks list. It is very easy to hook your ant task code to the other tasks: your code only needs to be in the classpath, and the Ant tool will load it at runtime. For more information about writing your own Ant tasks, please see the project website at http://ant.apache.org/.The next most popular way to build applications is using an Integrated Development Environment (IDE).', ''),
(44, 'Compilation - Automatic Compilation of Dependent Classes', 'In Java, if you have used any reference to any other java object, then the class for that object will be automatically compiled, if that was not compiled already. These automatic compilations are nested, and this continues until all classes are compiled that are needed to run the program. So it is usually enough to compile only the high level class, since all the dependent classes will be automatically compiled.However, you cant rely on this feature if your program is using reflection to create objects, or you are compiling for servlets or for a "jar", package. In these cases you should list these classes for explicit compilation.', ''),
(45, 'Compilation - Filename Case', 'The Java source file name must be the same as the public class name that the file contains. There can be only one public class defined per file. The Java class name is case sensitive, as is the source file name.The naming convention for the class name is for it to start with a capital letter.', ''),
(46, 'Compilation - Packages, Subdirectories, and Resources', 'Each Java top level class belongs to a package (covered in the chapter about Packages). This may be declared in a package statement at the beginning of the file; if that is missing, the class belongs to the unnamed package.For compilation, the file must be in the right directory structure. A file containing a class in the unnamed package must be in the current/root directory; if the class belongs to a package, it must be in a directory with the same name as the package.The convention is that package names and directory names corresponding to the package consist of only lower case letters.A class with this package declarationhas to be in a directory named example.A class with this package declarationhas to be in a directory named en which has to be a sub-directory of wikibooks which in turn has to be a sub-directory of org resulting in org/wikibooks/en on Linux or orgwikibooksen on Windows.Java programs often contain non-code files such as images and properties files. These are referred to generally as resources and stored in directories local to the classes in which theyre used. For example, if the class com.example.ExampleApp uses the icon.png file, this file could be stored as /com/example/resources/icon.png. These resources present a problem when a program is complied, because javac does not copy them to wherever the .class files are being complied to (see above); it is up to the programmer to move the resource files and directories.', ''),
(47, 'Compilation - Quick compilation procedure', 'To execute your first Java program, follow the instructions below:', ''),
(48, 'Compilation - The JIT compiler', 'The Just-In-Time (JIT) compiler is the compiler that converts the byte-code to machine code. It compiles byte-code once and the compiled machine code is re-used again and again, to speed up execution. Early Java compilers compiled the byte-code to machine code each time it was used, but more modern compilers cache this machine code for reuse on the machine. Even then, javas JIT compiling was still faster than an "interpreter-language", where code is compiled from high level language, instead of from byte-code each time it was used.The standard JIT compiler runs on demand. When a method is called repeatedly, the JIT compiler analyzes the bytecode and produces highly efficient machine code, which runs very fast. The JIT compiler is smart enough to recognize when the code has already been compiled, so as the application runs, compilation happens only as needed. As Java applications run, they tend to become faster and faster, because the JIT can perform runtime profiling and optimization to the code to meet the execution environment. Methods or code blocks which do not run often receive less optimization; those which run often (so called hotspots) receive more profiling and optimization.', ''),
(49, 'Compilation', 'In Java, programs are not compiled into executable files; they are compiled into bytecode (as discussed earlier), which the JVM (Java Virtual Machine) then executes at runtime. Java source code is compiled into bytecode when we use the javac compiler. The bytecode gets saved on the disk with the file extension .class. When the program is to be run, the bytecode is converted, using the just-in-time (JIT) compiler. The result is machine code which is then fed to the memory and is executed.Java code needs to be compiled twice in order to be executed:The Java classes/bytecode are compiled to machine code and loaded into memory by the JVM when needed the first time. This is different from other languages like C/C++ where programs are to be compiled to machine code and linked to create an executable file before it can be executed.', ''),
(50, 'Compiler and Annotations', 'Annotations can be used by the compiler to carry out certain directives. Much that youd love programming in Java, you probably would have been fussed about compiler warnings. Compiler warnings are not necessarily errors but are warnings that tell you the code might malfunction because of some reason.You can issue directive to the compiler in the shape of three pre-defined annotation to tell it what sort of pre-processing a certain bit of code requires. The three annotations are:@Deprecated is used to flag that a method or class should no longer be used, normally because a better alternative exists. Compilers and IDEs typically raise a warning if deprecated code is invoked from non deprecated code. [1]@Override flags that a method overrides a method in a superclass. If there is no overridden method, a compile error should occur. [2]@SuppressWarnings(..) SuppressWarnings tells the compiler not to report on some, or all, types of warnings. It can be applied to a type, a method or a variable. [3]', '');
INSERT INTO `textbook` (`textid`, `topic`, `content`, `code`) VALUES
(51, 'Conditional blocks', 'Conditional blocks allow a program to take a different path depending on some condition(s). These allow a program to perform a test and then take action based on the result of that test. In the code sections, the actually executed code lines will be highlighted.The if block executes only if the boolean expression associated with it is true. The structure of an if block is as follows:Here is a double example to illustrate what happens if the condition is true and if the condition is false:The if block may optionally be followed by an else block which will execute if that boolean expression is false. The structure of an if block is as follows:An else-if block may be used when multiple conditions need to be checked. else-if statements come after the if block, but before the else block. The structure of an if block is as follows:Here is an example to illustrate:Keep in mind that only a single block will execute, and it will be the first true condition.All the conditions are evaluated when if is reached, no matter what the result of the condition is, after the execution of the if block:Conditional expressions use the compound ?: operator. Syntax:This evaluates boolean expression1, and if it is true then the conditional expression has the value of expression1; otherwise the conditional expression has the value of expression2.Example:This is equivalent to the following code fragment:The switch conditional statement is basically a shorthand version of writing many if...else statements. The switch block evaluates a char, byte, short, or int (or enum, starting in J2SE 5.0; or String, starting in J2SE 7.0), and, based on the value provided, jumps to a specific case within the switch block and executes code until the break command is encountered or the end of the block. If the switch value does not match any of the case values, execution will jump to the optional default case.The structure of a switch statement is as follows:Here is an example to illustrate:If a case does not end with the break statement, then the next case will be checked, otherwise the execution will jump to the end of the switch statement.Look at this example to see how its done:Starting in J2SE 5.0, the switch statement can also be used with an enum value instead of an integer.Though enums have not been covered yet, here is an example so you can see how its done (note that the enum constants in the cases do not need to be qualified with the type:Starting in J2SE 7.0, the switch statement can also be used with an String value instead of an integer.', ''),
(52, 'Contributors', 'Here is a list of at least some of the contributors to the Java Programming Wikibook.Though, there have been a lot of edits to the Wikibook using anonymous IP addresses, we thank the ones that positively added content and posted feedback for the book.', ''),
(53, 'Conventions - Code conventions', 'The book follows the official Java code conventions. Here is an example:', ''),
(54, 'Conventions - Hidden section', 'If a section is optional, it can be hidden like this:', ''),
(55, 'Conventions - Illustrations and diagrams', 'This book uses various illustrations and diagrams to convey its message, e.g., flow-chart or UML diagrams, etc. Due to the nature of diagrams, they need to be designed in a scalable vector format. It is highly recommended that you use the SVG format for your diagrams. Please, do not use JPG or PNG for diagrams that could otherwise be done in SVG. Ask a regular contributor for his/her help in this matter.A regular feature for diagrams used in this book is the overall color scheme. The most notable color used for illustrations in this book is #2a7fff (as is shown for the diagrams below, for instance). In order to include illustrations into your content, you need to use the {{Java/Illustration}} template. Given below is an example of how this template ought to be used.', ''),
(56, 'Conventions - Notes', 'Notes grant readers additional information about a certain topic. You can enter additional or side notes by using the following template:Use notes only when it is necessary. A note is less readable than paragraphs.', ''),
(57, 'Conventions - Page formatting', 'Most of the time a page from the Java Programming Wikibook has a structure that looks like this:', ''),
(58, 'Conventions - Preferred English', 'This book uses United States English, purely for the sake of consistency. Most programming languages have words represented in the United States English, e.g., color, etc. You should use the US English wherever possible.', ''),
(59, 'Conventions - Samples', 'Sometimes we wish to convey an entire java file, this can be done as follows:"1.1" means that it is the first code of the first chapter. Using <source/> is better than using a template as || is a part of the Java syntax.When just a small section of code is shown, the code template may be used as follows:To represent what is shown on the screen, use the following syntax:', ''),
(60, 'Conventions - To-do items', 'If there are sections of the book that require attention at a later time, you can add a to-do note by including the following template:', ''),
(61, 'Conventions - Warning', 'To warn the user of things like common pitfalls, the XWarning template should be used as demonstrated:', ''),
(62, 'Conventions', 'These conventions are aimed to increase the readability and the comprehension of the Java Programming Wikibook. It completes the Wikibooks Manual of Style. However exceptions can be made if needed. If you find it too complex to follow, add the content rawly. It will be formatted by someone.', ''),
(63, 'Custom Annotations - Annotation Element Declarations', 'What look like methods in the body of the annotation definition are called annotation element declarations. These are the named entities that we used with the annotation body in the example in the previous section. However, for the sake of clarity, code below also represents the calling of the following annotation:', ''),
(64, 'Custom Annotations - Annotation Type Declaration', 'Before you can use an annotation with classes, theirs members and statements or expressions, you need to define an annotation type. Following is the syntax on how to define a type for the mentioned annotation.Thats it! Our first ever annotation has been defined. Now, we can use it with any of our classes. An annotation definition if you look closely resembles the definition of a normal interface, except that the interface keyword is preceded by the @ character. Some refer to this syntactical declaration as the annotation type declaration due to the fact that @ is AT or Annotation Type for that very instance.', ''),
(65, 'Custom Annotations - Using a default value', 'Now, for instance, you want the annotation to know that if no value for the version element is present, then it should use a default value. Declaring a default value would be done the following way.So, now if you use the same code again, you can ignore the version element because you know that the value is to be provided by default.', ''),
(66, 'Custom Annotations', 'Annotations can be viewed as a source of defining meta-data for a piece of code in Java. The annotation @CodeDescription used in the following sections does not come as a part of the Java API.', ''),
(67, 'Defining Classes - Constructors', 'A constructor is called to initialize an object immediately after the object has been allocated:Typically, a constructor is invoked using the new keyword:The constructor syntax is close to the method syntax. However, the constructor has the same name as the name of the class (with the same case) and the constructor has no return type. The second point is the most important difference as a method can also have the same name as the class, which is not recommended:The returned object is always a valid, meaningful object, as opposed to relying on a separate initialization method. A constructor cannot be abstract, final, native, static, strictfp nor synchronized. However, a constructor, like methods, can be overloaded and take parameters.By convention, a constructor that accepts an object of its own type as a parameter and copies the data members is called a copy constructor. One interesting feature of constructors is that if and only if you do not specify a constructor in your class, the compiler will create one for you. This default constructor, if written out would look like:The super() command calls the constructor of the superclass. If there is no explicit call to super(...) or this(...), then the default superclass constructor super(); is called before the body of the constructor is executed. That said, there are instances where you need to add in the call manually. For example, if you write even one constructor, no matter what parameters it takes, the compiler will not add a default constructor. The code listing 4.8 results in a runtime error:This is something to keep in mind when extending existing classes. Either make a default constructor, or make sure every class that inherits your class uses the correct constructor.', ''),
(68, 'Defining Classes - Fundamentals', 'Every class in Java can be composed of the following elements:The following Java code would produce this output:', ''),
(69, 'Defining Classes - Initializers', 'Initializers are blocks of code that are executed at the same time as initializers for fields.Static initializers are blocks of code that are executed at the same time as initializers for static fields. Static field initializers and static initializers are executed in the order declared. The static initialization is executed after the class is loaded.Instance initializers are blocks of code that are executed at the same time as initializers for instance (non-static) fields. Instance field initializers and instance initializers are executed in the order declared. Both instance initializers and instance field initializers are executed during the invocation of a constructor. The initializers are executed immediately after the superclass constructor and before the body of the constructor.', ''),
(70, 'Drawing shapes - A new form of a rectangle', 'Simple so far, isnt it? Of all the shapes out there, these two are the only shapes that youd need to build for the moment. Complex graphics routines are required to build shapes like a rhombus, triangle, trapezium or a parallelogram. We would be tackling them later on in another section. However, on a last note I would leave you with another interesting shape - a combination of both ovals and rectangle. Think a rectangle with rounded corners, a Rounded Rectangle (RoundRect).Notice that the syntax of the drawRoundRect(int, int, int, int, int, int) method is a bit different than the syntax for the simple rectangle drawing routine drawRect(int, int, int, int). The two new arguments added at the end are the width of the arc in pixels and the height of the arc in pixels. The result is pretty amazing when you run the program. You dont need to squint your eyes to tell that the corners of the rectangle are slightly rounded. The more the values of the width and height of the arcs, the more roundness appears to form around the corner.', ''),
(71, 'Drawing shapes - Drawing a simple rectangle', 'We now proceed on to our second drawing. A simple rectangle would do it justice, see below for code.In the above example, you see how easy it is to draw a simple rectangle using the drawRect(int, int, int, int) method in the Graphics instance that we obtained. Run the program and you will see a simple black outline of a rectangle appearing where once a blank canvas was.The four arguments that are being passed into the method are, in order of appearance, the x-coordinate, the y-coordinate, width and the height. Hence, the resultant rectangle would start painting at the point on the screen 10 pixels from the left and 10 from the top and would be a 100 pixel wide and a 100 pixel in height. To save the argument here, the above drawing is that of a square with equal sides but squares are drawn using the same method and there is no such method as drawSquare(int, int, int)You can change the color of the outline by telling the Graphics instance the color you desire. This can be done as follows:Running the program would render the same rectangle but with a red colored outline.For the purposes of bringing color to our drawing, we used a method namely the setColor(Color) method. This method comes into force for all the drawing made after its call until another color is set. It asks for an argument of type Color. Now because you have no idea of how to actually instantiate a Color class, the class itself has a few built-in colors. Some built-in colors that you can use are mentioned below.Try running the program while coding changes to colors for a different colored outline each time. Play around a bit with more colors. Look for the Color class API documentation in the external links at the bottom of the page.Up until now, you have been able to draw a simple rectangle for yourself while asking a question silently, "why is the outline of the rectangle being painted rather the area as a whole?" The answer is simple. Any method that starts with drawXxxx(...) only draws the outline. To paint the area within the outline, we use the fillXxxx(...) methods. For instance, the code below would fill a rectangle with yellow color while having a red outline. Notice that the arguments remain the same.', ''),
(72, 'Drawing shapes - Etching a line on the canvas', 'To start off your drawing experience, consider drawing the most basic shape a line. A canvas when viewed upon with regards to drawing routines can be expressed as an inverted Cartesian coordinate system. A plane expressed by an x- and a y-axis. The origin point or being the top-left corner of a canvas and the visible area of the canvas being the Cartesian quadrant I or the positive-positive (+,+) quadrant. The further you go down from the top, the greater the value of y-coordinate on the y-axis, vice-versa for the x-axis as you move toward the right from the left. And unlike the values on a normal graph, the values appear to be positive. So a point at would be 10 pixels away from the left and 20 pixels away from the top, hence the format .Now, we already know that a line is a connection of two discreet points atop a canvas. So, if one point is at and the other is at , drawing a line would require you to write a syntax like code below. For the sake of brevity, we will skim out the rest of the method unused in the example.In the above example, a simple method is used to define precisely where to place the line on the Cartesian scale of the canvas. The drawLine(int,int,int,int) asks you to put four arguments, appearing in order, the x1 coordinate, the y1 coordinate, the x2 coordinate and the y2 coordinate. Running the program will show a simple black line diagonally going across the canvas.', ''),
(73, 'Drawing shapes - Introduction to Graphics', 'Throughout this chapter, we will refer to the process of creating Graphical content with code as either drawing or painting. However, Java officially recognizes the latter as the proper word for the process, but we will differentiate between the two later on.Now, the main class that you would be needing would, without doubt, be the Graphics class. If you take a closer look at the method that we used in theIdentifying the acquisition of the Graphics class in our codeTo view the contents of the Graphics class, please check the external links at the bottom of the page for links to the online API.', ''),
(74, 'EJB - Problems with EJB as a component based development', 'EJBs are an attempt to create component based application development. With EJBs it is easier to develop components, but the same basic and fundamental maintenance problem will still be there. That is the dependencies between the client and the components. The usage of a component is fixed, changes on the component interface cause to break the client code. The same client/server problem comes back, that is as the users of a component increases the maintenance of that component getting harder and harder until it goes to impossible.For a true component based application development we need to standardize the usage of a component. The client must somehow flexibly figure out automatically how to use a component, so component changes dont affect any of the clients using that component. Without that flexibility, a true component based application development will remain as an idea, a dream, a theory without significant practical use. If we had that flexibility, it could cause a paradigm shift in the software development industry.JINI was an attempt from Sun to address this flexibility problem. In JINI, the client download the component interface implementation and execute it in the client space.So we need to mix (somehow) EJB and JINI technologies to come up with a true flexible component based technology.', ''),
(75, 'EJB', 'Enterprise JavaBeans (EJB) technology is the server-side component architecture for Java Platform, Enterprise Edition (Java EE). EJB technology enables to create distributed, transactional, secure and portable application component objects.EJB supports the development and deployment of component based business applications. Applications written using the Enterprise JavaBeans architecture are scalable, transactional, and multi-user secure. These applications may be written once, and then deployed on any server platform that supports the Enterprise JavaBeans specification.', ''),
(76, 'Event Handling - A simple example', 'In the previous section weve explored the depths (such as there are) of the Java platform Event Model framework. If youre like most people, youve found the theoretical text more confusing than the actual use of the model. Certainly more confusing than should be necessary to explain what is, really, quite a simple framework.In order to clear everything up a bit, lets examine a simple example based on the Event Model framework. Lets assume that we want to write a program that reads a stream of numbers input by the user at the command line and processes this stream somehow. Say, by keeping track of the running sum of numbers and producing that sum once the stream has been completely read.Of course we could implement this program quite simply with a loop in a main() method. But instead lets be a little more creative. Lets say that we want to divide our program neatly into classes, each with a responsibility of its own (like we should in a proper, object-oriented design). And lets imagine that we want it to be possible not only to calculate the sum of all the numbers read, but to perform any number of calculations on the same number stream. In fact, it should be possible to add new calculations with relative ease and without having to affect any previously existing code.If we analyze these requirements, we come to the conclusion that we have a number of different responsibilities in the program:Using the Event Model framework allows us to separate the two main responsibilities cleanly and affords us the flexibility we are looking for. If we implement the logic for reading the number stream in a single class and treat the reading of a single number as an event, the Event Model allows us to broadcast that event (and the number) to as many stream processors as we like. The class for reading the number stream will act as the event source of the program and each stream processor will be a listener. Since each listener is a class of its own and can be registered with the stream reader (or not) this means our model allows us to have multiple, independent stream processing that we can add on to without affecting the code to read the stream or any pre-existing stream processor.The Event Model says that any state associated with an event should be included in a class that represents the event. Thats perfect for us; we can implement a simple event class that will record the number read from the command line. Each listener can then process this number as it sees fit.For our interesting event set lets keep things simple: lets limit ourselves to having read a new number and having reached the end of the stream. With this choice we come to the following design for our example application:In the following sections we look at the implementation of this example.Lets start with the basics. According to the Event Model rules, we must define an event class to encapsulate our interesting event. We should call this class something-somethingEvent. Lets go for NumberReadEvent, since thats what will interest us. According to the Model rules, this class should encapsulate any state that belongs with an event occurrence. In our case, thats the number read from the stream. And our event class must inherit from java.util.EventObject. So all in all, the following class is all we need:Next, we must define a listener interface. This interface must define methods for interesting events and must extend java.util.EventListener. We said earlier our interesting events were "number read" and "end of stream reached", so here we go:Actually the numberStreamTerminated method is a little weird, since it isnt actually a "number read" event. In a real program youd probably want to do this differently. But lets keep things simple in this example.So, with our listener interface defined, we need one or more implementations (actual listener classes). At the very least we need one that will keep a running sum of the numbers read. We can add as many as we like, of course. But lets stick with just one for now. Obviously, this class must implement our Number', ''),
(77, 'Event Handling - A simple example', 'ReadListener interface. Keeping a running summation is a matter of adding numbers to a field as the events arrive. And we wanted to report on the sum when the end of the stream is reached; since we know when that happens (i.e. the numberStreamTerminated method is called), a simple println statement will do:So, is this code any good? No. Its yucky and terrible and most of all not thread safe. But it will do for our example.This is where things get interesting: the event source class. This is the interesting place because this is where we must put code to read the number stream, code to send events to all the listeners and code to manage listeners (add and remove them and keep track of them).Lets start by thinking about keeping track of listeners. Normally this is a tricky business, since you have to take all sorts of multithreading concerns into account. But were being simple in this example, so lets just stick with a simple java.util.Set of listeners. Which we can initialize in the constructor:That choice makes it really easy to implement adding and removing of listeners:We wont actually use the remove method in this example but recall that the Model says it must be present.Another advantage of this simple choice is that notification of all the listeners is easy as well. We can just assume any listeners will be in the set and iterate over them. And since the notification methods are synchronous (rule of the model) we can just call them directly:Note that weve made some assumptions here. For starters, weve assumed that well get the Double value d from somewhere. Also, weve assumed that no listener will ever care about the number value in the end-of-stream notification and have passed in the fixed value 0 for that event.Finally we must deal with reading the number stream. Well use the Console class for that and just keep on reading numbers until there are no more:Note how weve hooked the number-reading loop into the event handling mechanism by calling the notify methods? The entire class looks like this:Finally, we need one more class: the kickoff point for the application. This class will contain a main() method, plus code to create a NumberReader, a listener and to combine the two:If you compile and run the program, the result looks somewhat like this:Next, lets take a look at applying an adaptor to our design. Adaptors are used to add functionality to the event handling process that:According to the Event Model specification a typical use case for an adaptor is to add routing logic for events. But you can also add filtering or logging. In our case, lets do that: add logging of the numbers as "proof" for the calculations done in the listeners.An adaptor, as explained earlier, is a class that sits between the event source and the listeners. From the point of view of the event source, it masquerades as a listener (so it must implement the listener interface). From the point of view of the listeners it pretends to be the event source (so it should have add and remove methods). In other words, to write an adaptor you have to repeat some code from the event source (to manage listeners) and you have to re-implement the event notification methods to do some extra stuff and then pass the event on to the actual listeners.In our case we need an adaptor that writes the numbers to a log file. Keeping it simple once again, lets settle for an adaptor that:Also, we can make life easy on ourselves by just copying all the code we need to manage listeners over from the NumberReader class. Again, in a real program youd want to do this differently. Note that each notification method implementation also passes the event on to all the real listeners:Of course, to make the adaptor work we have to make some changes to the bootstrap code:But note how nicely and easily we can re-link the objects in our system. The fact that adaptors and listeners both implement the listener interface and the adaptor and event source both look like event sources means that we can hook the adaptor into the system without having to change a single s', ''),
(78, 'Event Handling - A simple example', 'tatement in the classes that we developed earlier.And of course, if we run the same example as given above, the numbers are now recorded in a log file.', ''),
(79, 'Event Handling - Event-driven programming', 'No matter what the programming language or paradigm you are using, chances are that you will eventually run into a situation where your program will have to wait for an external event to happen. Perhaps your program must wait for some user input, or perhaps it must wait for data to be delivered over the network. Or perhaps something else. In any case, the program must wait for something to happen that is beyond the programs control: the program cannot make that event happen.In this situation there are two general options for making a program wait for an external event to happen. The first of these is called polling and means you write a little loop of the for "while the event has not happened, check again". Polling is very simple to build and very straightforward. But it is also very wasteful: it means a program takes up processor time in order to do absolutely nothing but wait. This is usually considered too much of a drawback for programs that have to do a lot of waiting. Programs that have a lot of waiting moments (for example, programs that have a graphical user interface and often have to wait for long periods of time until the user does something) usually fare much better when they use the other mechanism: event-driven programming.In event-driven programming a program that must wait, simply goes to sleep. It no longer takes up processor time, might even be unloaded from memory and generally leaves the computer available to do useful things. But the program doesnt completely go away; instead, it makes a deal with the computer or the operating system. A deal sort of like this:Event-driven programming usually has a pretty large impact on the design of a program. Usually, a program has to be broken up into separate pieces to do event-driven programming (one piece for general processing and one or more others to deal with events that occur). Event-driven programming in Java is more complicated than non-event driven but it makes far more efficient use of the hardware and sometimes (like when developing a graphical user interface) dividing your code up into event-driven blocks actually fits very naturally with your programs structure.In this module we examine the basis of the Java Platforms facilities for event-driven programming and we look at some typical examples of how that basis has been used throughout the platform.', ''),
(80, 'Event Handling - Platform uses of the Event Model', 'The Event Model, as mentioned earlier, doesnt have a single all-encompassing implementation within the Java platform. Instead, the model serves as a basis for several different purpose-specific implementations, both within the standard Java platform and outside it (in frameworks).Within the platform the main implementations are found in two areas:', ''),
(81, 'Event Handling - The Java Platform Event Model', 'One of the most interesting things about support for event-driven programming on the Java platform is that there is none, as such. Or, depending on your point of view, there are many different individual pieces of the platform that offer their own support for event-driven programming.The reason that the Java platform doesnt offer one general implementation of event-driven programming is linked to the origins of the support that the platform does offer. Back in 1996 the Java programming language was just getting started in the world and was still trying to gain a foothold and conquer a place for itself in software development. Part of this early development concentrated on software development tooling like IDEs. One of the trends in software development around that time was for reusable software components geared towards user interfaces: components that would encapsulate some sort of interesting, reusable functionality into a single package that could be handled as a single entity rather than as a loose collection of individual classes. Sun Microsystems tried to get on the component bandwagon by introducing what they called a JavaBean, a software component not only geared towards the UI but that could also be configured easily from an IDE. In order to make this happen Sun came up with a large specification of JavaBeans (the JavaBeans Spec) dealing mostly with naming conventions (to make the components easy to handle from an IDE). But Sun also realized at the same time that a UI-centric component would need support for an event-driven way of connecting events in the component to business logic that would have to be written by the individual developer. So the JavaBeans Spec also included a small specification for an event Model for the Java platform.When they started working on this Event Model, the Sun engineers were faced with a choice: try to come up with a huge specification to encompass all possible uses of an event model, or just specify an abstract, generic framework that could be expanded for individual use in specific situations. They chose the latter option and so, love it or hate it, the Java Platform has no generic support for event-driven programming other than this general Event Model framework.The Event Model framework is really very simple in and of itself, consisting of three classes (one abstract) and an interface. Most of all it consists of naming conventions that the programmer must obey. The framework is depicted in the image on the right.Speaking in terms of classes and interfaces, the most important parts of the framework are the java.util.EventObject abstract class and the java.util.EventListener interface. These two types are the centerpieces of the rules and conventions of the Java Platform Event Model, which are:That seems like a lot, but its pretty simple once you get used to it. Take a look at the image on the left, which contains a general example of how you might use the framework. In this example we have a class called EventSourceClass that publishes interesting events. Following the rules of the Event Model, the events are represented by the InterestingEvent class which has a reference back to the EventSourceClass object (source, inherited from java.util.EventObject).Whenever an interesting event occurs, the EventSourceClass must notify all of the listeners for that event that it knows about by calling the notification method that exist for that purpose. All of the notification methods (in this example there is only one, interestingEventOccurred) have been grouped together by topic in a listener interface: InterestingEventListener, which implements java.util.EventListener and is named according to the Event Model conventions. This interface must be implemented by all event listener classes (in this case only InterestingEventListenerImpl). Because EventSourceClass must be able to notify any interested listeners, it must be possible to register them. For this purpose the EventSourceClass has an addInterestingEventListener method. And since it is required, there is a removeInterestingEventLi', ''),
(82, 'Event Handling - The Java Platform Event Model', 'stener method as well.As you can clearly see from the example, using the Event Model is mostly about following naming conventions. This might seem a little cumbersome at first, but the point of having naming conventions is to allow automated tooling to access and use the event model. And there are indeed many tools, IDEs and frameworks that are based on these naming conventions.Theres one more thing to notice about the Event Model and that is what is not in the Model. The Event Model is designed to allow implementations a large degree of freedom in the implementation choices made, which means that the Event Model can serve as the basis for a very wide range of specific, purpose-built event handling systems.Aside from naming conventions and some base classes and interfaces, the Event Model specifies the following:But the Event Model doesnt specify how any of this must be done. There are no rules regarding which classes exactly must be event sources, nor about how they must keep track of registered event listeners. So one class might publish its own events, or be responsible for publishing the events that relate to an entire collection of objects (like an entire component). And an event source might allow listeners to be deregistered at any time (even in the middle of handling an event) or might limit this to certain times (which is relevant to multithreading).Also, the Event Model doesnt specify how it must be embedded within any program. So, while the model specifies that a call to an event handling method is a synchronous call, the Model does not prescribe that the event handling method cannot hand off tasks to another thread or that the entire event model implementation must run in the main thread of the application. In fact, the Java Platforms standard user interface framework (Swing) includes an event handling implementation that runs as a complete subsystem of a desktop application, in its own thread.In the previous section we mentioned that an event notification method usually takes a single argument. This is the preferred convention, but the specification does allow for exceptions to this rule if the application really needs that exception. A typical case for an exception is when the event notification must be sent across the network to a remote system though non-Java means, like the CORBA standard. In this case it is required to have multiple arguments and the Event Model allows for that. However, as a general rule the correct format for a notification method isAnother thing we mentioned earlier is that, as a general rule, the Event Model allows many event listeners to register with a single event source for the same event. In this case the event source must broadcast any relevant events to all the registered listeners. However, once again the Event Model specification allows for an exception to the rule. If it is necessary from a design point of view you may limit an event source to registering a single listener; this is called unicast event listener registration. When unicast registration is used, the registration method must be declared to throw the java.util.TooManyListenersException exception if too many listeners are registered:Finally, the specification allows for one more extension: the event adaptor. An event adaptor is an implementation of an event listener interface that can be inserted between an event source and an actual event listener class. This is done by registering the adaptor with the event source object using the regular registration method. Adaptors are used to add additional functionality to the event handling mechanism, such as routing of event objects, event filtering or enriching of the event object before processing by an actual event handler class.', ''),
(83, 'Event Handling', 'The Java platform Event Model is the basis for event-driven programming on the Java platform.', ''),
(84, 'Execution - J2EE code execution', 'As the focus was shifting from reaching GUI clients to thin client applications, with Java version 2, Sun introduced J2EE (Java 2 Extended Edition). J2EE added:With J2EE the following Java component executions are possible:', ''),
(85, 'Execution - Jini', 'After J2EE Sun had a vision about the next step of network computing. That is Jini. The main idea is that in a network environment, there would be many independent services and consumers. Jini would allow these services/consumers to interact dynamically with each other in a robust way. The basic features of Jini are:A minimal Jini network environment consists of:Jini is not widely used at the current writing (2006). There are two possible reasons for it. One is Jini a bit complicated to understand and to set it up. The other reason is that Microsoft pulled out from Java, which caused the industry to turn to the use of proprietary solutions.', ''),
(86, 'Execution - JSE code execution', 'Java language first edition came out in the client-server era. Thick clients were developed with rich GUI interfaces. Java first edition, JSE (Java Standard Edition) had/has the following in its belt:With JSE the following Java code executions are possible:', ''),
(87, 'Execution', 'There are various ways in which Java code can be executed. A complex Java application usually uses third party APIs or services. In this section we list the most popular ways a piece of Java code may be packed together and/or executed.', ''),
(88, 'Generics - Generic class', 'A generic class does not hard code the type of a field, a return value or a parameter. The class only indicates that a generic type should be the same, for a given object instance. The generic type is not specified in the class definition. It is specified during object instantiation. This allows the generic type to be different from an instance to another. So we should write our class this way:Here, the generic type is defined after the name of the class. Any new identifier can be chosen. Here, we have chosen T, which is the most common choice. The actual type is defined at the object instantiation:Although each object instance has its own type, each object instance is still strongly typed:A class can define as many generic types as you like. Choose a different identifier for each generic type and separate them by a comma:When a type that is defined with generic (for example, Collection<T>) is not used with generics (for example, Collection) is called a raw type.', ''),
(89, 'Generics - Generic method', 'A generic type can be defined for just a method:Here a new identifier (D) has been chosen at the beginning of the method declaration. The type is specific to a method call and different types can be used for the same object instance:The actual type will be defined by the type of the method parameter. Hence, the generic type cant be defined only for the return value as it wouldnt be resolved. See the Class<T> section for a solution.', ''),
(90, 'Generics - Motivation', 'Java was long criticized for the need to explicitly type-cast an element when it was taken out of a "container/collection" class. There was no way to enforce that a "collection" class contains only one type of object (e.g., to forbid at compile time that an Integer object is added to a Collection that should only contain Strings). This is possible since Java 1.5. In the first couple of years of Java evolution, Java did not have a real competitor. This has changed by the appearance of Microsoft C#. With Generics Java is better suited to compete against C#. Similar constructs to Java Generics exist in other languages, see Generic programming for more information. Generics were added to the Java language syntax in version 1.5. This means that code using Generics will not compile with Java 1.4 and less. Use of generics is optional. For backwards compatibility with pre-Generics code, it is okay to use generic classes without the generics type specification (<T>). In such a case, when you retrieve an object reference from a generic object, you will have to manually cast it from type Object to the correct type.', ''),
(91, 'Generics - Note for C++ programmers', 'Java Generics are similar to C++ Templates in that both were added for the same reason. The syntax of Java Generic and C++ Template are also similar. There are some differences however. The C++ template can be seen as a kind of macro, in that a new copy of the code is generated for each generic type referenced. All extra code for templates is generated at compiler time. In contrast, Java Generics are built into the language. The same code is used for each generic type. For example:Both these objects appear as the same type at runtime (both ArrayLists). The generic type information is erased during compilation (type erasure). For example:is transformed by erasure into:', ''),
(92, 'Generics - Wildcard Types', 'As we have seen above, generics give the impression that a new container type is created with each different type parameter. We have also seen that in addition to the normal type checking, the type parameter has to match as well when we assign generics variables. In some cases this is too restrictive. What if we would like to relax this additional checking? What if we would like to define a collection variable that can hold any generic collection, regardless of the parameter type it holds? The wildcard type is represented by the character <?>, and pronounced Unknown, or Any-Type. Any-Type can be expressed also by <? extends Object>. Any-Type includes Interfaces, not only Classes. So now we can define a collection whose element type matches anything. See below:You can specify a restriction on the types of classes that may be used. For example, <? extends ClassName> only allows objects of class ClassName or a subclass. For example, to create a collection that may only contain "Serializable" objects, specify:The above code is valid because the String class is serializable. Use of a class that is not serializable would cause a compilation error. The added items can be retrieved as Serializable object. You can call methods of the Serializable interface or cast it to String. The following collection can only contain objects that extend the class Animal.<? super ClassName> specifies a restriction on the types of classes that may be used. For example, to declare a Comparator that can compare Dogs, you use:Now suppose you define a comparator that can compare Animals:Since Dogs are Animals, you can use this comparator to compare Dogs also. Comparators for any superclass of Dog can also compare Dog; but comparators for any strict subclass cannot.The above code is valid because the Animal class is a supertype of the Dog class. Use of a class that is not a supertype would cause a compilation error.The advantage of the unbounded wildcard (i.e. <?>) compared to a raw type (i.e. without generic) is to explicitly say that the parameterized type is unknown, not any type. That way, all the operations that implies to know the type are forbidden to avoid unsafe operation. Consider the following code:This code will compile but this code may corrupt the collection if the collection only contains strings:This situation could have been avoided if the addAtBottom(Collection) method was defined with an unbounded wildcard: addAtBottom(Collection<?>). With this signature, it is impossible to compile a code that is dependent of the parameterized type. Only independent methods of a collection (clear(), isEmpty(), iterator(), remove(Object o), size(), ...) can be called. For instance, addAtBottom(Collection<?>) could contain the following code:', ''),
(93, 'Generics', 'Java is a strongly typed language, so a field in a class may be typed like this:This ensures that, only Integer objects can be put in the field and a ClassCastException cant occur at runtime, only compile-time error can occur. Unfortunately, it can be used only with Integer objects. If you want to use the same class in another context with Strings, you have to generalize the type like this:But you will have ClassCastException at runtime again and you cant easily use your field. The solution is to use Generics.', ''),
(94, 'History of the Java programming language - Earlier programming languages', 'Before Java emerged as a programming language, C++ was the dominant player in the trade. The primary goal of the creators of Java was to create a language that could tackle most of the things that C++ offered while getting rid of some of the more tedious tasks that came with the earlier languages.Computer hardware went through a performance and price revolution from 1972 to 1991. Better, faster hardware was available at ever lower prices and the demand for big and complex software exponentially increased. To accommodate the demand, new development technologies were invented.The C language developed in 1972 by Dennis Ritchie had taken a decade to become the most popular language amongst programmers working on PCs and similar platforms (other languages, like COBOL and FORTRAN, dominated the mainframe market). But, with time programmers found that programming in C became tedious with its structural syntax.[3] Although, people attempted to solve this problem, it would be later that a new development philosophy was introduced, one named Object-Oriented Programming. With OOP, you can write code that can be reused later without rewriting the code over and over again. In 1979, Bjarne Stroustrup developed C++, an enhancement to the C language with included OOP fundamentals and features. . Sun generated revenue from Java through the selling of licenses for specialized products such as the Java Enterprise System.', ''),
(95, 'History of the Java programming language - Reshaping thought', 'The team started thinking of replacing C++ with a better version, a faster version, a responsive version. But the one thing they hadnt thought of, as of yet, was that the language they were aiming for had to be developed for an embedded system with limited resources. An embedded system is a computer system scaled to a minimalistic interface demanding only a few functions from its design. For such a system, C++ or any successor would seem too large as all the languages at the time demanded a larger footprint than what was desired. The team thus had to think in a different way to go about solving all these problems.Co-founder of Sun Microsystems, Bill Joy, envisioned a language combining the power of Mesa and C in a paper he wrote for the engineers at Sun named Further. Gathering ideas, Gosling began work on enhancing C++ and named it "C++ ++ --", a pun on the evolutionary structure of the languages name. The ++ and -- meant, putting in and taking out stuff. He soon abandoned the name and called it Oak[1] after the tree that stood outside his office.', ''),
(96, 'History of the Java programming language - The demise of an idea, birth of another', 'By now, the work on Oak had been significant but come the year 1993, people saw the demise of set-top boxes, interactive TV and the PDAs. A failure that completely ushered the inventors thoughts to be reinvented. Only a miracle could make the project a success now. And such a miracle awaited anticipation.National Center for Supercomputing Applications (NCSA) had just unveiled its new commercial web browser for the internet the previous year. The focus of the team, now diverted towards where they thought the "next-wave" of computing would be the internet. The team then divulged into the realms of creating the same embeddable technology to be used in the web browser space calling it an applet a small application. Keeping all of this in mind, the team created a list of features tackling the C++ problems. In their opinion, the project should...The team now needed a proper identity and they decided on naming the new technology they created Java ushering a new generation of products for the internet boom. A by-product of the project was a cartoon named "Duke" created by Joe Parlang which became its identity then.Finally at the SunWorldTM conference, Andreesen unveiled the new technology to the masses. Riding along with the explosion of interest and publicity in the Internet, Java quickly received widespread recognition and expectations grew for it to become the dominant software for browser and consumer applications.[2]Initially Java was owned by Sun Microsystems, but later it was released to open source; the term Java was a trademark of Sun Microsystems. Sun released the source code for its HotSpot Virtual Machine and compiler in November 2006, and most of the source code of the class library in May 2007. Some parts were missing because they were owned by third parties, not by Sun Microsystems. The released parts were published under the terms of the GNU General Public License, a free software license.', '');
INSERT INTO `textbook` (`textid`, `topic`, `content`, `code`) VALUES
(97, 'History of the Java programming language - The Green team', 'Behind closed doors, a project was initiated in December of 1990, whose aim was to create a programming tool that could render obsolete the C and C++ programming languages. Engineer Patrick Naughton had become extremely frustrated with the state of Suns C++ and C APIs (Application Programming Interfaces) and tools. While he was considering to move towards NeXT, he was offered a chance to work on new technology and the Stealth Project was started, a secret nobody but he knew.This Stealth Project was later named the Green Project when James Gosling and Mike Sheridan joined Patrick.[1] Over the period of time that the Green Project teethed, the prospects of the project started becoming clearer to the engineers working on it. No longer was its aim to create a new language far superior to the present ones, but it aimed to target the language to devices other than the computer.Staffed at 13 people, they began work in a small office on Sand Hill Road in Menlo Park, California. This team would be called Green Team henceforth in time. The project they underwent was chartered by Sun Microsystems to anticipate and plan for the "next-wave" in computing. For the team, this meant at least one significant trend, that of the convergence of digitally controlled consumer devices and computers.[1]', ''),
(98, 'History of the Java programming language - Versions', 'Unlike C and C++, Javas growth is pretty recent. Here, wed quickly go through the development paths that Java took with age.Introduced in 1996 for the Solaris, Windows, Mac OS Classic and Linux, Java was initially released as the Java Development Kit 1.0 (JDK 1.0). This included the Java runtime (the virtual machine and the class libraries), and the development tools (e.g., the Java compiler). Later, Sun also provided a runtime-only package, called the Java Runtime Environment (JRE). The first name stuck, however, so usually people refer to a particular version of Java by its JDK version (e.g., JDK 1.0).Introduced in 1998 as a quick fix to the former versions, version 1.2 was the start of a new beginning for Java. The JDKs of version 1.2 and later versions are often called Java 2 as well. For example, the official name of JDK 1.4 is The Java(TM) 2 Platform, Standard Edition version 1.4.Released in 8 May 2000. The most notable changes were:Released in 6 February 2002, Java 1.4 has improved programmer productivity by expanding language features and available APIs:Released in September 2004Released on 11 December 2006.[4]Whats New in Java SE 6:Released on 28 July 2011.Feature additions for Java 7 include:[5]Lambda (Javas implementation of lambda functions), Jigsaw (Javas implementation of modules), and part of Coin were dropped from Java 7. Java 8 will be released with the remaining features in summer 2013.[18]', ''),
(99, 'Inheritance - The Object class', 'At the instantiating, the child class receives the features inherited from its superclass, which also has received the features inherited from its own superclass and so on to the Object class. This mechanism allows to define reusable global classes, whose user details the behavior in the derived more specific classes.In Java, a class can only inherit from one class. Java does not allow you to create a subclass from two classes, as that would require creating complicated rules to disambiguate fields and methods inherited from multiple superclasses. If there is a need for Java to inherit from multiple sources, the best option is through interfaces, described in the next chapter.', ''),
(100, 'Inheritance - The super keyword', 'The super keyword allows access to the members of the superclass of a class, as you can use this to access the members of the current class. Example:In this example, the constructor of the Plane class calls the constructor of its superclass Vehicle. You can only use super to access the members of the superclass inside the child class. If you use it from another class, it accesses the superclass of the other class. This keyword also allows you to explicitly access the members of the superclass, for instance, in the case where there is a method with the same name in your class (overriding, ...). Example:', ''),
(101, 'Inheritance', 'The inheritance is one of the most powerful mechanism of the Object Oriented Programming. It allows the reuse of the members of a class (called the superclass or the mother class) in another class (called subclass, child class or the derived class) that inherits from it. This way, classes can be built by successive inheritance.In Java, this mechanism is enabled by the extends keyword. Example:In the Code listing 4.10, the class Car inherits from Vehicle, which means that the attributes speed and numberOfSeats are present in the class Car, whereas they are defined in the class Vehicle. Also, the constructor defined in the class Car allows to initialize those attributes. In Java, the inheritance mechanism allows to define a class hierarchy with all the classes. Without explicit inheritance, a class implicitly inherits from the Object class. This Object class is the root of the class hierarchy.Some classes cant be inherited. Those classes are defined with the final keyword. For instance, the Integer class cant have subclasses. It is called a final class.', ''),
(102, 'Installation', 'In order to make use of the content in this book, you would need to follow along each and every tutorial rather than simply reading through the book. But to do so, you would need access to a computer with the Java platform installed on it the Java platform is the basic prerequisite for running and developing Java code, thus it is divided into two essential pieces of software:However as a developer, you would only require the JDK which comes equipped with a JRE as well. Given below are installation instruction for the JDK for various operating systems:', ''),
(103, 'Interfaces - Extending interfaces', 'An interface can extend several interfaces, similar to the way that a class can extend another class, using the extends keyword:This way, a class implementing the InterfaceAB interface has to implement the methodA(), the methodB() and the otherMethod() methods:Doing so, a ClassAB object can be casted into InterfaceA, InterfaceB and InterfaceAB.', ''),
(104, 'Interfaces - Interest', 'If you have objects from different classes that do not have common superclasses, you cant call a same method on them, even if the two classes implement a method with the same signature.The solution is to write an interface that defines the method that should be implemented in the two classes as the SimpleInterface in the Code listing 4.14 and then the both class implement the interface as in the Code listing 4.15.You can also have this interest using a common super class but a class can only inherit from one super class whereas it can implement several interfaces. Java does not support full orthogonal multiple inheritance. Java does not allow you to create a subclass from two classes. Multiple inheritance in C++ has complicated rules to disambiguate fields and methods inherited from multiple superclasses and types inherited multiple times. By separating interface from implementation, interfaces offer much of the benefit of multiple inheritance with less complexity and ambiguity. The price of no multiple inheritance is some code redundancy; since interfaces only define the signature of a class but cannot contain any implementation, every class inheriting an interface must provide the implementation of the defined methods, unlike in pure multiple inheritance, where the implementation is also inherited. The major benefit of that is that all Java objects can have a common ancestor. That class is called Object. When overriding methods defined in interfaces there are several rules to be followed:', ''),
(105, 'Interfaces', 'An interface is an abstraction of class with no implementation details. For example, java.lang.Comparable is a standard interface in Java. You cannot instantiate an interface. An interface is not a class but it is written the same way. The first difference is that you do not use the class keyword but the interface keyword to define it. Then, there are fields and methods you cannot define here:An interface represents a contract:You can see that the method1() method is abstract (unimplemented). To use an interface, you have to define a class that implements it, using the implements keyword:A class can implement several interface, separated by a comma. Java interfaces behave much like the concept of the Objective-C protocol. It is recommended to name an interface <verb>able, to mean the type of action this interface would enable on a class. However, it is not recommended to start the name of an interface by I as in C++. It is useless. Your IDE will help you instead.', ''),
(106, 'Java IDEs - BlueJ', 'BlueJ is an IDE that includes templates and will compile and run the applications for you. BlueJ is often used by classes because it is not necessary to set classpaths. BlueJ has its own sets of libraries and you can add your own under preferences. That sets the classpath for all compilations that come out of it to include those you have added and the BlueJ libraries.BlueJ offers an interesting GUI for creation of packages and programs. Classes are represented as boxes with arrows running between them to represent inheritance/implementation or if on is constructed in another. The source code is generated by the UML diagram or vice-versa. BlueJ adds all those classes (the project) into the classpath at compile time.By default it doesnt display the line numbers, so this should be ticked into OptionsPreferences...', ''),
(107, 'Java IDEs - DrJava', 'DrJava is an IDE developed by the JavaPLT group at Rice University. It is designed for students.', ''),
(108, 'Java IDEs - Eclipse', 'Eclipse is a Free and Open Source IDE, plus a developer tool framework that can be extended for a particular development need. IBM was behind its development, and it replaced IBM VisualAge tool. The idea was to create a standard look and feel that can be extended via plugins. The extensibility distinguishes Eclipse from other IDEs. Eclipse was also meant to compete with Microsoft Visual Studio tools. Microsoft tools give a standard way of developing code in the Microsoft world. Eclipse gives a similar standard way of developing code in the Java world, with a big success so far. With the online error checking only, coding can be sped up by at least 50% (coding does not include programming).The goals for Eclipse are twofold:IBMs WSAD, and later IBM Rational Software Development Platform, are built on Eclipse.Standard Eclipse features:', ''),
(109, 'Java IDEs - JBuilder', 'JBuilder is an IDE with proprietary source code, sold by Embarcadero Technologies. One of the advantages is the integration with Together, a modeling tool.', ''),
(110, 'Java IDEs - JCreator', 'JCreator is a simple and lightweight JAVA IDE from XINOX Software. It runs only on Windows platforms. It is very easy to install and starts quickly, as it is a native application. This is a good choice for beginners.', ''),
(111, 'Java IDEs - Kawa', 'Kawa is basically a Java editor developed by Tek-Tools. It does not include wizards and GUI tools, best suited to experienced Java programmers in small and midsized development teams. It looks that there is no new development for Kawa.See also a javaworld article', ''),
(112, 'Java IDEs - NetBeans', 'The NetBeans IDE is a Free and Open Source IDE for software developers. The IDE runs on many platforms including Windows, GNU/Linux, Solaris and Mac OS X. It is easy to install and use straight out of the box. You can easily create Java applications for mobile devices using Mobility Pack in NetBeans. With Netbeans 6.0, the IDE has become one of the most preferred development tools, whether it be designing a Swing UI, building a mobile application, an enterprise application or using it as a platform for creating your own IDE.', ''),
(113, 'Java IDEs - Processing', 'Processing is an enhanced IDE. It adds some extra commands and a simplified programming model. This makes it much easier for beginners to start programming in Java. It was designed to help graphic artists learn a bit of programming without struggling too much. Processing runs on Windows, GNU/Linux and Mac OS X platforms.', ''),
(114, 'JavaBeans - A Simple JavaBean', 'This is an example of a simple JavaBean type with the properties int age and String color.', ''),
(115, 'JavaBeans - Additional Remarks', 'A big strength of the JavaBean component model is that it is designed for simplicity. Developing JavaBeans is very simple, because a lot of behavior (like the platform independence or packaging mechanism) is supported in the Java Programming Language by default. However, one can optionally equip beans with additional objects like BeanInfos or custom PropertyEditors to use the component model in a more flexible way. A second facility is that Sun designed the whole Swing GUI library according to the JavaBeans component model. Thereby Swing components can easily be composed in visual builder tools.However, JavaBeans do not realize all features of a component model. A drawback is that JavaBeans are restricted to the Java programming language, while an important goal of components is the independence of an implementation language.', ''),
(116, 'JavaBeans - Customization', 'Customization is done via Property Editors. A property editor is a tool for customizing at design time a particular property type. Property editors are activated from so-called property sheets, which display all properties of a bean. If a property is selected for customization, the property sheet finds out the type of the property, displays the appropriate property editor with the propertys current value.', ''),
(117, 'JavaBeans - Events', 'JavaBeans interact with each other by means of events. Events are notifications, a component can give to other components, that something interesting has happened. An example for an event might be a mouse click on a button or the closing of a window. Beans can be source and target of events. To be informed about an event, a bean has to register at another Bean as a listener.The Java event model realizes the observer design pattern with the effect that the inter-component coupling is reduced. Method calls require tight coupling, as caller and receiver need to know each other at compile time, while with events all communication happens solely via interfaces.A special kind of event are PropertyChangeEvents. They are used to restrict some properties to take only specific values, for example for a month integer values between 1 and 12. Every time, such a bound property is modified, notifications to all registered PropertyChangeListeners will be send.', ''),
(118, 'JavaBeans - Implementation', 'To follow these standards, the bean needs one or more properties abstractions which represent different state values of an object. A property has a name (a valid Java identifier) and a type (either a reference type, a primitive type or an array type). By default, the properties of a JavaBean class are inferred by the presence of either a getter method, a setter method, or both:isDiscounted() would be the getter method for a boolean property named discounted. Thus, the method signature of most getters is public PropertyType getPropertyName() or public boolean isPropertyName().As per the JavaBeans standard, getters and setters defined as described above automatically determine the properties of the class. However, by creating java.beans.PropertyDescriptor classes, you can specify alternate implementations by explicitly declaring the property names and the getter and/or setter methods for each property.Properties are often implemented with private instance variables, but this is not required.', ''),
(119, 'JavaBeans - Introspection', 'In Java and J2EE programming, you can call a method on an object only if it is casted to a class or an interface that declares it. The structured definition of bean properties is very useful for comparing a single common property across several objects that are not and should not be related by inheritance.For example, a program may contain both a bean representing a companys employees, and another containing a list of buildings that a company occupies. A programmer writing a function called listAssetNames() wants to write a simple way of getting the field "name" from several beans that can get the field from both Employee and Building beans, and that can be easily adapted to get the same field from other types of beans that may not be written yet.While this could be done by rewriting both Employee and Building so that they each inherit from one class named NamedObject, or by creating a NamedObject interface, both methods have their own problems. Using inheritance is limiting, as each child class can only inherit from one parent class, which limits the number of different classes that can share properties, as well as the number of common properties that can be shared. Furthermore, using inheritance to express relationships other than a simple "is-a" relationship can be confusing, as can looking through dozens of class definitions to find where a single "dumb" getter function is implemented. Creating an interface fixes the problems caused by the multiple inheritance rule, as a class can use any number of interfaces, but it still requires every shared property to be explicitly spelled out.The simplest, most elegant way to deal with this type of relationship is to read the bean properties using introspection. The jakarta BeanUtils package is a common way of handling objects that need to be related in this way, as it takes advantage of the regularity of JavaBean naming conventions.or', ''),
(120, 'JavaBeans - Persistence', 'The requirements for an object to be a bean is to define a public parameterless constructor, so that beans can be instantiated by builder tools in an uncomplicated way (In the Point bean, the parameterless constructor is given implicitly). Secondly, one of the interfaces java.io.Serializable or java.io.Externalizable need to be implemented. The interfaces do not prescribe the implementation of any methods, but are an approval, that the bean may be saved in persistent storage as in a file or database. In doing so, the bean can be restored after an application was shut down or transferred across networks. The ability to store state of a component in persistent storage is called persistence. Java offers a standard serialization mechanism, which makes it very easy to serialize objects. Alternatively, a component can be stored in a customized manner (e.g. in xml format) by implementing the Externalizable interface.', ''),
(121, 'JavaBeans - Properties', 'The properties of a bean are all private fields that are accessible and modifiable by public methods. These getter and setter methods should be marked as such by following a simple naming convention: for some property named, say, xxx there should be a getXxx() which returns the property value and a setXxx() which sets the property.', ''),
(122, 'JavaBeans', 'Reusability comes at the core of any modern computer languages framework. It is often desirable to use components you previously built in recurring environments. In Rapid Application Development, these prove more helpful as you can drag them off a list of components and use it elsewhere in your project. Such level of reusability is added into the Java Programming language with the help of the JavaBeans architecture.JavaBeans are the mainstream Java component model, introduced in 1996 by Sun Microsystems. JavaBeans are defined as follows:"A JavaBean is a reusable software component that can be manipulated visually in a builder tool."Together with the component model, Sun released a simple visual composition tool, the BeanBox. It is mostly intended for experimenting with Beans rather than offering a professional IDE. For real world applications, one should better deploy on one of the Java IDEs like Visual Age or JBuilder that support the visual composition of JavaBeans.As we will see, JavaBeans do not essentially differ from standard Java classes, which makes the component model quite easy to use. What sets a JavaBean apart from normal Java classes is that a JavaBean follows the Oracle JavaBeans Standard (the term JavaBean or simply bean also refers to the instances of a JavaBean class). There is a set of features and conventions adopted for facilitating reuse:The JavaBeans standard provides a framework for creating objects to be used by GUI tools, including Java development environments. But in more common usage, a bean is a serializable class that follows the JavaBeans naming conventions for its properties. These naming standards make it easy to use Java introspection.', ''),
(123, 'Javadoc - Documentation', 'The JDK provides a tool named javadoc which allows to generate the documentation of the well commented classes. The javadoc command without argument give the complete syntax of the command.Example: for a class named Example defined in a package named org.wikibooks.en dans le fichier C:ProgJavaorgwikibooksenExample.java:The documentation can be generated in a specific folder (C:ProgDoc for example) with the following command:The options of this command are described below:The description page of a package copy the description text from the file named package.html which should be placed in the given folder. In our example, we should document the package in the file C:ProgJavaorgwikibooksenpackage.html.Since Java 5[1], the package.html file can be replaced by a special Java file named package-info.java containing only the package declaration preceding by a documentation comment.', ''),
(124, 'Javadoc - Syntax', 'A documentation comment is framed by slash-star-star and star-slash (i.e. /** ... */). The documentation is in the HTML format.A documentation comment is placed just above the commented entity (class, constructor, method, field).In a documentation comment, the first part is a description text in the HTML format. The second part is a list of special attributes whose name starts with an at sign (@):Here is a non exhaustive list of special attributes:See also annotations since Java 5.', ''),
(125, 'Javadoc', 'Java allows users to document the classes and the members by using a particular syntax of comment.', ''),
(126, 'JavaSpaces - JINI', 'JavaSpaces technology is part of the Java Jini technology. The basic features of JINI are:A minimal JINI network environment consists of:', ''),
(127, 'JavaSpaces - Leasing', 'When a service registers with the lookup service, it receives a lease from the lookup service, described in the Jini Distributed Leasing Specification.', ''),
(128, 'JavaSpaces - Lookup Discovery', 'Jini Discovery and Join Specification describes how does the client find the jini lookup service. There is a protocol to do that, jini comes with a set of APIs that implement that protocol. The Jini Discovery Utility Specification defines a set of utility classes that are used to work with the protocol.', ''),
(129, 'JavaSpaces - The JINI Lookup Service', 'The lookup service is described in the: Jini Lookup Service Specification (reggie). This service interface defines all operations that are possible on the lookup service. Clients locate services by requesting with a lookup server that implements a particular interface. Client asks the lookup server for all services that implement the particular service interface. The lookup service returns service objects for all registered services that implement the given interface. The client may invoke methods on that object in order to interact directly with the server.', ''),
(130, 'JavaSpaces', 'After J2EE, Sun had a vision about the next step of network computing: in a network environment, there would be many independent services and consumers. That is JavaSpaces. JavaSpaces would allow these services/consumers to interact dynamically with each other in a robust way. It can be viewed as an object repository that provides a distributed persistent object exchange mechanism (persistent can be in memory or disk) for Java objects. It can be used to store the system state and implement distributed algorithms. In a JavaSpace, all communication partners (peers) communicate by sharing state. It is an implementation of the Tuple spaces idea.JavaSpaces is used when someone wants to achieve scalability and availability and at the same time reducing the complexity of the overall system.Processes perform simple operations to write new objects into a JavaSpace, take objects from a JavaSpace, or read (make a copy of) objects from the JavaSpace.In conventional applications, objects are assembled from the database before presenting to the end user. In JavaSpace applications, we keep the ready made "end user" objects and store them in the JavaSpace. In JavaSpace applications the services are decoupled from each other; they communicate through objects that they write and read/take from the JavaSpace. Services search for objects that they want to take or read from the Space by using template object.', ''),
(131, 'Large numbers - BigDecimal', 'The BigInteger class cannot handle decimal numbers. The BigDecimal class represents a floating point value of arbitrary precision. It is composed of both a BigInteger, and a scale value (represented by a 32-bit integer).', ''),
(132, 'Large numbers - BigInteger', 'The BigInteger class represents integers of almost any size. As with other objects, they need to be constructed. Unlike regular numbers, the BigInteger represents an immutable object - methods in use by the BigInteger class will return a new copy of a BigInteger.To instantiate a BigInteger, you can create it from either byte array, or from a string. For example:BigInteger cannot use the normal Java operators. They use the methods provided by the class.It is possible to convert to a long, but the long may not be large enough.', ''),
(133, 'Large numbers', 'The integer primitive type with the largest range of value is the long, from -263 to 263-1. If you need greater or lesser values, you have to use the BigInteger class in the package java.math. A BigInteger object can represent any integer (as large as the RAM on the computer can hold) as it is not mapped on a primitive type. Respectively, you need to use the BigDecimal class for great decimal numbers.However, as these perform much slower than primitive types, it is recommended to use primitive types when it is possible.', ''),
(134, 'Literals - Boolean Literals', 'There are two boolean literalsThere are no other boolean literals, because there are no other boolean values!', ''),
(135, 'Literals - Mixed Mode Operations', 'In concatenation operations, the values in brackets are concatenated first. Then the values are concatenated from the left to the right. Be careful when mixing character literals and integers in String concatenation operations:The unexpected results arise because 1 and 0 are converted twice. The expression is concatenated as such:The code section 66 yields the desired result:', ''),
(136, 'Literals - null', 'null is a special Java literal which represents a null value: a value which does not refer to any object. It is an error to attempt to dereference the null value Java will throw a NullPointerException. null is often used to represent uninitialized state.', ''),
(137, 'Literals - Numeric Literals', 'There are three types of numeric literals in Java.In Java, you may enter integer numbers in several formats:By default, the integer literal primitive type is int. If you want a long, add a letter el suffix (either the character l or the character L) to the integer literal. This suffix denotes a long integer rather than a standard integer. For example, 3405691582L is a long integer literal. Long integers are 8 bytes in length as opposed to the standard 4 bytes for int. It is best practice to use the suffix L instead of l to avoid confusion with the digit 1 (one) which looks like l in many fonts: 200l 2001. If you want a short integer literal, you have to cast it.Starting in J2SE 7.0, you may insert underscores between digits in a numeric literal. They are ignored but may help readability by allowing the programmer to group digits.Floating point numbers are expressed as decimal fractions or as exponential notation:Floating point numbers consist of:Here, integer digits represents one or more of the digits 0 through 9.Starting in J2SE 7.0, you may insert underscores between digits in a numeric literal. They are ignored but may help readability by allowing the programmer to group digits.Character literals are constant valued character expressions embedded in a Java program. Java characters are sixteen bit Unicode characters, ranging from 0 to 65535. Character literals are expressed in Java as a single quote, the character, and a closing single quote (a, 7, $, ). Character literals have the type char, an unsigned integer primitive type. Character literals may be safely promoted to larger integer types such as int and long. Character literals used where a short or byte is called for must be cast to short or byte since truncation may occur.', ''),
(138, 'Literals - String Literals', 'String literals consist of the double quote character (") (ASCII 34, hex 0x22), zero or more characters (including Unicode characters), followed by a terminating double quote character ("), such as: "Ceci est une string."So a string literal follows the following grammar:Within string and character literals, the backslash character can be used to escape special characters, such as unicode escape sequences, or the following special characters:String literals may not contain unescaped newline or linefeed characters. However, the Java compiler will evaluate compile time expressions, so the following String expression results in a string with three lines of text:', ''),
(139, 'Literals', 'Java Literals are syntactic representations of boolean, character, numeric, or string data. Literals provide a means of expressing specific values in your program. For example, in the following statement, an integer variable named count is declared and assigned an integer value. The literal 0 represents, naturally enough, the value zero.The code section 3.62 contains two number literals followed by two boolean literals at line 1, one string literal followed by one number literal at line 2, and one string literal followed by one real number literal at line 3:', ''),
(140, 'Loop blocks - Break and continue keywords', 'The break keyword exits a flow control loop, such as a for loop. It basically breaks the loop.In the code section 3.34, the loop would print out all the numbers from 1 to 10, but we have a check for when i equals 5. When the loop reaches its fifth iteration, it will be cut short by the break statement, at which point it will exit the loop.The continue keyword jumps straight to the next iteration of a loop and evaluates the boolean expression controlling the loop. The code section 3.35 is an example of the continue statement in action:As the break and continue statements reduce the readability of the code, it is recommended to reduce their use or replace them with the use of if and while blocks. Some IDE refactoring operations will fail because of such statements.', ''),
(141, 'Loop blocks - Examples', 'The code listing 3.7 recieves a number as parameter and print its binary representation.The code listing 3.8 is a simulation of playing a game called Lucky Sevens. It is a dice game where the player rolls two dice. If the numbers on the dice add up to seven, he wins $4. If they do not, he loses $1. The game shows how to use control flow in a program as well as the fruitlessness of gambling.', ''),
(142, 'Loop blocks - Labels', 'Labels can be used to give a name to a loop. The reason to do this is so we can break out of or continue with upper-level loops from a nested loop.Here is how to label a loop:To break out of or continue with a loop, use the break or continue keyword followed by the name of the loop.For example:You neednt worry if you dont understand all the code, but look at how the label is used to break out of the outer loop from the inner loop. However, as such a code is hard to read and maintain, it is highly recommended not to use labels.', ''),
(143, 'Loop blocks - Try... catch blocks', 'The try-catch blocks are used to catch any exceptions or other throwable objects within the code.Heres what try-catch blocks looks like:The code listing 3.6 tries to print all the arguments that have been passed to the program. However, if there not enough arguments, it will throw an exception.In addition to the try and catch blocks, a finally block may be present. The finally block is always executed, even if an exception is thrown. It may appear with or without a catch block, but always with a try block.Here is what a finally block looks like:', ''),
(144, 'Loop blocks', 'Loops are a handy tool that enables programmers to do repetitive tasks with minimal effort. Say we want a program that can count from 1 to 10, we could write the following program.The task will be completed just fine, the numbers 1 to 10 will be printed in the output, but there are a few problems with this solution:Using loops we can solve all these problems. Once you get you head around them they will be invaluable to solving many problems in programming.Open up your editing program and create a new file saved as Loop.java. Now type or copy the following code:If we run the program, the same result is produced, but looking at the code, we immediately see the advantages of loops. Instead of executing 10 different lines of code, line 5 executes ten times. 10 lines of code have been reduced to just 4. Furthermore, we may change the number 10 to any number we like. Try it yourself, replace the 10 with your own number.while loops are the simplest form of loop. The while loop repeats a block of code while the specified condition is true. Here is the structure of a while loop:The loops condition is checked before each iteration of the loop. If the condition is false at the start of the loop, the loop will not be executed at all. The code section 3.28 sets in squareHigherThan200 the smallest integer whose square exceeds 200.The do-while loop is functionally similar to the while loop, except the condition is evaluated AFTER the statement executes It is useful when we try to find a data that does the job by randomly browsing an amount of data.The for loop is a specialized while loop whose syntax is designed for easy iteration through a sequence of numbers. It consists of the keyword for followed by three extra statements enclosed in parentheses. The first statement is the variable declaration statement, which allows you to declare one or more integer variables. The second is the condition, which is checked the same way as the while loop. Last is the iteration statement, which is used to increment or decrement variables, though any statement is allowed.This is the structure of a for loop:To clarify how a for loop is used, here is an example:The for loop is like a template version of the while loop. The alternative code using a while loop would be as follows:The code section 3.31 shows how to iterate with the for loop using multiple variables and the code section 3.32 shows how any of the parameters of a for loop can be skipped. Skip them all, and you have an infinitely repeating loop.Arrays havent been covered yet, but youll want to know how to use the enhanced for loop, called the for-each loop. The for-each loop automatically iterates through a list or array and assigns the value of each index to a variable.To understand the structure of a for-each loop, look at the following example:The example iterates through an array of words and prints them out like a sentence. What the loop does is iterate through sentence and assign the value of each index to word, then execute the code block.Here is the general contract of the for-each loop:Make sure that the type of the array or list is assignable to the declared variable, or you will get a compilation error. Notice that the loop automatically exits after the last item in the collection has been examined in the statement block.Although the enhanced for loop can make code much clearer, it cant be used in some common situations.', ''),
(145, 'Map - Thread safe maps', 'The following table lists all the synchronized map classes:', ''),
(146, 'Map', 'Aside from the java.util.Collection interface, the Java JDK has the java.util.Map interface as well. It is sometimes also called an Associated Array or a Dictionary. A map defines key value mappings. Implementations of the Map interface do not contain collections of objects. Instead they contain collections of key->value mappings. It can be thought of as an array where the index doesnt need to be an integer.Use the Map interface if you need to keep related objects together in a Map where you can:In the above example, the same operations are made with two different map implementations:We see that only the TreeMap has sorted the keys. Beware of the generics. The Map interface is tricky. The methods get() and remove() are not generic. This means that you must be careful of the type of the key:The remove() call has done nothing because "2" is a String, not an Integer so no key and value has been found and removed.The Map interface has the following implementations:', ''),
(147, 'Mathematical functions - Functions dealing with floating-point representation', 'Java 1.5 and 1.6 introduced several non-mathematical functions specific to the computer floating-point representation of numbers.Math.ulp(double) and Math.ulp(float) return an ulp, the smallest value which, when added to the argument, would be recognized as larger than the argument.Math.copySign returns the value of the first argument with the sign of the second argument. It can be used to determine the sign of a zero value.Math.getExponent returns (as an int) the exponent used to scale the floating-point argument in computer representation.', ''),
(148, 'Mathematical functions - Math constants', 'There are two constants in the Math class that are fairly accurate approximations of irrational mathematical numbers.The Math.E constant represents the value of Eulers number (e), the base of the natural logarithm.The Math.PI constant represents the value of pi, the ratio of a circles circumference to its diameter.', ''),
(149, 'Mathematical functions - Math methods', 'There are several methods in the Math class that deal with exponential functions.The power method, double Math.pow(double, double), returns the first parameter to the power of the second parameter. For example, a call to Math.pow(2, 10) will return a value of 1024 (210).The Math.exp(double) method, a special case of pow, returns e to the power of the parameter. In addition, double Math.expm1(double) returns (ex - 1). Both of these methods are more accurate and convenient in these special cases.Java also provides special cases of the pow function for square roots and cube roots of doubles, double Math.sqrt(double) and double Math.cbrt(double).Java has no general logarithm function; when needed this can be simulated using the change-of-base theorem.double Math.log(double) returns the natural logarithm of the parameter (not the common logarithm, as its name suggests!).double Math.log10(double) returns the common (base-10) logarithm of the parameter.double Math.log1p(double) returns ln(parameter+1). It is recommended for small values.The trigonometric methods of the Math class allow users to easily deal with trigonometric functions in programs. All accept only doubles. Please note that all values using these methods are initially passed and returned in radians, not degrees. However, conversions are possible.The three main trigonometric methods are Math.sin(x), Math.cos(x), and Math.tan(x), which are used to find the sine, cosine, and tangent, respectively, of any given number. So, for example, a call to Math.sin(Math.PI/2) would return a value of about 1. Although methods for finding the cosecant, secant, and cotangent are not available, these values can be found by taking the reciprocal of the sine, cosine, and tangent, respectively. For example, the cosecant of pi/2 could be found using 1/Math.sin(Math.PI/2).Java provides inverse counterparts to the trigonometric functions: Math.asin(x), and Math.acos(x), Math.atan(x).In addition, hyperbolic functions are available: Math.sinh(x), Math.cosh(x), and Math.tanh(x).To convert between degree and radian measures of angles, two methods are available, Math.toRadians(x) and Math.toDegrees(x). While using Math.toRadians(x), a degrees value must be passed in, and that value in radians (the degree value multiplied by pi/180) will be returned. The Math.toDegrees(x) method takes in a value in radians and the value in degrees (the radian value multiplied by 180/pi) is returned.The absolute value method of the Math class is compatible with the int, long, float, and double types. The data returned is the absolute value of parameter (how far away it is from zero) in the same data type. For example:In this example, result will contain a value of 3.These methods are very simple comparing functions. Instead of using if...else statements, one can use the Math.max(x1, x2) and Math.min(x1, x2) methods. The Math.max(x1, x2) simply returns the greater of the two values, while the Math.min(x1, x2) returns the lesser of the two. Acceptable types for these methods include int, long, float, and double.', ''),
(150, 'Mathematical functions - Rounding number example', 'Sometimes, we are not only interested in mathematically correct rounded numbers, but we want that a fixed number of significant digits are always displayed, regardless of the number used. Here is an example program that returns always the correct string. You are invited to modify it such that it does the same and is simpler!The constant class contains repeating constants that should exist only once in the code so that to avoid inadvertent changes. (If the one constant is changed inadvertently, it is most likely to be seen, as it is used at several locations.)The MathsUtils class is like an addition to the java.lang.Math class and contains the rounding calculations.The code is tested with the following JUnit test:The output of the JUnit test follows:If you are interested in a comparison with C#, take a look at the rounding number example there. If you are interested in a comparison with C++, you can compare this code here with the same example over there.Notice that in the expression starting with if ((D == 0), I have to use OR instead of the || because of a bug in the source template.', ''),
(151, 'Mathematical functions', 'The java.lang.Math class allows the use of many common mathematical functions that can be used while creating programs.Since it is in the java.lang package, the Math class does not need to be imported. However, in programs extensively utilizing these functions, a static import can be used.', ''),
(152, 'Meta-Annotations - Documented', 'If a member is annotated with a type itself marked as @Documented, then that member will be documented as annotating that type.In the documentation for the Example class, such as the JavaDoc, Example will be shown as annotated with @NotSecret, but not @Secret.', ''),
(153, 'Meta-Annotations - Inherited', 'Exactly as the name sounds, an @Inherited annotation type is inherited by subclasses of an annotated type.In this example, Superclass has been explicitly annotated with both @ForEveryone and @JustForMe. Subclass hasnt been explicitly marked with either one; however, it inherits @ForEveryone because the latter is annotated with @Inherited. @JustForMe isnt annotated, so it isnt inherited by Subclass.', ''),
(154, 'Meta-Annotations - Repeatable', 'A @Repeatable annotation type is repeatable - i.e. can be specified multiple times on the same class. This meta-annotation was added in Java 8.', ''),
(155, 'Meta-Annotations - Retention', 'Different annotation types have different purposes. Some are intended for use with the compiler; others are meant to be reflected dynamically at runtime. Theres no reason for a compiler annotation to be available at runtime, so the @Retention meta-annotation specifies how long an annotation type should be retained. The value attribute is one of the java.lang.annotation.RetentionPolicy enum constants. The possible values, in order from shortest to longest retention, are as follows:If no @Retention policy is specified, it defaults to RetentionPolicy.CLASS.', ''),
(156, 'Meta-Annotations - Target', 'The @Target meta-annotation determines what may be marked by the annotation. The value attribute is one or more of the java.lang.annotation.ElementType enum constants. Those constants are ElementType.ANNOTATION_TYPE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, and TYPE.', ''),
(157, 'Meta-Annotations', 'There are five annotation types in the java.lang.annotation package called meta-annotations. These annotation types are used to annotate other annotation types.', ''),
(158, 'Methods - Parameter passing', 'We can pass any primitive data types or objects to a method but the two are not processed the same way.The primitive types are passed in by value. It means that as soon as the primitive type is passed in, there is no more link between the value inside the method and the source variable:As you can see in code section 3.70, the modifyValue() method has not modified the value of i.The object references are passed by value. It means that:You must understand the difference between the reference of an object and the object itself. A object reference is the link between a variable name and an instance of object:An object reference is a pointer, an address to the object instance.The object itself is the value of its attributes inside the object instance:Take a look at the example above:The name has changed because the method has changed the object itself and not the reference. Now take a look at the other example:The name has not changed because the method has changed the reference and not the object itself. The behavior is the same as if the method was in-lined and the parameters were assigned to new variable names:', ''),
(159, 'Methods - Return parameter', 'So as we can see, a method may or may not return a value. If the method does not return a value we use the void Java keyword.Same as the parameter passing, the method can return a primitive type or an object reference. So a method can return only one value. What if you want to return more than one value from a method. You can always pass in an object reference to the method, and let the method modify the object properties. The modified values can be considered as an output value from the method. However you can also create an Object array inside the method, assign the return values and return the array to the caller. You could have a problem however, if you want to mix primitive data types and object references as the output values from the method.There is a better approach. Defines special return object with the needed return values. Create that object inside the method, assign the values and return the reference to this object. This special object is "bound" to this method and used only for returning values, so do not use a public class. The best way is to use a nested class, see example below:In the above example the getPersonInfoById method returns an object reference that contains both values of the name and the age. See below how you may use that object:', ''),
(160, 'Methods - Special method, the constructor', 'The constructor is a special method called automatically when an object is created with the new keyword. Constructor does not have a return value and its name is the same as the class name. Each class must have a constructor. If we do not define one, the compiler will create a default so called empty constructor automatically.', ''),
(161, 'Methods - Static methods', 'A static method is a method that can be called without an object instance. It can be called on the class directly. For example, the valueOf(String) method of the Integer class is a static method:As a consequence, it cannot use the non-static methods of the class but it can use the static ones. The same way, it cannot use the non-static attributes of the class but it can use the static ones:You can notice that when you use System.out.println(), out is a static attribute of the System class. A static attribute is related to a class, not to any object instance, so there is only one value for all the object instances. This attribute is unique in the whole Java Virtual Machine. All the object instances use the same attribute:', ''),
(162, 'Methods - Variable argument list', 'Java SE 5.0 added syntactic support for methods with variable argument list, which simplifies the typesafe usage of methods requiring a variable number of arguments. Less formally, these parameters are called varargs[1]. The last parameter can be followed with ..., and Java will box all the arguments into an array. Vararg parameter must always be the last method parameter:When calling the method, a programmer can simply separate the points by commas, without having to explicitly create an array of Point objects. Within the method, the points can be referenced as points[0], points[1], etc. If no points are passed, the array has a length of zero. To require the programmer to use a minimum number of parameters, those parameters can be specified before the variable argument:', '');
INSERT INTO `textbook` (`textid`, `topic`, `content`, `code`) VALUES
(163, 'Methods', 'Methods are how we communicate with objects. When we invoke or call a method we are asking the object to carry out a task. We can say methods implement the behaviour of objects. For each method we need to give a name, we need to define its input parameters and we need to define its return type. We also need to set its visibility (private, protected or public). If the method throws an Exception, that needs to be declared as well. It is called a method definition. The syntax of method definition is: class MyClass {}We can declare that the method does not return anything using the void Java keyword. For example:When the method returns nothing, the return keyword at the end of the method is optional. When the execution flow reaches the return keyword, the method execution is stopped and the execution flow returns to the caller method. The return keyword can be used anywhere in the method as long as there is a way to execute the instructions below:In the code section 3.68, the return keyword at line 5 is well placed because the instructions below can be reached when a is negative or equal to 0. However, the return keyword at line 8 is badly placed because the instructions below cant be reached.', ''),
(164, 'Nested Classes - Anonymous Classes', 'In Java, a class definition and its instantiation can be combined into a single step. By doing that the class does not require a name. Those classes are called anonymous classes. An anonymous class can be defined and instantiated in contexts where a reference can be used, and it is a nested class to an existing class. Anonymous class is a special case of a class local to a method; hence they also can access final local variables of the enclosing method.Anonymous classes are most useful to create an instance of an interface or adapter class without needing a brand new class.In the above example the class that implements the ActionListener is anonymous. The class is defined where it is instantiated.The above code is harder to read than if the class is explicitly defined, so why use it? If many implementations are needed for an interface, those classes are used only in one particular place, and it would be hard to come up with names for them, using an anonymous inner class makes sense.The following example uses an anonymous inner class to implement an action listener.The following example does the same thing, but it names the class that implements the action listener.Using anonymous classes is especially preferable when you intend to use many different classes that each implement the same interface.', ''),
(165, 'Nested Classes - Inner classes', 'When a class is declared inside another class, the nested class access modifier can be public, private, protected or package(default).The inner class has access to the enclosing class instances variables and methods, even private ones, as seen above. This makes it very different from the nested class in C++, which are equivalent to the "static" inner classes, see below.An inner object has a reference to the outer object. In other words, all inner objects are tied to the outer object. The inner object can only be created through a reference to the outer object. See below.Note that inner objects, because they are tied to the outer object, cannot contain static variables or methods.When in a non-static method of the outer class, you can directly use new InnerClass(), since the class instance is implied to be this.You can directly access the reference to the outer object from within an inner class with the syntax OuterClass.this; although this is usually unnecessary because you already have access to its fields and methods.Inner classes compile to separate ".class" bytecode files, with the name of the enclosing class, followed by a "$", followed by the name of the inner class. So for example, the above inner class would be compiled to a file named "OuterClass$InnerClass.class".An inner class can be declared static. These classes are not bound to an instance of the outer defining class. A static inner class has no enclosing instance, and therefore cannot access instance variables and methods of the outer class. You do not specify an instance when creating a static inner class. This is equivalent to the inner classes in C++.These inner classes, also called local classes, cannot have access modifiers, like local variables, since the class is private to the method. The inner class can be only abstract or final.In addition to instance variables of the enclosing class, local classes can also access local variables of the enclosing method, but only ones that are declared final. This is because the local class instance might outlive the invocation of the method, and so needs its own copy of the variable. To avoid problems with having two different copies of a mutable variable with the same name in the same scope, it is required to be final, so it cannot be changed.', ''),
(166, 'Nested Classes', 'In Java you can define a class inside an other class. A class can be nested inside another class or inside a method. A class that is not nested is called a top-level class and a class defining a nested class is an outer class.', ''),
(167, 'Nesting Exceptions', 'When an exception is caught, the exception contains the stack-trace, which describes the error and shows where the exception happened, where the problem is, where the application programmer should look to fix the problem. Sometime it is desirable to catch an exception and throw another new exception. If the new exception keep a reference to the first exception, the first exception is called a nesting exception.The above code is an example of a nesting exception. When the Exception is thrown, by passing in the ClassCastException object reference as a parameter, the ClassCastException is nested in the newly created Exception, its stack-trace is appended together. When the Exception is caught, its stack-trace contains the original ClassCastExceptions stack-trace.This is a kind of exception conversion, from one exception to another. For example, calling a remote object using RMI, the calling method has to deal with RemoteException which is thrown if something is wrong during the communication. For the application point of view, RemoteException has no meaning, it should be transparent to the application that a remote object was used or not. So the RemoteException should be converted to an application exception.This conversion can also hide where the error is originated. The stack-trace starts when the exception is thrown. So when we catch and throw a new exception, the stack-trace starts at when the new exception was thrown, losing the original stack-trace. This was true with the earlier version of Java (before 1.4). Since then, a so called cause facility capabilities were built in the Throwable class.A throwable contains a snapshot of the execution stack of its thread at the time it was created. It can also contain a message string that gives more information about the error. Finally, it can contain a cause: another throwable that caused this throwable to get thrown. The cause facility is also known as the chained exception facility, as the cause can, itself, have a cause, and so on, leading to a "chain" of exceptions, each caused by another.A cause can be associated with a throwable in two ways: via a constructor that takes the cause as an argument, or via the initCause(Throwable) method. New throwable classes that wish to allow causes to be associated with them should provide constructors that take a cause and delegate (perhaps indirectly) to one of the Throwable constructors that takes a cause. For example:Because the initCause method is public, it allows a cause to be associated with any throwable, even a "legacy throwable" whose implementation predates the addition of the exception chaining mechanism to Throwable. For example:Further, as of release 1.4, many general purpose Throwable classes (for example Exception, RuntimeException, Error) have been retrofitted with constructors that take a cause. This was not strictly necessary, due to the existence of the initCause method, but it is more convenient and expressive to delegate to a constructor that takes a cause.By convention, class Throwable and its subclasses have two constructors, one that takes no arguments and one that takes a String argument that can be used to produce a detail message. Further, those subclasses that might likely have a cause associated with them should have two more constructors, one that takes a Throwable (the cause), and one that takes a String (the detail message) and a Throwable (the cause).', ''),
(168, 'Object Lifecycle - Class loading', 'One of the main concerns of a developer writing hot re-deployable applications is to understand how class loading works. Within the internals of the class loading mechanism lies the answer to questions like:', ''),
(169, 'Object Lifecycle - Creating object by cloning an object', 'Cloning is not automatically available to classes. There is some help though, as all Java objects inherit the protected Object clone() method. This base method would allocate the memory and do the bit by bit copying of the objects states.You may ask why we need this clone method. Couldnt I create a constructor and just passing in the same object, and do the copying variable by variable? Lets see:You might think that accessing the private memberVar variable of obj would fail but as this is in the same class this code is legal. The clone() method copies the whole objects memory in one operation. This is much faster than using the new keyword. Object creation with the new keyword is expensive, so if you need to create lots of objects with the same type, performance will be better if you create one object and clone new ones from it. See below a factory method that will return a new object using cloning.Now, lets see how to make the Customer object cloneable.In the code listing 4.15 we used cloning for speed up object creation. Another use of cloning could be to take a snapshot of an object that can change in time. Lets say we want to store Customer objects in a collection, but we want to disassociate them from the live objects. So before adding the object, we clone them, so if the original object changes from that point forward, the added object wont. Also lets say that the Customer object has a reference to an Activity object that contains the customer activities. Now we are facing a problem, it is not enough to clone the Customer object, we also need to clone the referenced objects. The solution:Note that only mutable objects needs to be cloned. References to unchangeable objects such as String be used in the cloned object without worry.', ''),
(170, 'Object Lifecycle - Creating object receiving from a remote source', 'When an object is sent through a network, the object needs to be recreated at the receiving host.Java has built-in support for serialization, using the Serializable interface; however, a class must first implement the Serializable interface.By default, a class will have all of its fields serialized when converted into a data stream (with transient fields being skipped). If additional handling is required beyond the default of writing all fields, you need to provide an implementation for methods:If the object needs to write or provide a replacement object during serialization, it needs to implement the following two methods, with any access specifier:Normally, a minor change to the class can cause the serialization to fail. You can still allow the class to be loaded by defining the serialization version id:', ''),
(171, 'Object Lifecycle - Creating object with the new keyword', '99% of new objects are created using the new keyword.When an object from the MyObject class is created for the first time, the JVM searches the file system for the definition of the class, that is the Java byte code. The file has the extension of *.class. The CLASSPATH environment variable contains locations where Java classes are stored. The JVM is looking for the MyObject.class file. Depending on which package the class belongs to, the package name will be translated to a directory path.When the MyObject.class file is found, the JVMs class loader loads the class in memory, and creates a java.lang.Class object. The JVM stores the code in memory, allocates memory for the static variables, and executes any static initialize block. Memory is not allocated for the object member variables at this point, memory will be allocated for them when an instance of the class, an object, is created.There is no limit on how many objects from the same class can be created. Code and static variables are stored only once, no matter how many objects are created. Memory is allocated for the object member variables when the object is created. Thus, the size of an object is determined not by its codes size but by the memory it needs for its member variables to be stored.', ''),
(172, 'Object Lifecycle - Destroying objects', 'Unlike in many other object-oriented programming languages, Java performs automatic garbage collection any unreferenced objects are automatically erased from memory and prohibits the user from manually destroying objects.When an object is garbage-collected, the programmer may want to manually perform cleanup, such as closing any open input/output streams. To accomplish this, the finalize() method is used. Note that finalize() should never be manually called, except to call a super class finalize method from a derived class finalize method. Also, we can not rely on when the finalize() method will be called. If the java application exits before the object is garbage-collected, the finalize() method may never be called.The garbage-collector thread runs in a lower priority than the other threads. If the application creates objects faster than the garbage-collector can claim back memory, the program can run out of memory.The finalize method is required only if there are resources beyond the direct control of the Java Virtual Machine that needs to be cleaned up. In particular, there is no need to explicitly close an OutputStream, since the OutputStream will close itself when it gets finalized. Instead, the finalize method is used to release either native or remote resources controlled by the class.', ''),
(173, 'Object Lifecycle', 'Before a Java object can be created the class byte code must be loaded from the file system (with .class extension) to memory. This process of locating the byte code for a given class name and converting that code into a Java class instance is known as class loading. There is one class created for each type of Java class.All objects in Java programs are created on heap memory. An object is created based on its class. You can consider a class as a blueprint, template, or a description how to create an object. When an object is created, memory is allocated to hold the object properties. An object reference pointing to that memory location is also created. To use the object in the future, that object reference has to be stored as a local variable or as an object member variable.The Java Virtual Machine (JVM) keeps track of the usage of object references. If there are no more reference to the object, the object can not be used any more and becomes garbage. After a while the heap memory will be full of unused objects. The JVM collects those garbage objects and frees the memory they allocated, so the memory can be reused again when a new object is created. See below a simple example:The obj variable contains the object reference pointing to an object created from the MyObject class. The obj object reference is in scope inside the { }. After the } the object becomes garbage. Object references can be passed in to methods and can be returned from methods.', ''),
(174, 'Overloading and Overriding - Constructor overloading', 'The constructor can be overloaded. You can define more than one constructor with different parameters. For example:In the code listing 4.12, we defined two constructors, one with no input parameter, and one with one input parameter. You may ask which constructor will be called. Its depends how the object is created with the new keyword. See below:In the code section 4.29, we created two objects from the same class, or we can also say that obj1 and obj2 both have the same type. The difference between the two is that in the first one the memberField field is not initialized, in the second one that is initialized to "Init Value". A constructor may also be called from another constructor, see below:In the code listing 4.13, the constructor with no input parameter calls the other constructor with the default initial value. This call must be the first instruction of a constructor or else a compiler error will occur. The code gives an option to the user, to create the object with the default value or create the object with a specified value. The first constructor could have been written using the this keyword as well:Such a call reduces the code repetition.', ''),
(175, 'Overloading and Overriding - Method overloading', 'In a class, there can be several methods with the same name. However they must have a different signature. The signature of a method is comprised of its name, its parameter types and the order of its parameter. The signature of a method is not comprised of its return type nor its visibility nor its exceptions it may throw. The practice of defining two or more methods within the same class that shares the same names but different parameters is called overloading methods.Methods with the same name in a class are called overloaded methods. Overloading methods offers no specific benefit to the JVM but it is useful to the programmer to have several methods do the same things but with different parameters. For example, we may have the operation runAroundThe represented as two methods with the same name, but different input parameter types:One type can be the subclass of the other:Although both methods would be fit to call the method with the String parameter, it is the method with the nearest type that will be called instead. To be more accurate, it will call the method whose parameter type is a subclass of the parameter type of the other method. So, aObject will output Object. Beware! The parameter type is defined by the declared type of an object, not its instantiated type!The following two method definitions are validbecause the type order is different. If both input parameters were type String, that would be a problem since the compiler would not be able to distinguish between the two:The compiler would give an error for the following method definitions as well:Note, the return type is not part of the unique signature. Why not? The reason is that a method can be called without assigning its return value to a variable. This feature came from C and C++. So for the call:the compiler would not know which method to call. It is also the case for the thrown exceptions.', ''),
(176, 'Overloading and Overriding - Method overriding', 'To easily remember what can be done in method overriding, keep in mind that all you can do on an object of a class outside this class, you can do it also on an object of a subclass, only the behavior can change. A subclass should be covariant.Although a method signature has to be unique inside a class, the same method signature can be defined in different classes. If we define a method that exists in the super class then we override the super class method. It is called method overriding. This is different from method overloading. Method overloading happens with methods with the same name different signature. Method overriding happens with same name, same signature between inherited classes.The return type can cause the same problem we saw above. When we override a super class method the return type also must be the same. If that is not the same, the compiler will give you an error.Beware! If a class declares two public methods with the same name, and a subclass overrides one of them, the subclass still inherits the other method. In this respect, the Java programming language differs from C++.Method overriding is related dynamic linking, or runtime binding. In order for the Method Overriding to work, the method call that is going to be called can not be determined at compilation time. It will be decided at runtime, and will be looked up in a table.In the code section 4.31, the expression at line 3 is true if it is executed a morning and false if it is executed an afternoon. Thus, the instance of obj will be a MyClass or a SubOfMyClass depending on the execution time. So it is impossible to determine the method address at compile time. Because the obj reference can point to object and all its sub object, and that will be known only at runtime, a table is kept with all the possible method addresses to be called. Do not confuse:The implementation of this method is searched using the instantiated type of the called object (obj) and the declared type of the parameter object (myParameter).Also another rule is that when you do an override, the visibility of the new method that overrides the super class method can not be reduced. The visibility can be increased, however. So if the super class method visibility is public, the override method can not be package, or private. An override method must throw the same exceptions as the super class, or their subexceptions.super references to the parent class (i.e. super.someMethod()). It can be used in a subclass to access inherited methods that the subclass has overridden or inherited fields that the subclass has hidden.', ''),
(177, 'Overloading and Overriding - Variable Argument', 'Instead of overloading, you can use dynamic number of arguments. After the last parameter, you can pass optional unlimited parameters of the same type. These parameters are defined by adding a last parameter and adding ... after its type. The dynamic arguments will be received as an array:The above method can be called with a dynamic number of arguments, for example:This feature was not available before Java 1.5 .', ''),
(178, 'Overview - Applet', 'The Java creators created the concept of the applet. A Java program can be run in a client browser program. Java was released in 1995; the time when the Internet was becoming more available and familiar to the general public. The promise of Java was in the client browser-side in that code would be downloaded and executed as a Java applet in the client browser program.', ''),
(179, 'Overview - Automatic memory garbage collection', 'In conventional languages like C and C++, the programmer has to make sure that all memory that was allocated is freed. Memory leaks became a regular nuisance in instances where the programmers had to manually allocate the systems memory resources.Memory resources or buffers have specific modes of operation for optimal performance. Once a buffer is filled with data, it needs to be cleaned up after there is no further use for its content. If a programmer forgets to clean it in his/her code, the memory is easily overloaded. Programming in C/C++ languages became tedious and unsafe because of these very quirks, and programs built in these languages were prone to memory leakages and sudden system crashes sometimes even harming the hardware itself. Freeing memory is particularly important in servers, since it has to run without stopping for days. If a piece of memory is not freed after use and the server just keeps allocating memory, that memory leak can take down the server.In Java, freeing up memory is taken out of the programmers hands; the Java Virtual Machine keeps track of all used memory. When memory is not used any more it is automatically freed up. A separate task is running in the background by the JVM, freeing up unreferenced, unused memory. That task is called the Garbage Collector.The Garbage Collector is always running. This automatic memory garbage collection feature makes it easy to write robust server side programs in Java. The only thing the programmer has to watch for is the speed of object creation. If the application is creating objects faster than the Garbage Collector can free them, it can cause memory problems. Depending on how the JVM is configured, the application either can run out of memory by throwing the NotEnoughMemoryException, or can halt to give time for the Garbage Collector to do its job.', ''),
(180, 'Overview - Dynamic class loading', 'In conventional languages like C and C++, all code had to be compiled and linked to one executable program, before execution. In Java, classes are compiled as needed. If a class is not needed during an execution phase, that class is not even compiled into byte code.This feature comes in handy especially in network programming when we do not know, beforehand, what code will be executed. A running program could load classes from the file system or from a remote server.Also this feature makes it theoretically possible for a Java program to alter its own code during execution, in order to do some self-learning behavior. It would be more realistic to imagine, however, that a Java program would generate Java code before execution, and then, that code would be executed. With some feedback mechanism, the generated code could improve over time.', ''),
(181, 'Overview - Error handling', 'The old way of error handling was to let each function return an error code then let the caller check what was returned. The problem with this method was that if the return code was full of error-checking codes, this got in the way of the original one that was doing the actual work, which in turn did not make it very readable.In the new way of error handling, functions/methods do not return error codes. Instead, when there is an error, an exception is thrown. The exceptions can be handled by the catch keyword at the end of a try block. This way, the code that is calling the function does not need to be mangled with error checking codes, thus making the code more readable. This new way of error handling is called Exception handling.Exception handling was also added to C++. However, there are two differences between Java and C++ Exception handling:The optional exception handling in the Java predecessors leads the developers not to care about the error handling. As a consequence, unexpected errors often occur. Java forces the developers to handle exceptions. The programmer must handle exception or declare that the user must handle it. Someone must handle it.', ''),
(182, 'Overview - Evaluation', 'In most peoples opinions, Java technology delivers reasonably well on all these goals. The language is not, however, without drawbacks. Java tends to be more high-level than similar languages (such as C++), which means that the Java language lacks features such as hardware-specific data types, low-level pointers to arbitrary memory addresses, or programming methods like operator overloading. Although these features are frequently abused or misused by programmers, they are also powerful tools. However, Java technology includes Java Native Interface (JNI), a way to call native code from Java language code. With JNI, it is still possible to use some of these features.Some programmers also complain about its lack of multiple inheritance, a powerful feature of several object-oriented languages, among others C++. The Java language separates inheritance of type and implementation, allowing inheritance of multiple type definitions through interfaces, but only single inheritance of type implementation via class hierarchies. This allows most of the benefits of multiple inheritance while avoiding many of its dangers. In addition, through the use of concrete classes, abstract classes, as well as interfaces, a Java language programmer has the option of choosing full, partial, or zero implementation for the object type he defines, thus ensuring maximum flexibility in application design.There are some who believe that for certain projects, object orientation makes work harder instead of easier. This particular complaint is not unique to the Java language but applies to other object-oriented languages as well.', ''),
(183, 'Overview - Forbidden bad practices', 'Over the years, some features in C/C++ programming became abused by the programmers. Although the language allows it, it was known as bad practices. So the creators of Java have disabled them:', ''),
(184, 'Overview - Networking capabilities', 'However powerful, the predecessors of Java lacked a standard feature to network with other computers, and usually relied on the platforms intricate networking capabilities. With almost all network protocols being standardized, the creators of Java technology wanted this to be a flagship feature of the language while keeping true to the spirit of earlier advances made towards standardizing Remote Procedure Call. Another feature that the Java team focused on was its integration in the World Wide Web and the Internet.The Java platform was one of the first systems to provide wide support for the execution of code from remote sources. The Java language was designed with network computing in mind.An applet could run within a users browser, executing code downloaded from a remote HTTP server. The remote code runs in a highly restricted "sandbox", which protects the user from misbehaving or malicious code; publishers could apply for a certificate that they could use to digitally sign applets as "safe", giving them permission to break out of the sandbox and access the local file system and network, presumably under user control.', ''),
(185, 'Overview - Object orientation', 'Object orientation ("OO"), refers to a method of programming and language technique. The main idea of OO is to design software around the "things" (i.e. objects) it manipulates, rather than the actions it performs.As the hardware of the computer advanced, it brought about the need to create better software techniques to be able to create ever increasing complex applications. The intent is to make large software projects easier to manage, thus improving quality and reducing the number of failed projects. Object oriented solution is the latest software technique.', ''),
(186, 'Overview - Platform dependence', 'In C or C++ programming, you start to write a source code:', ''),
(187, 'Overview - Platform dependence', '... you compile it to a machine code file:', ''),
(188, 'Overview - Platform dependence', '... and then you execute it:', ''),
(189, 'Overview - Platform dependence', 'In this situation, the machine code file and its execution are specific to the platform (Windows, Linux, Mac OS, ...) it was compiled for, that is to say to the targeted platform:... because the compiled file is a machine code file designed to work on a specific platform and hardware. It would have produced a different results/output for another platform. So if you want your program to run on several platforms, you have to compile your program several times:It poses greater vulnerability risks. Note here that when a certain code is compiled into an executable format, the executable cannot be changed dynamically. It would need to be recompiled from the changed code for the changes to be reflected in the finished executable. Modularity (dividing code into modules) is not present in Javas predecessors. If instead of a single executable, the output application was in the form of modules, one could easily change a single module and review changes in the application. In C/C++ on the other hand, a slight change in code required the whole application to be recompiled.The idea of Java is to compile the source code into an intermediate language that will be interpreted.The intermediate language is the byte code. The interpretor is the Java Virtual Machine (JVM). The byte code file is universal and the JVM is platform specific:So a JVM should be coded for each platform. And thats the case. So you just have to generate a unique byte code file (a .class file).The first implementations of the language used an interpreted virtual machine to achieve portability, and many implementations still do. These implementations produce programs that run more slowly than the fully-compiled programs created by the typical C++ compiler, so the language suffered a reputation for producing slow programs. Since Java 1.2, Java VM produces programs that run much faster, using multiple techniques.The first of these is to simply compile directly into native code like a more traditional compiler, skipping bytecode entirely. This achieves great performance, but at the expense of portability. This is not really used any more.Another technique, the just-in-time (JIT) compiler, compiles the Java bytecode into native code at the time the program is run, and keep the compiled code to be used again and again. More sophisticated VMs even use dynamic recompilation, in which the VM can analyze the behavior of the running program and selectively recompile and optimize critical parts of the program. Both of these techniques allow the program to take advantage of the speed of native code without losing portability.Portability is a technically difficult goal to achieve, and Javas success at that goal is a matter of some controversy. Although it is indeed possible to write programs for the Java platform that behave consistently across many host platforms, the large number of available platforms with small errors or inconsistencies led some to parody Suns "Write once, run anywhere" slogan as "Write once, debug everywhere".', ''),
(190, 'Overview - Secure execution', 'With the high-level of control built into the language to manipulate hardware, a C/C++ programmer could access almost any resource, either hardware or software on the system. This was intended to be one of the languages strong points, but this very flexibility led to confusion and complex programming practices.', ''),
(191, 'Overview - Standardization', 'C++ was built atop the C language and as a result divergent ways of doing the same thing manifested around the language. For instance, creating an object could be done in three different ways in C++. Furthermore, C++ did not come with a standard library bundled with its compilers. Instead, it relied on resources created by other programmers; code which rarely fit together.In Java, standardized libraries are provided to allow access to features of the host machines (such as graphics and networking) in unified ways. The Java language also includes support for multi-threaded programsa necessity for many networking applications.Platform independent Java is, however, very successful with server side applications, such as web services, servlets, or Enterprise JavaBeans.Java also made progress on the client side, first it had Abstract Window Toolkit (AWT), then Swing, and the most recent client side library is the Standard Widget Toolkit (SWT). It is interesting to see how they tried to handle the two opposing consuming forces. Those are:It is interesting to see how the approach was switched back and forth. AWT Swing SWT.', ''),
(192, 'Overview', 'The new features and upgrades included into Java changed the face of programming environment and gave a new definition to Object Oriented Programming (OOP in short). But unlike its predecessors, Java needed to be bundled with standard functionality and be independent of the host platform.The primary goals in the creation of the Java language:The Java language introduces some new features that did not exist in other languages like C and C++.', ''),
(193, 'Packages - Import and class usage', 'The simpliest way to use a class declared in a package is to prefix the class name with its package:If you are using the class from a class in the same package, you dont have to specify the package. If another class with the same name exists in another package, it will use the local class.The syntax above is a bit verbose. You can import the class by using the import Java keyword at the top of the file and then only specify its name:Note that you cant import two classes with the same name in two different packages.The classes Integer and String belongs to the package java.lang but they dont need to be imported as the java.lang package is implicitly imported in all classes.', ''),
(194, 'Packages - Importing packages from .jar files', 'If you are importing library packages or classes that reside in a .jar file, you must ensure that the file is in the current classpath (both at compile- and execution-time). Apart from this requirement, importing these packages and classes is the same as if they were in their full, expanded, directory structure.For example, to compile and run a class from a projects top directory (that contains the two directories /source and /libraries) you could use the following command:And then to run it, similarly:The above is simplified, and demands that MainClass be in the default package, or a package called source, which isnt very desirable.With BlueJ just click on Tools, Preferences, Libraries, and add the .jar one by one.', ''),
(195, 'Packages - Package convention', 'A package name should start with a lower character. This eases to distinguish a package from a class name. In some operating systems, the directory names are not case sensitive. So package names should be lowercase.The Java package needs to be unique across Vendors to avoid name collisions. For that reason Vendors usually use their domain name in reverse order. That is guaranteed to be unique. For example a company called Your Company Inc., would use a package name something like this: com.yourcompany.yourapplicationname.yourmodule.YourClass.', ''),
(196, 'Packages - Package declaration', 'In a class, a package is declared at the top of the source code using the keyword package:If your class is declared in a package, say business, your class must be placed in a subfolder called business from the root of your application folder. This is how the compiler and the class loader find the Java files on the file system. You can declare your class in a subpackage, say engine. So the full package is business.engine and the class must be placed in a subsubfolder called engine in the subfolder business (not in a folder called business.engine).', ''),
(197, 'Packages - Wildcard imports', 'It is possible to import an entire package, using an asterisk:While it may seem convenient, it may cause problems if you make a typographical error. For example, if you use the above import to use JFrame, but then type JFraim frame = new JFraim();, the Java compiler will report an error similar to "Cannot find symbol: JFraim". Even though it seems as if it was imported, the compiler is giving the error report at the first mention of JFraim, which is half-way through your code, instead of the point where you imported JFrame along with everything else in javax.swing.If you change this to import javax.swing.JFraim; the error will be at the import instead of within your code.Furthermore, if you import javax.swing.*; and import java.util.*;, and javax.swing.Queue is later added in a future version of Java, your code that uses Queue (java.util) will fail to compile. This particular example is fairly unlikely, but if you are working with non-Oracle libraries, it may be more likely to happen.', ''),
(198, 'Packages', 'If your application becomes quite big, you may have lots of classes. Although you can browse them in their alphabetic order, it becomes confusing. So your application classes can be sorted into packages.A package is a name space that mainly contains classes and interfaces. For instance, the standard class ArrayList is in the package java.util. For this class, java.util.ArrayList is called its fully qualified name because this syntax has no ambiguity. Classes in different packages can have the same name. For example, you have the two classes java.util.Date and java.sql.Date which are not the same. If no package is declared in a class, its package is the default package.', ''),
(199, 'Primitive Types - Data conversion (casting)', 'Data conversion (casting) can happen between two primitive types. There are two kinds of casting:The following table shows the conversions between primitive types, it shows the casting operation for explicit conversions:Unlike C, C++ and similar languages, Java cant represent false as 0 or null and cant represent true as non-zero. Java cant cast from boolean to a non-boolean primitive data type, or vice versa.', ''),
(200, 'Primitive Types - Data conversion (casting)', 'For non primitive types:', ''),
(201, 'Primitive Types - Integer numbers and floating point numbers', 'The data types that one can use for integer numbers are byte, short, int and long but when it comes to floating point numbers, we use float or double. Now that we know that, we can modify the code in the code section 3.53 as:Why not float, you say? If wed used a float, we would have to append the number with a f as a suffix, so 10.5 should be 10.5f as in:Floating-point math never throws exceptions. Dividing a non-zero value by 0 equals infinity. Dividing a non-infinite value by infinity equals 0.', ''),
(202, 'Primitive Types - Integer types in Java', 'With what we have learned so far, we will identify the different types of signed integer values that can be created and manipulated in Java. Following is a table of the most basic numeric types: integers. As we have discussed earlier, the data types in Java for integers caters to both positive and negative values and hence are signed numeric types. The size in bits for a numeric type determines what its minimum and maximum value would be. If in doubt, one can always calculate these values.Lets see how this new found knowledge of the basic integer types in Java fits into the picture. Say, you want to numerically manipulate the days in a year all 365 days. What type would you use? Since the data type byte only goes up to 127, would you risk giving it a value greater than its allowed maximum. Such decisions might save you from dreaded errors that might occur out of the programmed code. A much more sensible choice for such a numeric operation might be a short. Oh, why couldnt they make just one data type to hold all kinds of numbers? Wouldnt you ask that question? Well, lets explore why.When you tell a program you need to use an integer, say even a byte, the Java program allocates a space in the memory. It allocates whole 8 bits of memory. Where it wouldnt seem to matter for todays memory modules that have place for almost a dozen trillion such bits, it matters in other cases. Once allocated that part of the memory gets used and can only be claimed back after the operation is finished. Consider a complicated Java program where the only data type youd be using would be long integers. What happens when theres no space for more memory allocation jobs? Ever heard of the Stack Overflow errors. Thats exactly what happens your memory gets completely used up and fast. So, choose your data types with extreme caution.Enough talk, lets see how you can create a numeric type. A numeric type begins with the types name (short, int, etc.) and then provides with a name for the allocated space in the memory. Following is how its done. Say, we need to create a variable to hold the number of days in a year.Here, daysInYear is the name of the variable that holds 365 as its value, while short is the data type for that particular value. Other uses of integer data types in Java might see you write code such as this given below:', ''),
(203, 'Primitive Types - Numbers in computer science', 'Programming may not be as trivial or boring as just crunching huge numbers any more. However, huge chunks of code written in any programming language today, let alone Java, obsessively deal with numbers. Be it churning out huge prime numbers,[1] or just calculating a cost of emission from your scooter. In 1965, Gemini V space mission escaped a near-fatal accident because of a programming error.[2] And again in 1979, a computer program calculated the ability of five nuclear reactors to withstand earthquakes as overestimated; this caused the plants to be shut down temporarily.[3] There is one thing common to both these programming errors: the subject data, being computed at the time the errors occurred, was numeric. Out of past experience, Java came bundled with revised type checking for numeric data and puts lots of emphasis on correctly identifying different types of it. So you must recognise the importance of numeric data when it comes to programming.Numbers are stored in memory using a binary system. The memory is like a grid of cells:Each cell can contain a binary digit (shortened to bit), that is to say, zero or one:Actually, each cell does contain a binary digit, as one bit is roughly equivalent to 1 and an empty cell in the memory signifies 0. A single binary digit can only hold two possible values: a zero or a one.Multiple bits held together can hold multiple permutations 2 bits can hold 4 possible values, 3 can hold 8, and so on. For instance, the maximum number 8 bits can hold (11111111 in binary) is 255 in the decimal system. So, the numbers from 0 to 255 can fit within 8 bits.It is all good, but this way, we can only host positive numbers (or unsigned integers). They are called unsigned integers. Unsigned integers are whole number values that are all positive and do not attribute to negative values. For this very reason, we would ask one of the 8 bits to hold information about the sign of the number (positive or negative). This leaves us with just 7 bits to actually count out a number. The maximum number that these 7 bits can hold (1111111) is 127 in the decimal system.Altogether, using this method, 8 bits can hold numbers ranging from -128 to 127 (including zero) a total of 256 numbers. Not a bad pay-off one might presume. The opposite to an unsigned integer is a signed integer that have the capability of holding both positive and negative values.But, what about larger numbers. You would need significantly more bits to hold larger numbers. Thats where Javas numeric types come into play. Java has multiple numeric types their size dependant on the number of bits that are at play.In Java, numbers are dealt with using data types specially formulated to host numeric data. But before we dive into these types, we must first set some concepts in stone. Just like you did in high school (or even primary school), numbers in Java are placed in clearly distinct groups and systems. As youd already know by now, number systems includes groups like the integer numbers (0, 1, 2 ... ); negative integers (0, -1, -2 ... -) or even real and rational numbers (value of Pi, , 0.333~, etcetera). Java simply tends to place these numbers in two distinct groups, integers (- ... 0 ... ) and floating point numbers (any number with decimal points or fractional representation). For the moment, we would only look into integer values as they are easier to understand and work with.', ''),
(204, 'Primitive Types', 'Primitive types are the most basic data types available within the Java language; these include boolean, byte, char, short, int, long, float and double. These types serve as the building blocks of data manipulation in Java. Such types serve only one purpose containing pure, simple values of a kind. Because these data types are defined into the Java type system by default, they come with a number of operations predefined. You can not define a new operation for such primitive types. In the Java type system, there are three further categories of primitives:All the primitive types have a fixed size. Thus, the primitive types are limited to a range of values. A smaller primitive type (byte) can contain less values than a bigger one (long).Integer primitive types silently overflow:As Java is strongly typed, you cant assign a floating point number (a number with a decimal point) to an integer variable:A primitive type should be set by an appropriate value. The primitive types can be initialized with a literal. Most of the literals are primitive type values, except String Literals, which are instance of the String class.', ''),
(205, 'Random numbers - Truly random numbers', 'Both Math.random() and the Random class produce pseudorandom numbers. This is good enough for a lot of applications, but remember that it is not truly random. If you want a more secure random number generator, Java provides the java.security.SecureRandom package. What happens with Math.random() and the Random class is that a seed is chosen from which the pseudorandom numbers are generated. SecureRandom increases the security to ensure that the seed which is used by the pseudorandom number generator is non-deterministic that is, you cannot simply put the machine in the same state to get the same set of results. Once you have created a SecureRandom instance, you can use it in the same way as you can the Random class.If you want truly random numbers, you can get a hardware random number generator or use a randomness generation service.', ''),
(206, 'Random numbers', 'To generate random numbers the Math.random() method can be used, which returns a double, greater than or equal to 0.0 and less than 1.0.The following code returns a random integer between n and m (where n <= randomNumber < m):Alternatively, the java.util.Random class provides methods for generating random booleans, bytes, floats, ints, longs and Gaussians (doubles from a normal distribution with mean 0.0 and standard deviation 1.0). For example, the following code is equivalent to that above:As an example using random numbers, we can make a program that uses a Random object to simulate flipping a coin 20 times:Of course, if you run the program you will probably get different results.', '');
INSERT INTO `textbook` (`textid`, `topic`, `content`, `code`) VALUES
(207, 'Remote Method Invocation - RMI clients', 'Here is an example of RMI client:', ''),
(208, 'Remote Method Invocation - RMI Remote object', 'The remote object has to either extend the java.rmi.server.UnicastRemoteObject object, or be explicitly exported by calling the java.rmi.server.UnicastRemoteObject.exportObject() method.', ''),
(209, 'Remote Method Invocation - rmiregistry', 'Remote objects can be listed in the RMI Registry. Clients can get a reference to the remote object by querying the Registry. After that, the client can call methods on the remote objects. (Remote object references can also be acquired by calling other remote methods. The Registry is really a bootstrap that solves the problem of where to get the initial remote reference from.)The RMI Registry can either be started within the server JVM, via the LocateRegistry.createRegistry() API, or a separate process called rmiregistry that has to be started before remote objects can be added to it, e.g. by the command line in Unix:or under Windows:If port is not specified the default 1099 is used. The client will need to connect to this port to access the Registry.The Registry can also be started from a program by calling the following code:Objects passed in as parameters to the remote objectss methods will be passed by value. If the remote object changes the passed-in object values, it wont be reflected on the client side, this is opposite what happens when a local object is called. Objects that used as parameters for remote methods invocation must implement the java.io.Serializable interface, as they are going to be serialized when passed through the network, and a new object will be created on the other side.However, exported remote objects passed as parameters are passed by remote reference.', ''),
(210, 'Remote Method Invocation - STUB and SKELETON', 'The remote method invocation goes through a STUB on the client side and a so called SKELETON on the server side.Prior to Java 1.2 the skeleton had to be explicitly generated with the rmic tool. Since 1.2 a dynamic skeleton is used, which employs the features of Java Reflection to do its work.', ''),
(211, 'Remote Method Invocation', 'Javas Remote Method Invocation (commonly referred to as RMI) is used for client and server models. RMI is the object oriented equivalent to RPC (Remote procedure call).The Java Remote Method Invocation (RMI) system allows an object running in one Java Virtual Machine (VM) to invoke methods on an object running in another Java VM. RMI provides for remote communication between programs written in the Java programming language.RMI is defined to use only with the Java platform. If you need to call methods between different language environments, use CORBA. With CORBA a Java client can call C++ server and/or a C++ client can call a Java server. With RMI that can not be done.', ''),
(212, 'Scope - Access modifiers', 'You surely would have noticed by now, the words public, protected and private at the beginning of classs method declarations used in this book. These keywords are called the access modifiers in the Java language syntax, and they define the scope of a given item.The interface methods and interfaces are always public. You do not need to specify the access modifier. It will default to public. For clarity it is considered a good practice to put the public keyword.The same way all member variables defined in the Interface by default will become static final once inherited in a class.The cases in bold are the default.', ''),
(213, 'Scope - Field encapsulation', 'Generally, it is best to make data private or protected. Access to the data is controlled by setter and getter methods. This lets the programmer control access to data, allowing him/her to check for and handle invalid data.In the code section 3.51, the setName() method will only change the value of name if the new name is not null. Because setName() is conditionally changing name, it is wise to return a boolean to let the program know if the change was successful.', ''),
(214, 'Scope - Scope', 'The scope of a class, a variable or a method is its visibility and its accessibility. The visibility or accessibility means that you can use the item from a given place.A method parameter is visible inside of the entire method but not visible outside the method.In code listing 3.14, i is visible within the entire method1 method but not in the method2 and the main methods.A local variable is visible after its declaration until the end of the block in which the local variable has been created.', ''),
(215, 'Scope - Utility', 'A general guideline for visibilities is to only make a member as visible as it needs to be. Dont make a member public if it only needs to be private.Doing so, you can rewrite a class and change all the private members without making compilation errors, even you dont know all the classes that will use your class as long as you do not change the signature of the public members.', ''),
(216, 'Stack trace - Converting the stack trace into string', 'Many times for debugging purposes, wed like to convert the stack trace to a String so we can log it to our log file.The following code shows how to do that:', ''),
(217, 'Stack trace', 'Stack Trace is a list of method calls from the point when the application was started to the point where the exception was thrown. The most recent method calls are at the top.The stack trace can be printed to the standard error by calling the public void printStackTrace() method of an exception.From Java 1.4, the stack trace is encapsulated into an array of a java class called java.lang.StackTraceElement. The stack trace element array returned by Throwable.getStackTrace() method. Each element represents a single stack frame. All stack frames except for the one at the top of the stack represent a method invocation. The frame at the top of the stack represents the execution point at which the stack trace was generated. Typically, this is the point at which the throwable corresponding to the stack trace was created.A stack frame represents the following information:Creates a stack trace element representing the specified execution point.', ''),
(218, 'Statements - Assertion', 'An assertion checks if a condition is true:Each assert statement is ended by a semi-colon (;). However, assertions are disabled by default, so you must run the program with the -ea argument in order for assertions to be enabled (java -ea [name of compiled program]).', ''),
(219, 'Statements - Assignment statements', 'Up until now, weve assumed the creation of variables as a single statement. In essence, we assign a value to those variables, and thats just what it is called. When you assign a value to a variable in a statement, that statement is called an assignment statement (also called an initialization statement). Did you notice one more thing? Its the semicolon (;), which is at the end of each statement. A clear indicator that a line of code is a statement is its termination with an ending semicolon. If one was to write multiple statements, it is usually done on each separate line ending with a semicolon. Consider the example below:You do not necessarily have to use a new line to write each statement. Just like English, you can begin writing the next statement where you ended the first one as depicted below:However, the only problem with putting multiple statements on one line is, its very difficult to read it. It doesnt look that intimidating at first, but once youve got a significant amount of code, its usually better to organize it in a way that makes sense. It would look more complex and incomprehensible written as it is in Listing 3.4.Now that we have looked into the anatomy of a simple assignment statement, we can look back at what weve achieved. We know that...Now, before we move on to the next topic, you need to try and understand what the code below does.The first two statements are pretty much similar to those in Section 3.3 but with different variable names. The third however is a bit interesting. Weve already talked of variables as being similar to gift boxes. Think of your computers memory as a shelf where you put all those boxes. Whenever you need a box (or variable), you call its identifier (thats the name of the variable). So calling the variable identifier firstNumber gives you the number 10, calling secondNumber would give you 20 hence when you add the two up, the answer should be 30. Thats what the value of the last variable result would be. The part of the third statement where you add the numbers, i.e., firstNumber + secondNumber is called an expression and the expression is what decides what the value is to be. If its just a plain value, like in the first two statements, then its called a literal (the value is literally the value, hence the name literal).Note that after the assignment to result its value will not be changed if we assign different values to firstNumber or secondNumber, like in line 4.With the information you have just attained, you can actually write a decent Java program that can sum up values.', ''),
(220, 'Statements - Branching Statements', 'Program flow can be affected using function/method calls, loops and iterations. Of various types of branching constructs, we can easily pick out two generic branching methods.If you look closely at a method, youll see that a method is a named statement block that is executed by calling that particular name. An unconditional branch is created either by invoking the method or by calling break, continue, return or throw, all of which are described below.When a name of a method is encountered in a flow, it stops execution in the current method and branches to the newly called method. After returning a value from the called method, execution picks up at the original method on the line below the method call.The program flow begins in the main method. Just as aMethod is invoked, the flow travels to the called method. At this very point, the flow branches to the other method. Once the method is completed, the flow is returned to the point it left off and resumes at the next statement after the call to the method.', ''),
(221, 'Statements - Iteration Statements', 'Iteration Statements are statements that are used to iterate a block of statements. Such statements are often referred to as loops. Java offers four kinds of iterative statements.The while loop iterates a block of code while the condition it specifies is true.The syntax for the loop is:Here the condition is an expression. An expression as discussed earlier is any statement that returns a value. While condition statements evaluate to a boolean value, that is, either true or false. As long as the condition is true, the loop will iterate the block of code over and over and again. Once the condition evaluates to false, the loop exits to the next statement outside the loop.The do-while loop is functionally similar to the while loop, except the condition is evaluated AFTER the statement executesThe for loop is a specialized while loop whose syntax is designed for easy iteration through a sequence of numbers. Example:The program prints the numbers 0 to 99 and their squares.The same statement in a while loop:The foreach statement allows you to iterate through all the items in a collection, examining each item in turn while still preserving its type. The syntax for the foreach statement is:For an example, well take an array of Strings denoting days in a week and traverse through the collection, examining one item at a time.Notice that the loop automatically exits after the last item in the collection has been examined in the statement block.Although the enhanced for loop can make code much clearer, it cant be used in some common situations.', ''),
(222, 'Statements - Program Control Flow', 'Statements are evaluated in the order as they occur. The execution of flow begins at the top most statement and proceed downwards till the last statement is encountered. A statement can be substituted by a statement block. There are special statements that can redirect the execution flow based on a condition, those statements are called branching statements, described in detail in a later section.', ''),
(223, 'Statements - Return statement', 'A return statement exits from a block, so it is often the last statement of a method:A return statement can return the content of a variable or nothing. Beware not to write statements after a return statement which would not be executed! Each return statement is ended by a semi-colon (;).Conditional branching is attained with the help of the if...else and switch statements. A conditional branch occurs only if a certain condition expression evaluates to true.Also referred to as if statements, these allow a program to perform a test and then take action based on the result of that test.The form of the if statement:The condition is a boolean expression which can be either true or false. The actions performed will depend on the value of the condition.Example:If statements can also be made more complex using the else if combination:Example:If there is only one statement to be executed after the condition, as in the above example, it is possible to omit the curly braces, however Oracles Java Code Conventions explicitly state that the braces should always be used.There is no looping involved in an if statement so once the condition has been evaluated the program will continue with the next instruction after the statement.The if ... else statement is used to conditionally execute one of two blocks of statements, depending on the result of a boolean condition.Example:Oracles Java Code Conventions recommend that the braces should always be used.An if statement has two forms:andUse the second form if you have different statements to execute if the boolean-condition is true or if it is false. Use the first if you only wish to execute statement1 if the condition is true and you do not wish to execute alternate statements if the condition is false.The code section 3.13 calls two int methods, f() and y(), stores the results, then uses an if statement to test if x is less than y and if it is, the statement1 body will swap the values. The end result is x always contains the larger result and y always contains the smaller result.if...else statements also allow for the use of another statement, else if. This statement is used to provide another if statement to the conditional that can only be executed if the others are not true. For example:The else if statement is useful in this case because if one of the conditionals is true, the other must be false. Keep in mind that if one is true, the other will not execute. For example, if the statement at line 2 contained in the first conditional were changed to x = 3;, the second conditional, the else if, would still not execute. However, when dealing with primitive types in conditional statements, it is more desirable to use switch statements rather than multiple else if statements.The switch conditional statement is basically a shorthand version of writing many if...else statements. The syntax for switch statements is as follows:This means that if the variable included equals one of the case results, the statements following that case, until the word break will run. The default case executes if none of the others are true. Note: the only types that can be analysed through switch statements are char, byte, short, or int primitive types. This means that Object variables can not by analyzed through switch statements. However, as of the JDK 7 release, you can use a String object in the expression of a switch statement.In this example, since the integer variable n is equal to 2, case 2 will execute, make x equal to 4. Thus, 4 is returned by the method.', ''),
(224, 'Statements - Statement Blocks', 'A bunch of statements can be placed in braces to be executed as a single block. Such a block of statement can be named or be provided a condition for execution. Below is how youd place a series of statements in a block.', ''),
(225, 'Statements - The continue and break statements', 'At times, you would like to re-iterate a loop without executing the remaining statement within the loop. The continue statement causes the loop to re-iterate and start over from the top most statement inside the loop.Where there is an ability to re-iterate the loop, there is an ability to exit the loop when required. At any given moment, if youd like to exit a loop and end all further work within the loop, the break ought to be used.The continue and break statements can be used with a label like follows:', ''),
(226, 'Statements - Throw statement', 'A throw statement exit from a method and so on and so on or it is caught by a try/catch block. It does not return a variable but an exception:Beware not to write statements after a throw statement which would not be executed too! Each throw statement is ended by a semi-colon (;).', ''),
(227, 'Statements - Variable declaration statement', 'The simplest statement is a variable declaration:It defines a variable that can be used to store values for later use. The first token is the data type of the variable (which type of values this variable can store). The second token is the name of the variable, by which you will be referring to it. Then each declaration statement is ended by a semicolon (;).', ''),
(228, 'Statements', 'Now, that we have the Java platform on our systems and have run the first program successfully, we are geared towards understanding how programs are actually made. As we have already discussed, a program is a set of instructions, which are tasks provided to a computer. These instructions are called statements in Java. Statements can be anything from a single line of code to a complex mathematical equation. Consider the following line:This line is a simple instruction that tells the system to initialize a variable and set its value as 24. If the above statement was the only one in the program, it would look similar to this:Java places its statements within a class declaration and, in the class declaration, the statements are usually placed in the method declaration, as above.', ''),
(229, 'Streams - Input streams', 'Input streams acquire bytes for our programmed java application/program (e.g. a file, an array, a keyboard or monitor, etc.). InputStream is an abstract class that represents a source of byte data. It has a read() method, which returns the next byte in the stream and a close() method, which should be called by a program when that program is done with the stream. The read() method is overloaded, and can take a byte array to read to. It has a skip() method that can skip a number of bytes, and an available() method that a program can use to determine the number of bytes immediately available to be read, as not all the data is necessarily ready immediately. As an abstract class, it cannot be instantiated, but describes the general behavior of an input stream. A few examples of concrete subclasses would be ByteArrayInputStream, which reads from a byte array, and FileInputStream, which reads byte data from a file.In the following example, we print "Hello world!" on the screen several times. The number of times the message is printed is stored in a file named source.txt. This file should only contain a integer and should be placed in the same folder of the ConfiguredApplication class.The close() method is not always mandatory but can avoid some inter-process concurrency conflicts. However if it occurs before a read() or write() (in the same process) they return the warning Stream closed.The class start to identify the filename with a File object. The File object is used by an input stream as the source of the stream. We create a buffer and a character to prepare the data loading. The buffer will contain all the file content and the character will temporary contain each character present in the file, one after one. This is done while{}in the loop. Each iteration of the loop will copy a character from the stream to the buffer. The loop ends when no more character is present in the stream. Then we close the stream. The last part of the code use the data we have loaded in from the file. It is transformed into string and then into an integer (so the data must be an integer). If it works, the integer is used to determine the number of time we print "Hello world!" on the screen. No try/catch block has been defined for readability but the thrown exceptions should be caught.Lets try with the following source file:We should obtain this:There is also Reader which is an abstract class that represents a source of character data. It is analogous to InputStream, except that it deals with characters instead of bytes (remember that Java uses Unicode, so that a character is 2 bytes, not one). Its methods are generally similar to those of InputStream. Concrete subclasses include classes like FileReader, which reads characters from files, and StringReader, which reads characters from strings. You can also convert an InputStream object to a Reader object with the InputStreamReader class, which can be "wrapped around" an InputStream object (by passing it as an argument in its constructor). It uses a character encoding scheme (which can be changed by the programmer) to translate a byte into a 16-bit Unicode character.', ''),
(230, 'Streams - More Info', 'More information on the contents of the java.io package can be viewed on the Oracle website by clicking this link (http://docs.oracle.com/javase/7/docs/api/index.html).', ''),
(231, 'Streams - Output streams', 'Output Streams direct streams of bytes outwards to the environment from our program or application. OutputStream is an abstract class which is the destination counterpart of InputStream. OutputStream has a write() method which can be used to write a byte to the stream. The method is overloaded, and can take an array as well. A close() method closes the stream when the application is finished with it, and it has a flush() method. The stream may wait until it has a certain amount before it writes it all at once for efficiency. If the stream object is buffering any data before writing it, the flush() method will force it to write all of this data. Like InputStream, this class cannot be instantiated, but has concrete subclasses that parallel those of InputStream, eg ByteArrayOutputStream, FileOutputStream, etc.In the following example, we store the current time in an already existing file called log.txt located in the same folder than the class.This case is more simple as we can put all the data in the stream at the same time. The first part of the code generate a string containing the current time. Then we create a File object identifying the output file and an output stream for this file. We write the data in the stream, flush it and close it. Thats all. No try/catch block has been defined for readability but the thrown exceptions should be caught.Now lets execute it:We should obtain this content:There is also Writer which is a character counterpart of OutputStream, and a destination counterpart to Reader, this is also an abstract superclass. Particular implementations parallel those of Reader, eg FileWriter, StringWriter, and OutputStreamWriter, for converting a regular OutputStream into a reader so that it can take character data.', ''),
(232, 'Streams - System.out and System.err', 'System is a class in the package java.lang with a number of static members that are available to Java programs. Two members that are useful for console output are System.out and System.err. Both System.out and System.err are PrintStream objects. PrintStream is a subclass of FilterOutputStream, itself a subclass of OutputStream (discussed above), and its main purpose is to translate a wide variety of data types into streams of bytes that represent that data in characters according to some encoding scheme.System.out and System.err both display text to a console where the user can read it, however what this means exactly depends on the platform used and the environment in which the program is running. In BlueJay and Eclipse IDE, for example, there is a special "terminal" window that will display this output. If the program is launched in Windows, the output will be sent to the DOS prompt (usually this means that you have to launch the program from the command line to see the output).System.out and System.err differ in what theyre supposed to be used for. System.out should be used for normal program output, System.err should be used to inform the user that some kind of error has occurred in the program. In some situations, this may be important. In DOS, for instance, a user can redirect standard output to some other destination (a file, for example), but error output will not be redirected, but rather displayed on the screen. If this werent the case, the user might never be able to tell that an error had occurred.', ''),
(233, 'Streams', 'The most basic input and output in Java (System.in and System.out fields that have been used in the Basic I/O) is done using streams. Streams are objects that represent sources and destinations of data. Streams that are sources of data can be read from, and streams that are destinations of data can be written to. A stream in Java is an ordered sequence of bytes of undetermined length. Streams are ordered and in sequence so that the java virtual machine can understand and work upon the stream. Streams are analogous to water streams. They exist as a communication medium, just like electromagnetic waves in communication. The order or sequence of bytes in a Java stream allow the virtual machine to classify it among other streams.Java has various inbuilt streams implemented as classes in the package java.io like the classes of System.in and System.out. Streams can be classed as both input and output streams. All Java streams are derived from Input Stream (java.io.InputStream) and Output Stream (java.io.OutputStream) classes. They are abstract base classes meant for other stream classes. The System.in is the input stream class derivative and analogically System.out is the output counterpart. Both are basic classes used to directly interact with input and output through console, similarly follows System.err. Also Java has streams to communicate across different parts of a program or even among threads. There are also classes that "filter" streams, changing one format to another (e.g. class DataOutputStream, which translates various primitive types to byte streams).It is a characteristic of streams that they deal only in one discrete unit of data at a time, and different streams deal with different types of data. If one had a stream that represented a destination for bytes, for example, one would send data to the destination one byte at a time. If a stream was a source of byte data, one would read the data a byte at a time. Because this is the only way to access data from a stream, in this latter case, we wouldnt know when we had read all the data from the stream until we actually got there. When reading a stream, one generally has to check each unit of data each read operation to see if the end of the stream has been reached (with byte streams, the special value is the integer -1, or FFFF hex).', ''),
(234, 'String - Comparing Strings', 'Comparing strings is not as easy as it may first seem. Be aware of what you are doing when comparing Strings using ==:The difference between the above and below code is that the above code checks to see if the Strings are the same objects in memory which they are. This is as a result of the fact that Strings are stored in a place in memory called the String Constant Pool. If the new keyword is not explicitly used when creating the String it checks to see if it already exists in the Pool and uses the existing one. If it does not exist, a new Object is created. This is what allows Strings to be immutable in Java. To test for equality, use the equals(Object) method inherited by every class and defined by String to return true if and only if the object passed in is a String containing the exact same data:Remember that the comparison is case sensitive.To order String objects, use the compareTo() method, which can be accessed wherever we use a String datatype. The compareTo() method returns a negative, zero, or positive number if the parameter is less than, equal to, or greater than the object on which it is called. Lets take a look at an example:The code section 3.92 is comparing the String variable person1 to person2. If person1 was to be different, even in the slightest manner we will get a value above or below 0 depending on the exact difference. The result is negative if this String object lexicographically precedes the argument string. The result is a positive integer if this String object lexicographically follows the argument string. Take a look at the Java API for more details.', ''),
(235, 'String - Concatenation', 'The Java language provides special support for the string concatenation with operator +:The concatenation is not always processed at the same time. Raw string literals concatenation is done at compile time, hence there is a single string literal in the byte code of the class. Concatenation with at least one object is done at runtime.+ operator can concatenate other objects with strings. For instance, integers will be converted to strings before the concatenation:Each Java object has the String toString() inherited from the Object class. This method provides a way to convert objects into Strings. Most classes override the default behavior to provide more specific (and more useful) data in the returned String:', ''),
(236, 'String - Immutability', 'Strings are immutable; that is, they cannot be modified once created. Whenever it looks as if a String object was modified actually a new String object was created. For instance, the String.trim() method returns the string with leading and trailing whitespace removed. Actually, it creates a new trimmed string and then returns it. Pay attention on what happens in Code section 3.82:The trim() method call does not modify the object so nothing happens. It creates a new trimmed string and then throws it away.The returned string is assigned to the variable. It does the job as the trim() method has created a new String instance.', ''),
(237, 'String - Splitting a String', 'Sometimes it is useful to split a string into separate strings, based on a regular expressions. The String class has a split() method, since Java 1.4, that will return a String array:Another useful application could be to split the String text based on the new line character, so you could process the text line by line.', ''),
(238, 'String - String cases', 'The String class also allows for the modification of cases. The two methods that make this possible are toLowerCase() and toUpperCase().These methods are useful to do a search which is not case sensitive:', ''),
(239, 'String - Substrings', 'It may also be sometimes useful to create substrings, or strings using the order of letters from an existing string. This can be done in two methods.The first method involves creating a substring out of the characters of a string from a given index to the end:The index of the first character in a string is 0.By counting from there, it is apparent that the character in index 3 is the second "f" in "coffee". This is known as the beginIndex. All characters from the beginIndex until the end of the string will be copied into the new substring.The second method involves a user-defined beginIndex and endIndex:The string returned by substring() would be "port".Please note that the endIndex is not inclusive. This means that the last character will be of the index endIndex-1. Therefore, in this example, every character from index 3 to index 6, inclusive, was copied into the substring.', ''),
(240, 'String', 'String is a class built into the Java language defined in the java.lang package. It represents character strings. Strings are ubiquitous in Java. Study the String class and its methods carefully. It will serve you well to know how to manipulate them skillfully. String literals in Java programs, such as "abc", are implemented as instances of this class like this:On the right hand side a String object is created represented by the string literal. Its object reference is assigned to the str variable.', ''),
(241, 'The Java platform - Java Development Kit (JDK)', 'The JRE takes care of running the Java code on multiple platforms, however as developers, we are interested in writing pure code in Java which can then be converted into Java byte-code for mass deployment. As developers, we do not need to write Java byte-code, rather we write the code in the Java programming language (which is quite similar to writing C or C++ code).Upon downloading the JDK, a developer ensures that their system has the appropriate JRE and additional tools to help with the development of applications in the Java programming language. Java code can be found in files with the extension .java. These files are called Java source files. In order to convert the Java code in these source files to Java byte-code, you need to use the Java compiler tool installed with your JDK.The Java compiler tool (named javac in the JDK) is the most important utility found with the JDK. In order to compile a Java source file (say, SomeApplication.java) to its respective Java byte-code, you would need to use the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):This command would convert the SomeApplication.java source file into its equivalent Java byte-code. The resultant byte-code would exist in a newly created file named SomeApplication.class. This process of converting Java source files into their equivalent byte-codes is known as compilation.In most modern operating systems, a large body of reusable code is provided to simplify the programmers job. This code is typically provided as a set of dynamically loadable libraries that applications can call at runtime. Because the Java platform is not dependent on any specific operating system, applications cannot rely on any of the existing libraries. Instead, the Java platform provides a comprehensive set of standard class libraries, containing much of the same reusable functions commonly found in modern operating systems.The Java class libraries serve three purposes within the Java platform. Like other standard code libraries, they provide the programmer with a well-known set of functions to perform common tasks, such as maintaining lists of items or performing complex string parsing. In addition, the class libraries provide an abstract interface to tasks that would normally depend heavily on the hardware and operating system. Tasks such as network access and file access are often heavily dependent on the native capabilities of the platform. The Java java.net and java.io libraries implement the required native code internally, then provide a standard interface for the Java applications to perform those tasks. Finally, some underlying platforms may not support all of the features a Java application expects. In these cases, the class libraries can either emulate those features using whatever is available, or provide a consistent way to check for the presence of a specific feature.', ''),
(242, 'The Java platform - Java Runtime Environment (JRE)', 'Any piece of code written in the Java programming language can be run on any operating system, platform or architecture in fact, it can be run on any device that supports the Java platform. Before Java, this amount of ubiquity was very hard to achieve. If a software was written for a Unix-based system, it was impossible to run the same application on a Windows system in this case, the application was native only to Unix-based systems.A major milestone in the development of the Java programming language was to develop a special runtime environment that would execute any Java application independent of the computers operating system, platform or architecture.The Java Runtime Environment (JRE) sits on top of the machines operating system, platform and architecture. If and when a Java application is run, the JRE acts as a liaison between the underlying platform and that application. It interprets the Java application to run in accordance with the underlying platform, such that upon running the application, it looks and behaves like a native application. The part of the JRE that accomplishes this complex liaison agreement is called the Java Virtual Machine (JVM).Native Java applications are preserved in a special format called the byte-code. Byte-code remains the same, no matter what hardware architecture, operating system, or software platform it is running under. On a file-system, Java byte-code resides in files that have the .class (also known as a class file) or the .jar (also known as a Java archive) extension. To run byte-code, the JRE comes with a special tool (appropriately named java).Suppose your byte-code is called SomeApplication.class. If you want to execute this Java byte-code, you would need to use the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):If you want to execute a Java byte-code with a .jar extension (say, SomeApplication.jar), you would need to use the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):Most computers come with a pre-installed copy of the JRE. If your computer doesnt have a JRE, then the above commands would not work. You can always check what version of the JRE is installed on the computer by writing the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):Quite possibly, the most important part of the JRE is the Java Virtual Machine (JVM). The JVM acts like a virtual processor, enabling Java applications to be run on the local system. Its main purpose is to interpret (read translate) the received byte-code and make it appear as native code. The older Java architecture used this process of interpretation to execute Java byte-code. Even though the process of interpretation brought the WORA principle to diverse machines, it had a drawback it consumed a lot of time and clocked the system processor intensively to load an application.Since version 1.2, the JRE features a more robust JVM. Instead of interpreting byte-code, it down-right converts the code straight into equivalent native code for the local system. This process of conversion is called just-in-time compilation or JIT-compilation. This process only occurs when the byte-code is executed for the first time. Unless the byte-code itself is changed, the JVM uses the compiled version of the byte-code on every successive execution. Doing so saves a lot of time and processor effort, allowing applications to execute much faster at the cost of a small delay on first execution.The JVM is an intelligent virtual processor. It has the ability to identify areas within the Java code itself that can be optimized for faster and better performance. Based on every successive run of your Java applications, the JVM would optimize it to run even better.Java was not the first virtual-machine-based platform, though it is by far the most successful and well-known. Previous uses for virtual machine technology primarily involved emulators to aid development for not-yet-developed hardware or operating systems, but the JVM was designed to be implemented ent', ''),
(243, 'The Java platform - Java Runtime Environment (JRE)', 'irely in software, while making it easy to efficiently port an implementation to hardware of all kinds.', ''),
(244, 'The Java platform - Similar concepts', 'The success of the Java platform and the concepts of the write once, run anywhere principle has led to the development of similar frameworks and platforms. Most notable of these is the Microsofts .NET framework and its open-source equivalent Mono.The .NET framework borrows many of the concepts and innovations of Java their alternative for the JVM is called the Common Language Runtime (CLR), while their alternative for the byte-code is the Common Intermediate Language (CIL). In fact, the .NET platform had an implementation of a Java-like language called Visual J# (formerly known as J++).J# is normally not supported with the JVM because instead of compiling it in Java byte-code, the .NET platform compiles the code into CIL, thus making J# different from the Java programming language. Furthermore, because J# implements the .NET Base Class Libraries (BCL) instead of the Java Class Libraries, J# is nothing more than a non-standard extension of the Java programming language. Due to the lack of interest from developers, Microsoft had to withdraw their support for J#, and focused on a similar programming language: C#.The word Java, by itself, usually refers to the Java programming language which was designed for use with the Java platform. Programming languages are typically outside of the scope of the phrase "platform". However, Oracle does not encourage the use of any other languages with the platform, and lists the Java programming language as a core part of the Java 2 platform. The language and runtime are therefore commonly considered a single unit.There are cases where you might want to program using a different language (say, Python) and yet be able to generate Java byte-code (instead of the Python compiled code) to be run with the JVM. Many third-party programming language vendors provide compilers that can compile code written in their language to Java byte-code. For instance, Python developers can use Jython compilers to compile Python code to the Java byte-code format (as illustrated below).', ''),
(245, 'The Java platform - Similar concepts', 'Of late, JVM-targeted third-party programming and scripting languages have seen tremendous growth. Some of these languages are also used to extend the functionalities of the Java language itself. A few examples include the following:', ''),
(246, 'The Java platform', 'The Java platform is the name given to the computing platform from Oracle that helps users to run and develop Java applications. The platform does not just enable a user to run and develop a Java application, but also features a wide variety of tools that can help developers work efficiently with the Java programming language.The platform consists of two essential softwares:In this section, we would explore in further detail what these two software components of the Java platform do.', ''),
(247, 'Threads and Runnables - Manipulating threads', 'It can be said that the execution order of the threads was manipulated to some degree using the Thread.sleep(...) method. The Thread class has such static methods that can arguably affect the execution order and manipulation of threads. Below are some useful static methods in the Thread class. These methods when called will only affect the currently running threads.', ''),
(248, 'Threads and Runnables - References', 'Daemon thread tutorial', ''),
(249, 'Threads and Runnables - Synchronization', 'Given below is an example of creating and running multiple threads that behave in a synchronous manner such that when one thread is using a particular resource, the others wait until the resource has been released. We will talk more about this in later sections.', ''),
(250, 'Threads and Runnables - Threads', 'In light of the above discussion, a thread is the smallest unit of processing that can be scheduled by an operating system. Therefore, using threads, a programmer can effectively create two or more tasks[1] that run at the same time. The first call-to-action is to implement a set of tasks that a particular thread would execute. To do so, we require the creation of a Runnable process.A Runnable process block is a simple class that implements a run() method. Within the run() method is the actual task that needs to be executed by a running thread. By implementing a class with the Runnable interface, we ensure that the class holds a run() method. Consider the following program:In the above code, we create a class called RunnableProcess and implement the Runnable interface to ensure that we have a run() method in the class declaration.We then declare the rest of the logic for the class. For the constructor, we take a String parameter that would serve as the name of the class. Then, we initialize the class member variable time with a random number between 0 and 999. To ensure the initialization of a random number, we use the Random class in the java.util package.The actual task that would be executed per this runnable block is presented within the run() method. To keep safe from exceptions occurring because of the concurrent programming, we wrap the code within this method with a try..catch block. The executing task actually consists of just three statements. The first outputs the provided name for the Runnable process, and the last reports that the thread has executed. Perhaps the most intriguing part of the code is the second statement: Thread.sleep(...).This statement allows the thread executing the current runnable block to halt its execution for the given amount of time. This time is presented in milliseconds. But for our convenience, this time would be the random number generated in the constructor and can be anywhere between 0 and 999 milliseconds. We will explore this in a later section. Creating a Runnable process block is just the beginning. No code is actually executed. To do so, we would require the creation of threads that would then individually execute this task.Once we have a Runnable process block, we can create various threads that can then execute the logic encased within such blocks. Multithreading capabilities in Java are utilized and manipulated using the Thread class. A Thread object therefore holds all the necessary logic and devices to create truly multithreaded programs. Consider the following program:Creating threads is as simple as the above program suggests. You just have to create an object of the Thread class and pass a reference to a Runnable process object. In the case above, we present the Thread constructor with the class object for the RunnableProcess class that we created in code listing 1. But for each object, we give a different name (i.e., "Thread-1" and "Thread-2", etc.) to differentiate between the three Thread objects. The above example only declares Thread objects and hasnt yet started them for execution.Now, that we know how to effectively create a Runnable process block and a Thread object that executes it, we need to understand how to start the created Thread objects. This couldnt be simpler. For this process, we will be calling the start() method on the Thread objects and voil, our threads will begin executing their individual process tasks.The above code will start all three declared threads. This way, all three threads will begin their execution one-by-one. However, this being concurrent programming and us having declared random times for the halting of the execution, the outputs for every one of us would differ. Following is the output we received when we executed the above program.It should be noted that the execution of the Thread didnt occur in the desired order. Instead of the order t1t2t3, the threads executed in the order of t1t3t2. The order in which the threads are executed is completely dependant on the operating system and may change for every execution of the pr', ''),
(251, 'Threads and Runnables - Threads', 'ogram, thus making output of multithreaded application difficult to predict and control. Some people suggest that this is the major reason that adds to the complexity of multithreaded programming and its debugging. However, it should be observed that once the threads were put to sleep using the Thread.sleep(...) function, the execution intervals and order can be predicted quite capably. The thread with the least amount of sleeping time was t2 ("Thread-2") with 189 milliseconds of sleep hence it got called first. Then t1 was called and finally t3 was called.', ''),
(252, 'Threads and Runnables', 'CPUs for any computer are designed to execute one task at any given time, yet we run multiple applications side-by-side and everything works in perfect congruence. Its not just because CPUs are extremely fast in performing calculations, its because CPUs use a clever device of dividing their time amongst various tasks. Each application or task that is invoked on a computer gets associated with the CPU in the form of a process. A CPU therefore manages various processes, and jumps back and forth amongst each process giving it a fraction of its time and processing capability. This happens so fast that to a normal computer user it presents with the illusion of processes being run simultaneously. This capability of the CPU to divide its time amongst processes is called multitasking.So, if we run a Java application on a computer, we are effectively creating a process with the CPU that gets a fraction of the CPUs time. In Java parlance, this main process gets called the daemon process or the daemon thread. But, Java goes one step further. It allows programmers to divide this daemon thread into several multiple threads which get executed simultaneously (much like a CPU) hence providing a Java application with a finer multitasking capability called multithreading.In this section, we will take a look at what threads are and how multithreading is implemented within a Java program to make it appear congruent and effectively fast to respond.', '');
INSERT INTO `textbook` (`textid`, `topic`, `content`, `code`) VALUES
(253, 'Throwing and Catching Exceptions - catch blocks', 'A try/catch statement can contain several catch blocks, to handle different exceptions in different ways. Each catch block must take a parameter of a different throwable class. A thrown object may match several catch block but only the first catch block that matches the object will be executed. A catch-block will catch a thrown exception if and only if:This means that the catch block order is important. As a consequence, you cant put a catch block that catches all the exception (which take a java.lang.Exception as parameter) before a catch block that catches a more specific exception as the second block could never be executed.At line 14, we use a multi-catch clause. It is available since the JDK 7. This is a combination of several catch clauses and lets you handle exceptions in a single handler while also maintaining their types. So, instead of being boxed into a parent Exception super-class, they retain their individual types.You can also use the java.lang.Throwable class here, since Throwable is the parent class for the application-specific Exception classes. However, this is discouraged in Java programming circles. This is because Throwable happens to also be the parent class for the non-application specific Error classes which are not meant to be handled explicitly as they are catered for by the JVM itself.', ''),
(254, 'Throwing and Catching Exceptions - Example of handling exceptions', 'Lets examine the following code:In the code section 6.7, methodC is invalid. Because methodA and methodB pass (or throw) exceptions, methodC must be prepared to handle them. This can be handled in two ways: a try-catch block, which will handle the exception within the method and a throws clause which would in turn throw the exception to the caller to handle. The above example will cause a compilation error, as Java is very strict about exception handling. So the programmer is forced to handle any possible error condition at some point.A method can do two things with an exception: ask the calling method to handle it by the throws declaration or handle the exception inside the method by the try-catch block.To work correctly, the original code can be modified in multiple ways. For example, the following:The AnotherException from methodB will be handled locally, while CustomException and SomeException will be thrown to the caller to handle it. Most of the developers are embarrassed when they have to choose between the two options. This type of decision should not be taken at development time. If you are a development team, it should be discussed between all the developers in order to have a common exception handling policy.', ''),
(255, 'Throwing and Catching Exceptions - Exception object', 'The preceding exception could have been created explicitly by the developer as it is the case in the following code:Note that when b equals zero, there is no return value. Instead of a java.lang.ArithmeticException generated by the Java interpreter itself, it is an exception created by the coder. The result is the same. It shows you that an exception is an object. Its main particularity is that it can be thrown. An exception object must inherit from java.lang.Exception. Standard exceptions have two constructors:This string can later be extracted using various methods, as you can see in the code listing 6.2.You can throw any type of Throwable object using the keyword throw. It interrupts the method. Anything after the throw statement would not be executed, unless the thrown exception is handled. The exception object is not returned from the method, it is thrown from the method. That means that the exception object is not the return value of the method and the calling method can be interrupted too and so on and so on...Typically, youll throw a different class of exception for each different type of error. The information about the error is represented both inside the exception object and implicitly in the name of the exception class, so someone in the bigger context can figure out what to do with your exception. Often, the only information is the type of exception, and nothing meaningful is stored within the exception object.The box 6.1 below talks about the various exception classes within the java.lang package.', ''),
(256, 'Throwing and Catching Exceptions - finally block', 'A finally block can be added after the catch blocks. A finally block is always executed, even when no exception is thrown, an exception is thrown and caught, or an exception is thrown and not caught. Its a place to put code that should always be executed after an unsafe operation like a file close or a database disconnection. You can define a try block without catch block, however, in this case, it must be followed by a finally block.', ''),
(257, 'Throwing and Catching Exceptions', 'Language compilers are adept at pointing out most of the erroneous code in a program, however there are some errors that only become apparent when the program is executed. Consider the code listing 6.1; here, the program defines a method divide that does a simple division operation taking two integers as parameter arguments and returning the result of their division. It can safely be assumed that when the divide(4, 2) statement is called, it would return the number 2. However, consider the next statement, where the program relies upon the provided command line arguments to generate a division operation. What if the user provides the number zero (0) as the second argument? We all know that division by zero is impossible, but the compiler couldnt possibly have anticipated the user providing zero as an argument.Such exceptional code that results in erroneous interpretations at program runtime usually results in errors that are called exceptions in Java. When the Java interpreter encounters an exceptional code, it halts execution and displays information about the error that occurs. This information is known as a stack trace. The stack trace in the above example tells us more about the error, such as the thread "main" where the exception occurred, the type of exception java.lang.ArithmeticException, a comprehensible display message / by zero, and the exact methods and the line numbers where the exception may have occurred.', ''),
(258, 'Unchecked Exceptions', 'Unchecked, uncaught or runtime exceptions are exceptions that are not required to be caught or declared, even if it is allowed to do so. So a method can throw a runtime exception, even if this method is not supposed to throw exceptions. For example, ConcurrentModificationException is an unchecked exception.The unchecked exceptions can only be the RuntimeException and its subclasses, and the class Error and its subclasses. All other exception classes must be handled, otherwise the compiler gives an error.Sometime it is desirable to catch all exception for logging purposes, then throw it back on. For example, in servlet programming when application server calls the server doPost(), we want to monitor that no exception even runtime exception happened during serving the request. The application has its own logging separate from the server logging. The runtime exceptions would just go through without detecting it by the application. The following code would check all exceptions, log them, and throw it back again.In the above code, all business logic exception are handled in the handleRequest() method. Runtime exceptions are caught for logging purposes, and then thrown back to the server to handle it.Runtime exceptions are usually caused by data errors, like arithmetic overflow, divide by zero, ... . Runtime exceptions are not business related exceptions. In a well debugged code, runtime exceptions should not occur. Runtime exceptions should only be used in the case that the exception could be thrown by and only by something hard-coded into the program. These should not be able to be triggered by the softwares user(s).', ''),
(259, 'Understanding a Java Program - Detailed Program Structure and Overview', 'As promised, we will now provide a detailed description of this Java program. We will discuss the syntax and structure of the program and the meaning of that structure.The syntax of a Java class is the characters, symbols and their structure used to code the class. Java programs consist of a sequence of tokens. There are different kinds of tokens. For example, there are word tokens such as class and public which represent keywords (in purple above) special words with reserved meaning in Java. Other words such as Distance, point0, x1, and printDistance are not keywords but identifiers (in grey). Identifiers have many different uses in Java but primarily they are used as names. Java also has tokens to represent numbers, such as 1 and 3; these are known as literals (in orange). String literals (in blue), such as "Distance between ", consist of zero or more characters embedded in double quotes, and operators (in red) such as + and = are used to express basic computation such as addition or String concatenation or assignment. There are also left and right braces ({ and }) which enclose blocks. The body of a class is one such block. Some tokens are punctuation, such as periods . and commas , and semicolons ;. You use whitespace such as spaces, tabs, and newlines, to separate tokens. For example, whitespace is required between keywords and identifiers: publicstatic is a single identifier with twelve characters, not two Java keywords.Sequences of tokens are used to construct the next building blocks of Java classes as shown above: declarations and definitions. A class declaration provides the name and visibility of a class. In our example, public class Distance is the class declaration. It consists (in this case) of two keywords, public and class followed by the identifier Distance.This means that we are defining a class named Distance. Other classes, or in our case, the command line, can refer to the class by this name. The public keyword is an access modifier which declares that this class and its members may be accessed from other classes. The class keyword, obviously, identifies this declaration as a class. Java also allows declarations of interfaces and annotations.The class declaration is then followed by a block (surrounded by curly braces) which provides the classs definition (in blue in figure 2.2). The definition is the implementation of the class the declaration and definitions of the classs members. This class contains exactly six members, which we will explain in turn.The declaration...declares two instance fields. Instance fields represent named values that are allocated whenever an instance of the class is constructed. When a Java program creates a Distance instance, that instance will contain space for point0 and point1. When another Distance object is created, it will contain space for its own point0 and point1 values. The value of point0 in the first Distance object can vary independently of the value of point0 in the second Distance object.This declaration consists of:', ''),
(260, 'Understanding a Java Program - Detailed Program Structure and Overview', 'These two fields could also have been declared with two separate but more verbose declarations,Since the type of these fields is a reference type (i.e. a field that refers to or can hold a reference to an object value), Java will implicitly initialize the values of point0 and point1 to null when a Distance instance is created. The null value means that a reference value does not refer to an object. The special Java literal null is used to represent the null value in a program. While you can explicitly assign null values in a declaration, as inIt is not necessary and most programmers omit such default assignments.A constructor is a special method in a class which is used to construct an instance of the class. The constructor can perform initialization for the object, beyond that which the Java VM does automatically. For example, Java will automatically initialize the fields point0 and point1 to null.The constructor above consists of five parts:This constructor accepts four parameters, named x0, y0, x1 and y1. Each parameter requires a parameter type declaration, which in this example is int for all four parameters. The parameters in the parameter list are separated by commas.The two assignments in this constructor use Javas new operator to allocate two java.awt.Point objects. The first allocates an object representing the first point, (x0, y0), and assigns it to the point0 instance variable (replacing the null value that the instance variable was initialized to). The second statement allocates a second java.awt.Point instance with (x1, y1) and assigns it to the point1 instance variable.This is the constructor for the Distance class. Distance implicitly extends from java.lang.Object. Java inserts a call to the super constructor as the first executable statement of the constructor if there is not one explicitly coded. The above constructor body is equivalent to the following body with the explicit super constructor call:While it is true that this class could be implemented in other ways, such as simply storing the coordinates of the two points and computing the distance as , this class instead uses the existing java.awt.Point class. This choice matches the abstract definition of this class: to print the distance between two points on the plane. We take advantage of existing behavior already implemented in the Java platform rather than implementing it again. We will see later how to make the program more flexible without adding much complexity, because we choose to use object abstractions here. However, the key point is that this class uses information hiding. That is, how the class stores its state or how it computes the distance is hidden. We can change this implementation without altering how clients use and invoke the class.Methods are the third and most important type of class member. This class contains three methods in which the behavior of the Distance class is defined: printDistance(), main(), and intValue()The printDistance() method prints the distance between the two points to the standard output (normally the console).This instance method executes within the context of an implicit Distance object. The instance field references, point0 and point1, refer to instance fields of that implicit object. You can also use the special variable this to explicitly reference the current object. Within an instance method, Java binds the name this to the object on which the method is executing, and the type of this is that of the current class. The body of the printDistance method could also be coded asto make the instance field references more explicit.This method both computes the distance and prints it in one statement. The distance is computed with point0.distance(point1); distance() is an instance method of the java.awt.Point class (of which point0 and point1 are instances). The method operates on point0 (binding this to the object that point0 refers to during the execution of the method) and accepting another Point as a parameter. Actually, it is slightly more complicated than that, but well explain later. The result of', ''),
(261, 'Understanding a Java Program - Detailed Program Structure and Overview', 'the distance() method is a double precision floating point number.This method uses the syntaxto construct a String to pass to the System.out.println(). This expression is a series of String concatenation methods which concatenates Strings or the String representation of primitive types (such as doubles) or objects, and returns a long string. For example, the result of this expression for the points (0,3) and (4,0) is the Stringwhich the method then prints to System.out.In order to print, we invoke the println(). This is an instance method from java.io.PrintStream, which is the type of the static field out in the class java.lang.System. The Java VM binds System.out to the standard output stream when it starts a program.The main() method is the main entry point which Java invokes when you start a Java program from the command line. The commandinstructs Java to locate the Distance class, put the four command line arguments into an array of String values, then pass those arguments to the public static main(String[]) method of the class. We will introduce arrays shortly. Any Java class that you want to invoke from the command line or desktop shortcut must have a main method with this signature or the following signature: public static main(String...).The main() method invokes the final method, intValue(), four times. The intValue() takes a single string parameter and returns the integer value represented in the string. For example, intValue("3") will return the integer 3.People who do test-first programming or perform regression testing write a main() method in every Java class, and a main() function in every Python module, to run automated tests. When a person executes the file directly, the main() method executes and runs the automated tests for that file. When a person executes some other Java file that in turn imports many other Java classes, only one main() method is executed -- the main() method of the directly-executed file.The intValue() method delegates its job to the Integer.parseInt() method. The main method could have called Integer.parseInt() directly; the intValue() method simply makes the main() method slightly more readable.This method is private since, like the fields point0 and point1, it is part of the internal implementation of the class and is not part of the external programming interface of the Distance class.Both the main() and intValue() methods are static methods. The static keyword tells the compiler to create a single memory space associated with the class. Each individual object instantiated has its own private state variables and methods but use the same static methods and members common to the single class object created by the compiler when the first class object is instantiated or created. This means that the method executes in a static or non-object context there is no implicit separate instance available when the static methods run from various objects, and the special variable this is not available. As such, static methods cannot access instance methods or instance fields (such as printDistance()) or point0) directly. The main() method can only invoke the instance method printDistance() method via an instance reference such as dist.Most declarations have a data type. Java has several categories of data types: reference types, primitive types, array types, and a special type, void.The primitive types are used to represent boolean, character, and numeric values. This program uses only one primitive type explicitly, int, which represents 32 bit signed integer values. The program also implicitly uses double, which is the return type of the distance() method of java.awt.Point. double values are 64 bit IEEE floating point values. The main() method uses integer values 0, 1, 2, and 3 to access elements of the command line arguments. The Distance() constructors four parameters also have the type int. Also, the intValue() method has a return type of int. This means a call to that method, such as intValue(args[0]), is an expression of type int. This helps explain why the main method cannot call:Si', ''),
(262, 'Understanding a Java Program - Detailed Program Structure and Overview', 'nce the type of the args array element is String, and our constructors parameters must be int, such a call would result in an error because Java will not automatically convert values of type String into int values.Javas primitive types are boolean, byte, char, short, int, long, float and double. Each of which are also Java language keywords.In addition to primitive types, Java supports reference type. A reference type is a Java data type which is defined by a Java class or interface. Reference types derive this name because such values refer to an object or contain a reference to an object. The idea is similar to pointers in other languages like C.Java represents sequences of character data, or String, with the reference type java.lang.String which is most commonly referred to as String. String literals, such as "Distance between " are constants whose type is String.This program uses three separate reference types:Java supports arrays, which are aggregate types which have a fixed element type (which can be any Java type) and an integral size. This program uses only one array, String[] args. This indicates that args has an array type and that the element type is String. The Java VM constructs and initializes the array that is passed to the main method. See arrays for more details on how to create arrays and access their size.The elements of arrays are accessed with integer indices. The first element of an array is always element 0. This program accesses the first four elements of the args array explicitly with the indices 0, 1, 2, and 3. This program does not perform any input validation, such as verifying that the user passed at least four arguments to the program. We will fix that later.void is not a type in Java; it represents the absence of a type. Methods which do not return values are declared as void methods.This class defines two void methods:', ''),
(263, 'Understanding a Java Program - Indentation', 'Java ignores all whitespace in front of a statement. As this, these two code snippets are identical for the compiler:However, the first ones style (with whitespace) is preferred, as the readability is higher. The method body is easier to distinguish from the head, even at a higher reading speed.', ''),
(264, 'Understanding a Java Program - Whitespace', 'Whitespace in Java is used to separate the tokens in a Java source file. Whitespace is required in some places, such as between access modifiers, type names and Identifiers, and is used to improve readability elsewhere.Wherever whitespace is required in Java, one or more whitespace characters may be used. Wherever whitespace is optional in Java, zero or more whitespace characters may be used.Java whitespace consists of theLine separators are special whitespace characters in that they also terminate line comments, whereas normal whitespace does not.Other Unicode space characters, including vertical tab, are not allowed as whitespace in Java.Look at the static method intValue:Whitespace is required between private and static, between static and int, between int and intValue, and between String and data.If the code is written like this:...it means something completely different: it declares a method which has the return type privatestaticint It is unlikely that this type exists and the method is no longer static, so the above would result in a semantic error.', ''),
(265, 'Understanding a Java Program', 'This article presents a small Java program which can be run from the console. It computes the distance between two points on a plane. You do not need to understand the structure and meaning of the program just yet; we will get to that soon. Also, because the program is intended as a simple introduction, it has some room for improvement, and later in the module we will show some of these improvements. But lets not get too far ahead of ourselves!', ''),
(266, 'Unicode - International language support', 'The language distinguishes between bytes and characters. Characters are stored internally using UCS-2, although as of J2SE 5.0, the language also supports using UTF-16 and its surrogates. Java program source may therefore contain any Unicode character.The following is thus perfectly valid Java code; it contains Chinese characters in the class and variable names as well as in a string literal:', ''),
(267, 'Unicode - Unicode escape sequences', 'Unicode characters can also be expressed through Unicode Escape Sequences. Unicode escape sequence may appear anywhere in a Java source file (including inside identifiers, comments, and string literals).Unicode escape sequences consist ofSuch sequences represent the UTF-16 encoding of a Unicode character. For example, a is equivalent to u0061. This escape method does not support characters beyond U+FFFF or you have to make use of surrogate pairs.[1]Any and all characters in a program may be expressed in Unicode escape characters, but such programs are not very readable, except by the Java compiler - in addition, they are not very compact.One can find a full list of the characters here. may also be represented in Java as the Unicode escape sequence u03C0. Thus, the following is a valid, but not very readable, declaration and assignment:The following demonstrates the use of Unicode escape sequences in other Java syntax:Note that a Unicode escape sequence functions just like any other character in the source code. E.g., u0022 (double quote, ") needs to be quoted in a string just like ".', ''),
(268, 'Unicode', 'Most Java program text consists of ASCII characters, but any Unicode character can be used as part of identifier names, in comments, and in character and string literals. For example, (which is the Greek Lowercase Letter pi) is a valid Java identifier:and in a string literal:', ''),
(269, 'Variables - Assigning values to variables', 'Because we have provided a data type for the variable, we have a hint as to what the variable can and cannot hold. We know that int (integer) data type supports numbers that are either positive or negative integers. Therefore once a variable is created, we can provide it with any integer value using the following syntax. This process is called an assignment operation.Java provides programmers with a simpler way of combining both variable declaration and assignment operation in one line. Consider the following code:', ''),
(270, 'Variables - Creating variables', 'Variables and all the information they store are kept in the computers memory for access. Think of a computers memory as a table of data where each cell corresponds to a variable.Upon creating a variable, we basically create a new address space and give it a unique name. Java goes one step further and lets you define what you can place within the variable in Java parlance you call this a data type. So, you essentially have to do two things in order to create a variable:The following code demonstrates how a simple variable can be created. This process is known as variable declaration.', ''),
(271, 'Variables - Grouping variable declarations and assignment operations', 'Consider the following code:There are various ways by which you can streamline the writing of this code. You can group the declarations of similar data types in one statement, for instance:Alternatively, you can further reduce the syntax by doing group declarations and assignments together, as such:', ''),
(272, 'Variables - Identifiers', 'Although memory spaces have their own addresses usually a hash number such as 0xCAD3, etc. it is much easier to remember a variables location in the memory if we can give it a recognizable name. Identifiers are the names we give to our variables. You can name your variable anything like aVariable, someVariable, age, someonesImportantData, etcetera. But notice: none of the names we described here has a space within it. Hence, it is pretty obvious that spaces arent allowed in variable names. In fact, there are a lot of other things that are not allowed in variable names. The things that are allowed are:Any valid variable names might be correct but they are not always what you should be naming your variables for a few reasons as listed below:', ''),
(273, 'Variables - Kinds of variables', 'In the Java programming language, there are four kinds of variables.In the code listing 3.9, are examples of all four kinds of variables.', ''),
(274, 'Variables - Literals (values)', 'Now that we know how variables should be named, let us look at the values of those variables. Simple values like numbers are called literals. This section shows you what literals are and how to use them. Consider the following code:By now, weve only seen how numbers work in assignment statements. Lets look at data types other than numbers. Characters are basically letters of the English alphabet. When writing a single character, we use single quotes to encapsulate them. Take a look at the code below:Why, you ask? Well, the explanation is simple. If written without quotes, the system would think its a variable identifier. Thats the very distinction you have to make when differentiating between variables and their literal values. Character data types are a bit unusual. First, they can only hold a single character. What if you had to store a complete name within them, say John, would you write something like:Now, thats pathetic. Thankfully, theres a data type that handles large number of characters, its called a String. A string can be initialized as follows:Notice, the use of double quotation marks instead of single quotation marks. Thats the only thing you need to worry about.', ''),
(275, 'Variables - Naming conventions for identifiers', 'When naming identifiers, you need to use the following guidelines which ensure that your variables are named accurately. As we discussed earlier, we should always name our variables in a way that tells us what they hold. Consider this example:Do you know what this program does? Well, it multiplies two values. That much you guessed right. But, do you know what those values are? Exactly, you dont. Now consider this code:Now you can tell whats happening, cant you? However, before we continue, notice the case of the variables. If a word contains CAPITAL LETTERS, it is in UPPER CASE. If a word has small letters, it is in lower case. Both cases in a word renders it as mIxEd CaSe.The variables we studied so far had a mixed case. When there are two or more words making up the names of a variable, you need to use a special case called the camel-case. Just like the humps of a camel, your words need to stand out. Using this technique, the words first and name could be written as either firstName or FirstName.The first instance, firstName is what we use as the names of variables. Remember though, firstName is not the same as FirstName because Java is case-sensitive. Case-sensitive basically implies that the case in which you wrote one word is the case you have to call that word in when using them later on. Anything other than that is not the same as you intended. Youll know more as you progress. You can hopefully tell now why the variables you were asked to identify werent proper.', ''),
(276, 'Variables - Variables in Java programming', 'Java is considered as a strongly typed programming language. Thus all variables in the Java programming language ought to have a particular data type. This is either declared or inferred and the Java language only allows programs to run if they adhere to type constraints.If you present a numeric type with data that is not numeric, say textual content, then such declarations would violate Javas type system. This gives Java the ability of type safety. Java checks if an expression or data is encountered with an incorrect type or none at all. It then automatically flags this occurrence as an error at compile time. Most type-related errors are caught by the Java compiler, hence making a program more secure and safe once compiled completely and successfully. Some languages (such as C) define an interpretation of such a statement and use that interpretation without any warning; others (such as PL/I) define a conversion for almost all such statements and perform the conversion to complete the assignment. Some type errors can still occur at runtime because Java supports a cast operation which is a way of changing the type of one expression to another. However, Java performs run time type checking when doing such casts, so an incorrect type cast will cause a runtime exception rather than succeeding silently and allowing data corruption.On the other hand, Java is also known as a hybrid language. While supporting object oriented programming (OOP), Java is not a pure OO language like Smalltalk or Ruby. Instead, Java offers both object types and primitive types. Primitive types are used for boolean, character, and numeric values and operations. This allows relatively good performance when manipulating numeric data, at the expense of flexibility. For example, you cannot subclass the primitive types and add new operations to them.', ''),
(277, 'Variables', 'In the Java programming language, the words field and variable are both one and the same thing. Variables are devices that are used to store data, such as a number, or a string of character data.', ''),
(278, 'Java - Overview', 'Java programming language was originally developed by Sun Microsystems which was initiated by James Gosling and released in 1995 as core component of Sun Microsystems Java platform (Java 1.0 [J2SE]).The latest release of the Java Standard Edition is Java SE 8. With the advancement of Java and its widespread popularity, multiple configurations were built to suite various types of platforms. Ex: J2EE for Enterprise Applications, J2ME for Mobile Applications.The new J2 versions were renamed as Java SE, Java EE and Java ME respectively. Java is guaranteed to be <b>Write Once, Run Anywhere.</b>Java is: <li><p><b>Object Oriented:</b> In Java, everything is an Object. Java can be easily extended since it is based on the Object model.</p></li> <li><p><b>Platform independent:</b> Unlike many other programming languages including C and C++, when Java is compiled, it is not compiled into platform specific machine, rather into platform independent byte code. This byte code is distributed over the web and interpreted by virtual Machine (JVM) on whichever platform it is being run.</p></li> <li><p><b>Simple:</b> Java is designed to be easy to learn. If you understand the basic concept of OOP Java would be easy to master.</p></li> <li><p><b>Secure:</b> With Javas secure feature it enables to develop virus-free, tamper-free systems. Authentication techniques are based on public-key encryption.</p></li> <li><p><b>Architectural-neutral: </b>Java compiler generates an architecture-neutral object file format which makes the compiled code to be executable on many processors, with the presence of Java runtime system.</p></li> <li><p><b>Portable:</b> Being architectural-neutral and having no implementation dependent aspects of the specification makes Java portable. Compiler in Java is written in ANSI C with a clean portability boundary which is a POSIX subset.</p></li> <li><p><b>Robust:</b> Java makes an effort to eliminate error prone situations by emphasizing mainly on compile time error checking and runtime checking.</p></li> <li><p><b>Multithreaded:</b> With Javas multithreaded feature it is possible to write programs that can do many tasks simultaneously. This design feature allows developers to construct smoothly running interactive applications.</p></li> <li><p><b>Interpreted:</b> Java byte code is translated on the fly to native machine instructions and is not stored anywhere. The development process is more rapid and analytical since the linking is an incremental and light weight process. </p></li> <li><p><b>High Performance:</b> With the use of Just-In-Time compilers, Java enables high performance.</p></li> <li><p><b>Distributed:</b> Java is designed for the distributed environment of the internet.</p></li> <li><p><b>Dynamic:</b> Java is considered to be more dynamic than C or C++ since it is designed to adapt to an evolving environment. Java programs can carry extensive amount of run-time information that can be used to verify and resolve accesses to objects on run-time.</p></li> ', ''),
(279, 'History of Java:', 'James Gosling initiated the Java language project in June 1991 for use in one of his many set-top box projects. The language, initially called Oak after an oak tree that stood outside Goslings office, also went by the name Green and ended up later being renamed as Java, from a list of random words.Sun released the first public implementation as Java 1.0 in 1995. It promised <b>Write Once, Run Anywhere</b>(WORA), providing no-cost run-times on popular platforms. On 13 November 2006, Sun released much of Java as free and open source software under the terms of the GNU General Public License (GPL).On 8 May 2007, Sun finished the process, making all of Javas core code free and open-source, aside from a small portion of code to which Sun did not hold the copyright.', ''),
(280, 'Tools you will need:', 'For performing the examples discussed in this tutorial, you will need a Pentium 200-MHz computer with a minimum of 64 MB of RAM (128 MB of RAM recommended).You also will need the following softwares: <li><p>Linux 7.1 or Windows xp/7/8 operating system.</p></li> <li><p>Java JDK 8 </p></li> <li><p>Microsoft Notepad or any other text editor</p></li> This tutorial will provide the necessary skills to create GUI, networking, and Web applications using Java.', ''),
(281, 'Try It Option:', 'We have provided you an option to compile and execute available code online. Just click on <b>Try it</b> button avaiable at top-right corner of the code window to compile and execute available code. There are certain examples which can not be executed online, so we have skipped those examples.There may be a case that you do not see the result of the compiled/executed code, in such case you can re-try to compile and execute the code using <b>execute</b> button available in compliation pop-up window.', '<br><code><pre class="prettyprint notranslate tryit"> public class MyFirstJavaProgram {      public static void main(String []args) {        System.out.println("Hello World");     } }  </pre></code><br>'),
(282, 'Local Environment Setup', 'If you are still willing to set up your environment for Java programming language, then this section guides you on how to download and set up Java on your machine. Please follow the following steps to set up the environment.Java SE is freely available from the link <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank">Download Java</a>. So you download a version based on your operating system.Follow the instructions to download java and run the <b>.exe</b> to install Java on your machine. Once you installed Java on your machine, you would need to set environment variables to point to correct installation directories:', ''),
(283, 'Setting up the path for windows:', 'Assuming you have installed Java in <i>c:Program Filesjavajdk</i> directory: <li><p>Right-click on My Computer and select Properties.</p></li> <li><p>Click on the Environment variables button under the Advanced tab.</p></li> <li><p>Now, alter the Path variable so that it also contains the path to the Java executable. Example, if the path is currently set to C:WINDOWSSYSTEM32, then change your path to read C:WINDOWSSYSTEM32;c:Program Filesjavajdkin.</p></li> ', ''),
(284, 'Setting up the path for Linux, UNIX, Solaris, FreeBSD:', 'Environment variable PATH should be set to point to where the Java binaries have been installed. Refer to your shell documentation if you have trouble doing this.Example, if you use <i>bash</i> as your shell, then you would add the following line to the end of your .bashrc: export PATH=/path/to/java:$PATH', ''),
(285, 'Popular Java Editors:', 'To write your Java programs, you will need a text editor. There are even more sophisticated IDEs available in the market. But for now, you can consider one of the following: <li><p><b>Notepad:</b> On Windows machine you can use any simple text editor like Notepad (Recommended for this tutorial), TextPad.</p></li> <li><p><b>Netbeans:</b> is a Java IDE that is open-source and free which can be downloaded from <a href="http://www.netbeans.org/index.html" target="_blank">http://www.netbeans.org/index.html</a>.</p></li> <li><p><b>Eclipse:</b> is also a Java IDE developed by the eclipse open-source community and can be downloaded from <a href="http://www.eclipse.org/" target="_blank">http://www.eclipse.org/</a>.</p></li> ', ''),
(286, 'Java - Basic Syntax', 'When we consider a Java program it can be defined as a collection of objects that communicate via invoking each others methods. Let us now briefly look into what do class, object, methods and instance variables mean. <li><p><b>Object -</b> Objects have states and behaviours. Example: A dog has states - colour, name, breed as well as behaviours -wagging, barking, eating. An object is an instance of a class. </p></li> <li><p><b>Class -</b> A class can be defined as a template/ blue print that describes the behaviours/states that object of its type support.</p></li> <li><p><b>Methods -</b> A method is basically a behaviour. A class can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.</p></li> <li><p><b>Instance Variables -</b> Each object has its unique set of instance variables. An objects state is created by the values assigned to these instance variables.</p></li> ', ''),
(287, 'First Java Program:', 'Let us look at a simple code that would print the words <i>Hello World</i>.Lets look at how to save the file, compile and run the program. Please follow the steps given below: <li><p>Open notepad and add the code as above.</p></li> <li><p>Save the file as: MyFirstJavaProgram.java.</p></li> <li><p>Open a command prompt window and go to the directory where you saved the 	class. Assume its C:.</p></li> <li><p>Type  javac MyFirstJavaProgram.java and press enter to compile your code. If there are no errors in your code, the command prompt will take you to the next line (Assumption : The path variable is set).</p></li> <li><p>Now, type  java MyFirstJavaProgram  to run your program.</p></li>	 <li><p>You will be able to see  Hello World  printed on the window.</p></li> ', '<br><code><pre class="prettyprint notranslate tryit"> public class MyFirstJavaProgram {     /* This is my first java program.       * This will print Hello World as the output     */ 	     public static void main(String []args) {        System.out.println("Hello World"); // prints Hello World     } }  </pre></code><br><br><code><pre class="result notranslate"> C:&gt; javac MyFirstJavaProgram.java C:&gt; java MyFirstJavaProgram  Hello World </pre></code><br>'),
(288, 'Basic Syntax:', 'About Java programs, it is very important to keep in mind the following points. <li><p><b>Case Sensitivity - </b> Java is case sensitive, which means identifier <b>Hello</b> and <b>hello</b> would have different meaning in Java.</p></li> <li><p><b>Class Names - </b> For all class names the first letter should be in Upper Case. <br /><br /> If several words are used to form a name of the class, each inner words first letter should be in Upper Case.<br /><br /> Example <i>class MyFirstJavaClass </i></p></li> <li><p><b>Method Names - </b> All method names should start with a Lower Case letter.  <br /><br /> If several words are  used to form the name of the method, then each inner words first letter should be in Upper Case.<br /><br /> Example <i>public void myMethodName()</i></p></li> <li><p><b>Program File Name - </b> Name of the program file should exactly match the class name.  <br /><br /> When saving the file, you should save it using the class name (Remember Java is case sensitive) and append .java to the end of the name (if the file name and the class name do not match your program will not compile).<br /><br /> Example: Assume MyFirstJavaProgram is the class  name. Then the file should be saved as <i>MyFirstJavaProgram.java</i></p></li> <li><p><b>public static void main(String args[]) -</b> Java program processing starts from the main() method which is a mandatory part of every Java program.</p></li> ', ''),
(289, 'Java Identifiers:', 'All Java components require names. Names used for classes, variables and methods are called identifiers.In Java, there are several points to remember about identifiers. They are as follows: <li><p>All identifiers should begin with a letter (A to Z or a to z), currency character ($) or an underscore (_).</p></li> <li><p>After the first character identifiers can have any combination of characters.</p></li> <li><p>A key word cannot be used as an identifier.</p></li> <li><p>Most importantly identifiers are case sensitive.</p></li> <li><p>Examples of legal identifiers: age, $salary, _value,  __1_value</p></li> <li><p>Examples of illegal identifiers: 123abc, -salary</p></li> ', ''),
(290, 'Java Modifiers:', 'Like other languages, it is possible to modify classes, methods, etc., by using modifiers. There are two categories of modifiers: <li><p><b>Access Modifiers: </b> default, public , protected, private</p></li> <li><p><b>Non-access Modifiers: </b> final, abstract, strictfp</p></li> We will be looking into more details about modifiers in the next section.', ''),
(291, 'Java Variables:', 'We would see following type of variables in Java: <li>Local Variables</li> <li>Class Variables (Static Variables)</li> <li>Instance Variables (Non-static variables)</li> ', ''),
(292, 'Java Arrays:', 'Arrays are objects that store multiple variables of the same type. However, an array itself is an object on the heap. We will look into how to declare, construct and initialize in the upcoming chapters.', ''),
(293, 'Java Enums:', 'Enums were introduced in java 5.0. Enums restrict a variable to have one of only a few predefined values. The values in this enumerated list are called enums.With the use of enums it is possible to reduce the number of bugs in your code. For example, if we consider an application for a fresh juice shop, it would be possible to restrict the glass size to small, medium and large. This would make sure that it would not allow anyone to order any size other than the small, medium or large.', ''),
(294, 'Example:', 'Above example will produce the following result:<b>Note:</b> enums can be declared as their own or inside a class. Methods, variables, constructors can be defined inside enums as well.', '<br><code><pre class="prettyprint notranslate tryit"> class FreshJuice {     enum FreshJuiceSize{ SMALL, MEDIUM, LARGE }    FreshJuiceSize size; }  public class FreshJuiceTest {     public static void main(String args[]){       FreshJuice juice = new FreshJuice();       juice.size = FreshJuice.FreshJuiceSize.MEDIUM ;       System.out.println("Size: " + juice.size);    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Size: MEDIUM </pre></code><br>'),
(295, 'Java Keywords:', 'The following list shows the reserved words in Java. These reserved words may not be used as constant or variable or any other identifier names.', ''),
(296, 'Comments in Java', 'Java supports single-line and multi-line comments very similar to c and c++. All characters available inside any comment are ignored by Java compiler.', '<br><code><pre class="prettyprint notranslate tryit"> public class MyFirstJavaProgram{     /* This is my first java program.     * This will print Hello World as the output     * This is an example of multi-line comments.     */      public static void main(String []args){        // This is an example of single line comment        /* This is also an example of single line comment. */        System.out.println("Hello World");      } }  </pre></code><br>'),
(297, 'Using Blank Lines:', 'A line containing only white space, possibly with a comment, is known as a blank line, and Java totally ignores it.', ''),
(298, 'Inheritance:', 'In Java, classes can be derived from classes.  Basically if you need to create a new class and here is already a class that has some of the code you require, then it is possible to derive your new class from the already existing code. This concept allows you to reuse the fields and methods of the existing class without having to rewrite the code in a new class. In this scenario the existing class is called the superclass and the derived class is called the subclass.', ''),
(299, 'Interfaces:', 'In Java language, an interface can be defined as a contract between objects on how to communicate with each other. Interfaces play a vital role when it comes to the concept of inheritance.An interface defines the methods, a deriving class(subclass) should use. But the implementation of the methods is totally up to the subclass.', ''),
(300, 'Java - Object &amp; Classes', 'Java is an Object-Oriented Language. As a language that has the Object Oriented feature, Java supports the following fundamental concepts: <li>Polymorphism</li> <li>Inheritance</li> <li>Encapsulation</li> <li>Abstraction</li> <li>Classes</li> <li>Objects</li> <li>Instance</li> <li>Method</li> <li>Message Parsing</li> In this chapter, we will look into the concepts Classes and Objects. <li><p><b>Object -</b> Objects have states and behaviors. Example: A dog has states - color, name, breed as well as behaviors -wagging, barking, eating. An object is an instance of a class. </p></li> <li><p><b>Class -</b> A class can be defined as a template/blue print that describes the behaviors/states that object of its type support.</p></li> ', '');
INSERT INTO `textbook` (`textid`, `topic`, `content`, `code`) VALUES
(301, 'Objects in Java:', 'Let us now look deep into what are objects. If we consider the real-world we can find many objects around us, Cars, Dogs, Humans, etc. All these objects have a state and behavior.If we consider a dog, then its state is - name, breed, color, and the behavior is - barking, wagging, runningIf you compare the software object with a real world object, they have very similar characteristics.Software objects also have a state and behavior. A software objects state is stored in fields and behavior is shown via methods.So in software development, methods operate on the internal state of an object and the object-to-object communication is done via methods.', ''),
(302, 'Classes in Java:', 'A class is a blue print from which individual objects are created.A sample of a class is given below:A class can contain any of the following variable types. <li><p><b>Local variables: </b>Variables defined inside methods, constructors or blocks are called local variables. The variable will be declared and initialized within the method and the variable will be destroyed when the method has completed.</p></li> <li><p><b>Instance variables: </b>Instance variables are variables within a class but outside any method. These variables are initialized when the class is instantiated. Instance variables can be accessed from inside any method, constructor or blocks of that particular class.</p></li> <li><p><b>Class variables: </b>Class variables are variables declared with in a class, outside any method, with the static keyword.</p></li> A class can have any number of methods to access the value of various kinds of methods. In the above example, barking(), hungry() and sleeping() are methods.Below mentioned are some of the important topics that need to be discussed when looking into classes of the Java Language.', '<br><code><pre class="prettyprint notranslate"> public class Dog{    String breed;    int ageC    String color;     void barking(){    }        void hungry(){    }        void sleeping(){    } } </pre></code><br>'),
(303, 'Constructors:', 'When discussing about classes, one of the most important sub topic would be constructors. Every class has a constructor. If we do not explicitly write a constructor for a class the Java compiler builds a default constructor for that class.Each time a new object is created, at least one constructor will be invoked. The main rule of constructors is that they should have the same name as the class. A class can have more than one constructor.Example of a constructor is given below:Java also supports <a href="/java/java_using_singleton.htm">Singleton Classes</a> where you would be able to create only one instance of a class.<b>Note: </b>We have two different types of constructors we are going to discuss constructors in detail in coming chapters.', '<br><code><pre class="prettyprint notranslate"> public class Puppy{    public Puppy(){    }     public Puppy(String name){       // This constructor has one parameter, <i>name</i>.    } } </pre></code><br>'),
(304, 'Creating an Object:', 'As mentioned previously, a class provides the blueprints for objects. So basically an object is created from a class. In Java, the new key word is used to create new objects. There are three steps when creating an object from a class: <li><p><b>Declaration: </b>A variable declaration with a variable name with an object type.</p></li> <li><p><b>Instantiation: </b>The new key word is used to create the object.</p></li> <li><p><b>Initialization: </b>The new keyword is followed by a call to a constructor. This call initializes the new object.</p></li> Example of creating an object is given below:If we compile and run the above program, then it would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class Puppy{     public Puppy(String name){       // This constructor has one parameter, <i>name</i>.       System.out.println("Passed Name is :" + name );     }        public static void main(String []args){       // Following statement would create an object myPuppy       Puppy myPuppy = new Puppy( "tommy" );    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Passed Name is :tommy </pre></code><br>'),
(305, 'Accessing Instance Variables and Methods:', 'Instance variables and methods are accessed via created objects. To access an instance variable the fully qualified path should be as follows:', '<br><code><pre class="prettyprint notranslate"> /* First create an object */ ObjectReference = new Constructor();  /* Now call a variable as follows */ ObjectReference.variableName;  /* Now you can call a class method as follows */ ObjectReference.MethodName(); </pre></code><br>'),
(306, 'Example:', 'This example explains how to access instance variables and methods of a class:If we compile and run the above program, then it would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class Puppy{        int puppyAge;     public Puppy(String name){       // This constructor has one parameter, <i>name</i>.       System.out.println("Name chosen is :" + name );     }        public void setAge( int age ){        puppyAge = age;    }     public int getAge( ){        System.out.println("Puppys age is :" + puppyAge );         return puppyAge;    }        public static void main(String []args){       /* Object creation */       Puppy myPuppy = new Puppy( "tommy" );        /* Call class method to set puppys age */       myPuppy.setAge( 2 );        /* Call another class method to get puppys age */       myPuppy.getAge( );        /* You can access instance variable as follows as well */       System.out.println("Variable Value :" + myPuppy.puppyAge );     } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Name chosen is :tommy Puppys age is :2 Variable Value :2 </pre></code><br>'),
(307, 'Source file declaration rules:', 'As the last part of this section lets now look into the source file declaration rules. These rules are essential when declaring classes, <i>import</i> statements and <i>package</i> statements in a source file. <li><p>There can be only one public class per source file.</p></li> <li><p>A source file can have multiple non public classes.</p></li> <li><p>The public class name should be the name of the source file as well which should be appended by <b>.java</b> at the end. For example: the class name is <i>public class Employee{}</i> then the source file should be as Employee.java.</p></li> <li><p>If the class is defined inside a package, then the package statement should be the first statement in the source file.</p></li> <li><p>If import statements are present then they must be written between the package statement and the class declaration. If there are no package statements then the import statement should be the first line in the source file. </p></li> <li><p>Import and package statements will imply to all the classes present in the source file. It is not possible to declare different import and/or package statements to different classes in the source file.</p></li> Classes have several access levels and there are different types of classes; abstract classes, final classes, etc. we will be explaining about all these in the access modifiers chapter.Apart from the above mentioned types of classes, Java also has some special classes called Inner classes and Anonymous classes.', ''),
(308, 'Java Package:', 'In simple, it is a way of categorizing the classes and interfaces. When developing applications in Java,  hundreds of classes and interfaces will be written, therefore categorizing these classes is a must as well as makes life much easier.', ''),
(309, 'Import statements:', 'In Java if a fully qualified name, which includes the package and the class name, is given then the compiler can easily locate the source code or classes. Import statement is a way of giving the proper location for the compiler to find that particular class.For example, the following line would ask compiler to load all the classes available in directory java_installation/java/io :', '<br><code><pre class="prettyprint notranslate"> import java.io.*; </pre></code><br>'),
(310, 'A Simple Case Study', 'For our case study, we will be creating two classes. They are Employee and EmployeeTest.First open notepad and add the following code. Remember this is the Employee class and the class is a public class. Now, save this source file with the name Employee.java.The Employee class has four instance variables name, age, designation and salary. The class has one explicitly defined constructor, which takes a parameter.As mentioned previously in this tutorial, processing starts from the main method. Therefore in-order for us to run this Employee class there should be main method and objects should be created. We will be creating a separate class for these tasks.Given below is the <i>EmployeeTest</i> class, which creates two instances of the class Employee and invokes the methods for each object to assign values for each variable.Save the following code in EmployeeTest.java fileNow, compile both the classes and then run <i>EmployeeTest</i> to see the result as follows:', '<br><code><pre class="prettyprint notranslate" id="employee"> import java.io.*;  public class Employee{     String name;    int age;    String designation;    double salary; 	    // This is the constructor of the class Employee    public Employee(String name){       this.name = name;    }    // Assign the age of the Employee  to the variable age.    public void empAge(int empAge){       age =  empAge;    }    /* Assign the designation to the variable designation.*/    public void empDesignation(String empDesig){       designation = empDesig;    }    /* Assign the salary to the variable	salary.*/    public void empSalary(double empSalary){       salary = empSalary;    }    /* Print the Employee details */    public void printEmployee(){       System.out.println("Name:"+ name );       System.out.println("Age:" + age );       System.out.println("Designation:" + designation );       System.out.println("Salary:" + salary);    } } </pre></code><br><br><code><pre class="prettyprint notranslate tryit" title="employee"> import java.io.*;  public class EmployeeTest{     public static void main(String args[]){       /* Create two objects using constructor */       Employee empOne = new Employee("James Smith");       Employee empTwo = new Employee("Mary Anne");        // Invoking methods for each object created       empOne.empAge(26);       empOne.empDesignation("Senior Software Engineer");       empOne.empSalary(1000);       empOne.printEmployee();        empTwo.empAge(21);       empTwo.empDesignation("Software Engineer");       empTwo.empSalary(500);       empTwo.printEmployee();    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> C:&gt; javac Employee.java C:&gt; javac EmployeeTest.java C:&gt; java EmployeeTest Name:James Smith Age:26 Designation:Senior Software Engineer Salary:1000.0 Name:Mary Anne Age:21 Designation:Software Engineer Salary:500.0 </pre></code><br>'),
(311, 'Java - Basic Datatypes', 'Variables are nothing but reserved memory locations to store values. This means that when you create a variable you reserve some space in memory.Based on the data type of a variable, the operating system allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to variables, you can store integers, decimals, or characters in these variables.There are two data types available in Java: <li><p>Primitive Data Types</p></li> <li><p>Reference/Object Data Types</p></li> ', ''),
(312, 'Primitive Data Types:', 'There are eight primitive data types supported by Java. Primitive data types are predefined by the language and named by a keyword. Let us now look into detail about the eight primitive data types.', ''),
(313, 'byte:', ' <li><p>Byte data type is an 8-bit signed twos complement integer.</p></li> <li><p>Minimum value is -128 (-2^7)</p></li> <li><p>Maximum value is 127 (inclusive)(2^7 -1)</p></li> <li><p>Default value is 0</p></li> <li><p>Byte data type is used to save space in large arrays, mainly in place of integers, since a byte is four times smaller than an int.</p></li> <li><p>Example:  byte a = 100 , byte b = -50</p></li> ', ''),
(314, 'short:', ' <li><p>Short data type is a 16-bit signed twos complement integer. </p></li> <li><p>Minimum value is -32,768 (-2^15)</p></li> <li><p>Maximum value is 32,767 (inclusive) (2^15 -1)</p></li> <li><p>Short data type can also be used to save memory as byte data type. A short is 2 times smaller than an int</p></li> <li><p>Default value is 0.</p></li> <li><p>Example: short  s = 10000, short r = -20000</p></li> ', ''),
(315, 'int:', ' <li><p>Int data type is a 32-bit signed twos complement integer.</p></li> <li><p>Minimum value is - 2,147,483,648.(-2^31)</p></li> <li><p>Maximum value is 2,147,483,647(inclusive).(2^31 -1)</p></li> <li><p>Int is generally used as the default data type for integral values unless there is a concern about memory.</p></li> <li><p>The default value is 0.</p></li> <li><p>Example: int a = 100000, int b = -200000</p></li> ', ''),
(316, 'long:', ' <li><p>Long data type is a 64-bit signed twos complement integer. </p></li> <li><p>Minimum value is -9,223,372,036,854,775,808.(-2^63)</p></li> <li><p>Maximum value is 9,223,372,036,854,775,807 (inclusive). (2^63 -1)</p></li> <li><p>This type is used when a wider range than int is needed.</p></li> <li><p>Default value is 0L.</p></li> <li><p>Example: long a = 100000L, long b = -200000L</p></li> ', ''),
(317, 'float:', ' <li><p>Float data type is a single-precision 32-bit IEEE 754 floating point. </p></li> <li><p>Float is mainly used to save memory in large arrays of floating point numbers.</p></li> <li><p>Default value is 0.0f.</p></li> <li><p>Float data type is never used for precise values such as currency. </p></li> <li><p>Example: float f1 = 234.5f</p></li> ', ''),
(318, 'double:', ' <li><p>double data type is a double-precision 64-bit IEEE 754 floating point.</p></li>  <li><p>This data type is generally used as the default data type for decimal values, generally the default choice. </p></li> <li><p>Double data type should never be used for precise values such as currency.</p></li> <li><p>Default value is 0.0d.</p></li> <li><p>Example: double d1 = 123.4</p></li> ', ''),
(319, 'boolean:', ' <li><p>boolean data type represents one bit of information.</p></li> <li><p>There are only two possible values: true and false.</p></li> <li><p>This data type is used for simple flags that track true/false conditions.</p></li> <li><p>Default value is false.</p></li> <li><p>Example: boolean one = true</p></li> ', ''),
(320, 'char:', ' <li><p>char data type is a single 16-bit Unicode character. </p></li> <li><p>Minimum value is u0000 (or 0).</p></li> <li><p>Maximum value is  uffff (or 65,535 inclusive).</p></li> <li><p>Char data type is used to store any character.</p></li>  <li><p>Example: char letterA =A</p></li> ', ''),
(321, 'Reference Data Types:', ' <li><p>Reference variables are created using defined constructors of the classes. They are used to access objects. These variables are declared to be of a specific type that cannot be changed. For example, Employee, Puppy etc.</p></li>  <li><p>Class objects, and various type of array variables come under reference data type.</p></li> <li><p>Default value of any reference variable is null.</p></li>  <li><p>A reference variable can be used to refer to any object of the declared type or any compatible type.</p></li>  <li><p>Example: Animal animal = new Animal("giraffe");</p></li>  ', ''),
(322, 'Java Literals:', 'A literal is a source code representation of a fixed value. They are represented directly in the code without any computation.Literals can be assigned to any primitive type variable. For example:byte, int, long, and short can be expressed in decimal(base 10), hexadecimal(base 16) or octal(base 8) number systems as well.Prefix 0 is used to indicate octal and prefix 0x indicates hexadecimal when using these number systems for literals. For example:String literals in Java are specified like they are in most other languages by enclosing a sequence of characters between a pair of double quotes. Examples of string literals are:String and char types of literals can contain any Unicode characters. For example:Java language supports few special escape sequences for String and char literals as well. They are:', '<br><code><pre class="prettyprint notranslate"> byte a = 68; char a = A </pre></code><br><br><code><pre class="prettyprint notranslate"> int decimal = 100; int octal = 0144; int hexa =  0x64; </pre></code><br><br><code><pre class="prettyprint notranslate"> "Hello World" "two\nlines" ""This is in quotes"" </pre></code><br><br><code><pre class="prettyprint notranslate"> char a = u0001; String a = "u0001"; </pre></code><br>'),
(323, 'Java - Variable Types', 'A variable provides us with named storage that our programs can manipulate. Each variable in Java has a specific type, which determines the size and layout of the variables memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.You must declare all variables before they can be used. The basic form of a variable declaration is shown here:Here <i>data type</i> is one of Javas datatypes and <i>variable</i> is the name of the variable. To declare more than one variable of the specified type, you can use a comma-separated list.Following are valid examples of variable declaration and initialization in Java:This chapter will explain various variable types available in Java Language. There are three kinds of variables in Java: <li><p>Local variables </p></li> <li><p>Instance variables </p></li> <li><p>Class/static variables</p></li> ', '<br><code><pre class="prettyprint notranslate"> data type variable [ = value][, variable [= value] ...] ; </pre></code><br><br><code><pre class="prettyprint notranslate"> int a, b, c;         // Declares three ints, a, b, and c. int a = 10, b = 10;  // Example of initialization byte B = 22;         // initializes a byte type variable B. double pi = 3.14159; // declares and assigns a value of PI. char a = a;        // the char variable a iis initialized with value a </pre></code><br>'),
(324, 'Local variables:', ' <li><p>Local variables are declared in methods, constructors, or blocks.</p></li> <li><p>Local variables are created when the method, constructor or block is entered and the variable will be destroyed once it exits the method, constructor or block.</p></li> <li><p>Access modifiers cannot be used for local variables.</p></li> <li><p>Local variables are visible only within the declared method, constructor or block.</p></li> <li><p>Local variables are implemented at stack level internally.</p></li> <li><p>There is no default value for local variables so local variables should be declared and an initial value should be assigned before the first use.</p></li> ', ''),
(325, 'Example:', 'Here, <i>age</i> is a local variable. This is defined inside <i>pupAge()</i> method and its scope is limited to this method only.This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class Test{     public void pupAge(){       int age = 0;       age = age + 7;       System.out.println("Puppy age is : " + age);    }        public static void main(String args[]){       Test test = new Test();       test.pupAge();    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Puppy age is: 7 </pre></code><br>'),
(326, 'Example:', 'Following example uses <i>age</i> without initializing it, so it would give an error at the time of compilation.This would produce the following error while compiling it:', '<br><code><pre class="prettyprint notranslate tryit"> public class Test{     public void pupAge(){       int age;       age = age + 7;       System.out.println("Puppy age is : " + age);    }        public static void main(String args[]){       Test test = new Test();       test.pupAge();    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Test.java:4:variable number might not have been initialized age = age + 7;          ^ 1 error </pre></code><br>'),
(327, 'Instance variables:', ' <li><p>Instance variables are declared in a class, but outside a method, constructor or any block.</p></li> <li><p>When a space is allocated for an object in the heap, a slot for each instance variable value is created.</p></li> <li><p>Instance variables are created when an object is created with the use of the keyword new and destroyed when the object is destroyed.</p></li> <li><p>Instance variables hold values that must be referenced by more than one method, constructor or block, or essential parts of an objects state that must be present throughout the class.</p></li> <li><p>Instance variables can be declared in class level before or after use.</p></li> <li><p>Access modifiers can be given for instance variables.</p></li> <li><p>The instance variables are visible for all methods, constructors and block in the class. Normally, it is recommended to make these variables private (access level). However visibility for subclasses can be given for these variables with the use of access modifiers.</p></li> <li><p>Instance variables have default values. For numbers the default value is 0, for Booleans it is false and for object references it is null. Values can be assigned during the declaration or within the constructor.</p></li> <li><p>Instance variables can be accessed directly by calling the variable name inside the class. However within static methods and different class ( when instance variables are given accessibility) should be called using the fully qualified name . <i>ObjectReference.VariableName</i>.</p></li> ', ''),
(328, 'Example:', 'This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.io.*;  public class Employee{    // this instance variable is visible for any child class.    public String name;        // salary  variable is visible in Employee class only.    private double salary;        // The name variable is assigned in the constructor.     public Employee (String empName){       name = empName;    }     // The salary variable is assigned a value.    public void setSalary(double empSal){       salary = empSal;    }        // This method prints the employee details.    public void printEmp(){       System.out.println("name  : " + name );       System.out.println("salary :" + salary);    }     public static void main(String args[]){       Employee empOne = new Employee("Ransika");       empOne.setSalary(1000);       empOne.printEmp();    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> name  : Ransika salary :1000.0 </pre></code><br>'),
(329, 'Class/static variables:', ' <li><p>Class variables also known as static variables are declared with the <i>static</i> keyword in a class, but outside a method, constructor or a block. </p></li> <li><p>There would only be one copy of each class variable per class, regardless of how many objects are created from it.</p></li> <li><p>Static variables are rarely used other than being declared as constants. Constants are variables that are declared as public/private, final and static. Constant variables never change from their initial value.</p></li> <li><p>Static variables are stored in static memory. It is rare to use static variables other than declared final and used as either public or private constants.</p></li> <li><p>Static variables are created when the program starts and destroyed when the program stops.</p></li> <li><p>Visibility is similar to instance variables. However, most static variables are declared public since they must be available for users of the class.</p></li> <li><p>Default values are same as instance variables. For numbers, the default value is 0; for Booleans, it is false; and for object references, it is null. Values can be assigned during the declaration or within the constructor. Additionally values can be assigned in special static initializer blocks.</p></li> <li><p>Static variables can be accessed by calling with the class name <i>ClassName.VariableName</i>.</p></li> <li><p>When declaring class variables as public static final, then variables names (constants) are all in upper case. If the static variables are not public and final the naming syntax is the same as instance and local variables.</p></li> ', ''),
(330, 'Example:', 'This would produce the following result:<b>Note:</b> If the variables are access from an outside class the constant should be accessed as Employee.DEPARTMENT', '<br><code><pre class="prettyprint notranslate tryit"> import java.io.*;  public class Employee{    // salary  variable is a private static variable    private static double salary;     // DEPARTMENT is a constant    public static final String DEPARTMENT = "Development ";     public static void main(String args[]){       salary = 1000;       System.out.println(DEPARTMENT + "average salary:" + salary);    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Development average salary:1000 </pre></code><br>'),
(331, 'Java - Modifier Types', 'Modifiers are keywords that you add to those definitions to change their meanings. The Java language has a wide variety of modifiers, including the following: <li><p><a href="/java/java_access_modifiers.htm"> Java Access Modifiers</a></p></li> <li><p><a href="/java/java_nonaccess_modifiers.htm">Non Access Modifiers</a></p></li> To use a modifier, you include its keyword in the definition of a class, method, or variable. The modifier precedes the rest of the statement, as in the following examples (Italic ones) &minus;', '<br><code><pre class="prettyprint notranslate"> <i>public</i> class className {    // ... } <i>private</i> boolean myFlag; <i>static final</i> double weeks = 9.5; <i>protected static final</i> int BOXWIDTH = 42; <i>public static</i> void main(String[] arguments) {    // body of method } </pre></code><br>'),
(332, 'Access Control Modifiers:', 'Java provides a number of access modifiers to set access levels for classes, variables, methods and constructors. The four access levels are: <li><p>Visible to the package, the default. No modifiers are needed.</p></li> <li><p>Visible to the class only (private).</p></li> <li><p>Visible to the world (public).</p></li> <li><p>Visible to the package and all subclasses (protected).</p></li> ', ''),
(333, 'Non Access Modifiers:', 'Java provides a number of non-access modifiers to achieve many other functionality. <li><p>The <i>static</i> modifier for creating class methods and variables</p></li> <li><p>The <i>final</i> modifier for finalizing the implementations of classes, methods, and variables.</p></li> <li><p>The <i>abstract</i> modifier for creating abstract classes and methods.</p></li> <li><p>The <i>synchronized</i> and <i>volatile</i> modifiers, which are used for threads.</p></li> ', ''),
(334, 'Java - Basic Operators', 'Java provides a rich set of operators to manipulate variables. We can divide all the Java operators into the following groups: <li><p>Arithmetic Operators</p></li> <li><p>Relational Operators</p></li> <li><p>Bitwise Operators</p></li> <li><p>Logical Operators</p></li> <li><p>Assignment Operators</p></li> <li><p>Misc Operators</p></li> ', ''),
(335, 'The Arithmetic Operators:', 'Arithmetic operators are used in mathematical expressions in the same way that they are used in algebra. The following table lists the arithmetic operators:Assume integer variable A holds 10 and variable B holds 20, then:<a href="/java/java_arithmatic_operators_examples.htm">Show Examples</a>', ''),
(336, 'The Relational Operators:', 'There are following relational operators supported by Java languageAssume variable A holds 10 and variable B holds 20, then:<a href="/java/java_relational_operators_examples.htm">Show Examples</a>', ''),
(337, 'The Bitwise Operators:', 'Java defines several bitwise operators, which can be applied to the integer types, long, int, short, char, and byte.Bitwise operator works on bits and performs bit-by-bit operation. Assume if a = 60; and b = 13; now in binary format they will be as follows:a = 0011 1100b = 0000 1101-----------------a&amp;b = 0000 1100a|b = 0011 1101a^b = 0011 0001~a&nbsp; = 1100 0011The following table lists the bitwise operators:Assume integer variable A holds 60 and variable B holds 13 then:<a href="/java/java_bitwise_operators_examples.htm">Show Examples</a>', ''),
(338, 'The Logical Operators:', 'The following table lists the logical operators:Assume Boolean variables A holds true and variable B holds false, then:<a href="/java/java_logical_operators_examples.htm">Show Examples</a>', ''),
(339, 'The Assignment Operators:', 'There are following assignment operators supported by Java language:<a href="/java/java_assignment_operators_examples.htm">Show Examples</a>', ''),
(340, 'Miscellaneous Operators', 'There are few other operators supported by Java Language.', ''),
(341, 'Conditional Operator ( ? : )', 'Conditional operator is also known as the ternary operator. This operator consists of three operands and is used to evaluate Boolean expressions. The goal of the operator is to decide which value should be assigned to the variable. The operator is written as:Following is the example:This would produce the following result &minus;', '<br><code><pre class="prettyprint notranslate"> variable x = (expression) ? value if true : value if false </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> public class Test {     public static void main(String args[]){       int a, b;       a = 10;       b = (a == 1) ? 20: 30;       System.out.println( "Value of b is : " +  b );        b = (a == 10) ? 20: 30;       System.out.println( "Value of b is : " + b );    } } </pre></code><br><br><code><pre class="result notranslate"> Value of b is : 30 Value of b is : 20 </pre></code><br>'),
(342, 'instance of Operator:', 'This operator is used only for object reference variables. The operator checks whether the object is of a particular type (class type or interface type).  instanceof operator is written as:If the object referred by the variable on the left side of the operator passes the IS-A check for the class/interface type on the right side, then the result will be true. Following is the example:This would produce the following result:This operator will still return true if the object being compared is the assignment compatible with the type on the right. Following is one more example:This would produce the following result:', '<br><code><pre class="prettyprint notranslate"> ( Object reference variable ) instanceof  (class/interface type) </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> public class Test {     public static void main(String args[]){       String name = "James";       // following will return true since name is type of String       boolean result = name instanceof String;         System.out.println( result );    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> true </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> class Vehicle {}  public class Car extends Vehicle {    public static void main(String args[]){       Vehicle a = new Car();       boolean result =  a instanceof Car;       System.out.println( result );    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> true </pre></code><br>'),
(343, 'Precedence of Java Operators:', 'Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator:For example, x = 7 + 3 * 2; here  x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.', ''),
(344, 'Java - Loop Control', ' There may be a situation when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.Programming languages provide various control structures that allow for more complicated execution paths.A <b>loop</b> statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages:Java programming language provides the following types of loop to handle looping requirements. Click the following links to check their detail.', ''),
(345, 'Loop Control Statements:', 'Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.Java supports the following control statements. Click the following links to check their detail.', ''),
(346, 'Enhanced for loop in Java:', 'As of Java 5, the enhanced for loop was introduced. This is mainly used to traverse collection of elements including arrays.', ''),
(347, 'Syntax:', 'The syntax of enhanced for loop is: <li><p><b>Declaration:</b> The newly declared block variable, which is of a type compatible with the elements of the array you are accessing. The variable will be available within the for block and its value would be the same as the current array element.</p></li> <li><p><b>Expression:</b> This evaluates to the array you need to loop through. The expression can be an array variable or method call that returns an array.</p></li> ', '<br><code><pre class="prettyprint notranslate"> for(declaration : expression) {    //Statements } </pre></code><br>'),
(348, 'Example:', 'This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class Test {     public static void main(String args[]){       int [] numbers = {10, 20, 30, 40, 50};        for(int x : numbers ){          System.out.print( x );          System.out.print(",");       }       System.out.print("\n");       String [] names ={"James", "Larry", "Tom", "Lacy"};       for( String name : names ) {          System.out.print( name );          System.out.print(",");       }    } } </pre></code><br><br><code><pre class="result notranslate"> 10,20,30,40,50, James,Larry,Tom,Lacy, </pre></code><br>'),
(349, 'Java - Decision Making', 'Decision making structures have one or more conditions to be evaluated or tested by the program, along with a statement or statements that are to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.Following is the general form of a typical decision making structure found in most of the programming languages:Java programming language provides following types of decision making statements. Click the following links to check their detail.', ''),
(350, 'The ? : Operator:', 'We have covered <b>conditional operator ? :</b> in previous chapter which can be used to replace <b>if...else</b> statements. It has the following general form:Where Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the colon.To determine the value of whole expression, initially exp1 is evaluated  <li>If the value of exp1 is true, then the value of Exp2 will be the value of the whole expression. </li> <li>If the value of exp1 is false, then Exp3 is evaluated and its value becomes the value of the entire expression.</li>', '<br><code><pre class="prettyprint notranslate"> Exp1 ? Exp2 : Exp3; </pre></code><br>'),
(351, 'Java - Numbers Class', 'Normally, when we work with Numbers, we use primitive data  types  such as  byte, int, long, double, etc.', ''),
(352, 'Example:', 'However, in development, we come across situations where we need to use objects instead of primitive data types. In-order to achieve this Java provides <b>wrapper classes</b> All the wrapper classes (Integer, Long, Byte, Double, Float, Short) are subclasses of the abstract class Number. <img src="/java/images/number_classes.jpg" alt="Number Subclasses" /> The object of the wrapper class contains or wraps its respective primitive data type. converting primitive data types into object is called boxing, and this is taken care by the compiler. therefore while using a wrapper class you just need to pass the value of the primitive data type to the constructor of the Wrapper class. And  the Wrapper object will be converted back to a primitive data type, and this process is called un boxing. The <b>Number</b> class is part of the java.lang package.Here is an example of boxing and unboxing:This would produce the following result:When x is assigned integer value, the compiler boxes the integer because x is integer object. Later, x is unboxed so that they can be added as integer.', '<br><code><pre class="prettyprint notranslate"> int i = 5000; float gpa = 13.65; byte mask = 0xaf; </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> public class Test{     public static void main(String args[]){       Integer x = 5; // boxes int to an Integer object       x =  x + 10;   // unboxes the Integer to a int       System.out.println(x);     } } </pre></code><br><br><code><pre class="prettyprint notranslate"> 15 </pre></code><br>'),
(353, 'Number Methods:', 'Here is the list of the instance methods that all the subclasses of the Number class implement:', ''),
(354, 'Java - Character Class', 'Normally, when we work with characters, we use primitive data  types char.', ''),
(355, 'Example:', 'However in development, we come across situations where we need to use objects instead of primitive data types. In order to achieve this, Java provides wrapper class <b>Character</b> for  primitive data type char.The Character class offers a number of useful class (i.e., static) methods for manipulating characters. You can create a Character object with the Character constructor:The Java compiler will also create a Character object for you under some circumstances. For example, if you pass a primitive char into a method that expects an object, the compiler automatically converts the char to a Character for you. This feature is called autoboxing or unboxing, if the conversion goes the other way.', '<br><code><pre class="prettyprint notranslate"> char ch = a;  // Unicode for uppercase Greek omega character char uniChar = u039A;   // an array of chars char[] charArray ={ a, b, c, d, e };  </pre></code><br><br><code><pre class="prettyprint notranslate"> Character ch = new Character(a); </pre></code><br>'),
(356, 'Escape Sequences:', 'A character preceded by a backslash () is an escape sequence and has special meaning to the compiler.The newline character (\n) has been used frequently in this tutorial in System.out.println() statements to advance to the next line after the string is printed.Following table shows the Java escape sequences:When an escape sequence is encountered in a print statement, the compiler interprets it accordingly.', ''),
(357, 'Example:', 'If you want to put quotes within quotes you must use the escape sequence, ", on the interior quotes:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class Test {     public static void main(String args[]) {       System.out.println("She said "Hello!" to me.");    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> She said "Hello!" to me. </pre></code><br>'),
(358, 'Character Methods:', 'Here is the list of the important instance methods that all the subclasses of the Character class implement:For a complete list of methods, please refer to the java.lang.Character API specification.', ''),
(359, 'Java - Strings Class', 'Strings, which are widely used in Java programming, are a sequence of characters. In the Java programming language, strings are objects.The Java platform provides the String class to create and manipulate strings.', ''),
(360, 'Creating Strings:', 'The most direct way to create a string is to write:Whenever it encounters a string literal in your code, the compiler creates a String object with its value in this case, "Hello world!.As with any other object, you can create String objects by using the new keyword and a constructor. The String class has eleven constructors that allow you to provide the initial value of the string using different sources, such as an array of characters.This would produce the following result:<b>Note:</b> The String class is immutable, so that once it is created a String object cannot be changed. If there is a necessity to make a lot of modifications to Strings of characters, then you should use <a href="/java/java_string_buffer.htm">String Buffer &amp; String Builder</a> Classes.', '<br><code><pre class="prettyprint notranslate"> String greeting = "Hello world!"; </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> public class StringDemo{     public static void main(String args[]){       char[] helloArray = { h, e, l, l, o, .};       String helloString = new String(helloArray);         System.out.println( helloString );    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> hello. </pre></code><br>'),
(361, 'String Length:', 'Methods used to obtain information about an object are known as accessor methods. One accessor method that you can use with strings is the length() method, which returns the number of characters contained in the string object.Below given program is an example of <b>length()</b> , method String class.This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class StringDemo {     public static void main(String args[]) {       String palindrome = "Dot saw I was Tod";       int len = palindrome.length();       System.out.println( "String Length is : " + len );    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> String Length is : 17 </pre></code><br>'),
(362, 'Concatenating Strings:', 'The String class includes a method for concatenating two strings:This returns a new string that is string1 with string2 added to it at the end. You can also use the concat() method with string literals, as in:Strings are more commonly concatenated with the + operator, as in:which results in:Let us look at the following example:This would produce the following result:', '<br><code><pre class="prettyprint notranslate"> string1.concat(string2); </pre></code><br><br><code><pre class="prettyprint notranslate"> "My name is ".concat("Zara"); </pre></code><br><br><code><pre class="prettyprint notranslate"> "Hello," + " world" + "!" </pre></code><br><br><code><pre class="prettyprint notranslate"> "Hello, world!" </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> public class StringDemo {     public static void main(String args[]) {       String string1 = "saw I was ";       System.out.println("Dot " + string1 + "Tod");    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Dot saw I was Tod </pre></code><br>'),
(363, 'Creating Format Strings:', 'You have printf() and format() methods to print output with formatted numbers. The String class has an equivalent class method, format(), that returns a String object rather than a PrintStream object.Using Strings static format() method allows you to create a formatted string that you can reuse, as opposed to a one-time print statement. For example, instead of:you can write:', '<br><code><pre class="prettyprint notranslate"> System.out.printf("The value of the float variable is " +                   "%f, while the value of the integer " +                   "variable is %d, and the string " +                   "is %s", floatVar, intVar, stringVar); </pre></code><br><br><code><pre class="prettyprint notranslate"> String fs; fs = String.format("The value of the float variable is " +                    "%f, while the value of the integer " +                    "variable is %d, and the string " +                    "is %s", floatVar, intVar, stringVar); System.out.println(fs); </pre></code><br>'),
(364, 'Java - Arrays', 'Java provides a data structure, the <b>array</b>, which stores a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables.This tutorial introduces how to declare array variables, create arrays, and process arrays using indexed variables.', ''),
(365, 'Declaring Array Variables:', 'To use an array in a program, you must declare a variable to reference the array, and you must specify the type of array the variable can reference. Here is the syntax for declaring an array variable:<b>Note:</b> The style <b>dataType[] arrayRefVar</b> is preferred. The style <b>dataType arrayRefVar[]</b> comes from the C/C++ language and was adopted in Java to accommodate C/C++ programmers.', '<br><code><pre class="prettyprint notranslate"> dataType[] arrayRefVar;   // preferred way.  or  dataType arrayRefVar[];  //  works but not preferred way. </pre></code><br>'),
(366, 'Example:', 'The following code snippets are examples of this syntax:', '<br><code><pre class="prettyprint notranslate"> double[] myList;         // preferred way.  or  double myList[];         //  works but not preferred way. </pre></code><br>'),
(367, 'Creating Arrays:', 'You can create an array by using the new operator with the following syntax:The above statement does two things:  <li><p>It creates an array using new dataType[arraySize]; </p></li> <li><p>It assigns the reference of the newly created array to the variable arrayRefVar.</p></li> Declaring an array variable, creating an array, and assigning the reference of the array to the variable can be combined in one statement, as shown below:Alternatively you can create arrays as follows:The array elements are accessed through the <b>index</b>. Array indices are 0-based; that is, they start from 0 to <b>arrayRefVar.length-1</b>.', '<br><code><pre class="prettyprint notranslate"> arrayRefVar = new dataType[arraySize]; </pre></code><br><br><code><pre class="prettyprint notranslate"> dataType[] arrayRefVar = new dataType[arraySize]; </pre></code><br><br><code><pre class="prettyprint notranslate"> dataType[] arrayRefVar = {value0, value1, ..., valuek}; </pre></code><br>'),
(368, 'Example:', 'Following statement declares an array variable, myList, creates an array of 10 elements of double type and assigns its reference to myList:Following picture represents array myList. Here, myList holds ten double values and the indices are from 0 to 9.', '<br><code><pre class="prettyprint notranslate"> double[] myList = new double[10]; </pre></code><br>'),
(369, 'Processing Arrays:', 'When processing array elements, we often use either for loop or foreach loop because all of the elements in an array are of the same type and the size of the array is known.', ''),
(370, 'Example:', 'Here is a complete example of showing how to create, initialize and process arrays:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class TestArray {     public static void main(String[] args) {       double[] myList = {1.9, 2.9, 3.4, 3.5};        // Print all the array elements       for (int i = 0; i &lt; myList.length; i++) {          System.out.println(myList[i] + " ");       }       // Summing all elements       double total = 0;       for (int i = 0; i &lt; myList.length; i++) {          total += myList[i];       }       System.out.println("Total is " + total);       // Finding the largest element       double max = myList[0];       for (int i = 1; i &lt; myList.length; i++) {          if (myList[i] &gt; max) max = myList[i];       }       System.out.println("Max is " + max);    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> 1.9 2.9 3.4 3.5 Total is 11.7 Max is 3.5 </pre></code><br>'),
(371, 'The foreach Loops:', 'JDK 1.5 introduced a new for loop known as foreach loop or enhanced for loop, which enables you to traverse the complete array sequentially without using an index variable. ', ''),
(372, 'Example:', 'The following code displays all the elements in the array myList:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class TestArray {     public static void main(String[] args) {       double[] myList = {1.9, 2.9, 3.4, 3.5};        // Print all the array elements       for (double element: myList) {          System.out.println(element);       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> 1.9 2.9 3.4 3.5 </pre></code><br>');
INSERT INTO `textbook` (`textid`, `topic`, `content`, `code`) VALUES
(373, 'Passing Arrays to Methods:', 'Just as you can pass primitive type values to methods, you can also pass arrays to methods. For example, the following method displays the elements in an int array:You can invoke it by passing an array. For example, the following statement invokes the printArray method to display 3, 1, 2, 6, 4, and 2:', '<br><code><pre class="prettyprint notranslate"> public static void printArray(int[] array) {   for (int i = 0; i &lt; array.length; i++) {     System.out.print(array[i] + " ");   } } </pre></code><br><br><code><pre class="prettyprint notranslate"> printArray(new int[]{3, 1, 2, 6, 4, 2}); </pre></code><br>'),
(374, 'Returning an Array from a Method:', 'A method may also return an array. For example, the method shown below returns an array that is the reversal of another array:', '<br><code><pre class="prettyprint notranslate"> public static int[] reverse(int[] list) {   int[] result = new int[list.length];    for (int i = 0, j = result.length - 1; i &lt; list.length; i++, j--) {     result[j] = list[i];   }   return result; } </pre></code><br>'),
(375, 'Java - Date &amp; Time', 'Java provides the <b>Date</b> class available in <b>java.util</b> package, this class encapsulates the current date and time.The Date class supports two constructors as shown below.Below given are the methods of the date class.', ''),
(376, 'Getting Current Date &amp; Time', 'This is very easy to get current date and time in Java. You can use a simple Date object with <i>toString() </i> method to print current date and time as follows:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.Date;    public class DateDemo {    public static void main(String args[]) {        // Instantiate a Date object        Date date = new Date();                 // display time and date using toString()        System.out.println(date.toString());    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> on May 04 09:51:52 CDT 2009 </pre></code><br>'),
(377, 'Date Comparison:', 'There are following three ways to compare two dates: <li><p>You can use getTime( ) to obtain the number of milliseconds that have elapsed since midnight, January 1, 1970, for both objects and then compare these two values.</p></li> <li><p>You can use the methods before( ), after( ), and equals( ). Because the 12th of the month comes before the 18th, for example, new Date(99, 2, 12).before(new Date (99, 2, 18)) returns true.</p></li> <li><p>You can use the compareTo( ) method, which is defined by the Comparable interface and implemented by Date.</p></li> ', ''),
(378, 'Date Formatting using SimpleDateFormat:', 'SimpleDateFormat is a concrete class for formatting and parsing dates in a locale-sensitive manner. SimpleDateFormat allows you to start by choosing any user-defined patterns for date-time formatting. For example:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.*; import java.text.*;  public class DateDemo {    public static void main(String args[]) {        Date dNow = new Date( );       SimpleDateFormat ft =        new SimpleDateFormat ("E yyyy.MM.dd at hh:mm:ss a zzz");        System.out.println("Current Date: " + ft.format(dNow));    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Current Date: Sun 2004.07.18 at 04:14:09 PM PDT </pre></code><br>'),
(379, 'Simple DateFormat format codes:', 'To specify the time format, use a time pattern string. In this pattern, all ASCII letters are reserved as pattern letters, which are defined as the following:', ''),
(380, 'Date Formatting using printf:', 'Date and time formatting can be done very easily using <b>printf</b> method. You use a two-letter format, starting with <b>t</b> and ending in one of the letters of the table given below. For example:This would produce the following result:It would be a bit silly if you had to supply the date multiple times to format each part. For that reason, a format string can indicate the index of the argument to be formatted.The index must immediately follow the % and it must be terminated by a $. For example:This would produce the following result:Alternatively, you can use the &lt; flag. It indicates that the same argument as in the preceding format specification should be used again. For example:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.Date;  public class DateDemo {    public static void main(String args[]) {      // Instantiate a Date object      Date date = new Date();       // display time and date using toString()      String str = String.format("Current Date/Time : %tc", date );       System.out.printf(str);   } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Current Date/Time : Sat Dec 15 16:37:57 MST 2012 </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> import java.util.Date;    public class DateDemo {     public static void main(String args[]) {        // Instantiate a Date object        Date date = new Date();                 // display time and date using toString()        System.out.printf("%1$s %2$tB %2$td, %2$tY",                           "Due date:", date);    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Due date: February 09, 2004 </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> import java.util.Date;    public class DateDemo {     public static void main(String args[]) {        // Instantiate a Date object        Date date = new Date();                 // display formatted date        System.out.printf("%s %tB %&lt;te, %&lt;tY",                           "Due date:", date);    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Due date: February 09, 2004 </pre></code><br>'),
(381, 'Date and Time Conversion Characters:', 'There are other useful classes related to Date and time. For more details, you can refer to Java Standard documentation.', ''),
(382, 'Parsing Strings into Dates:', 'The SimpleDateFormat  class has some additional methods, notably parse( ) , which tries to parse a string according to the format stored in the given SimpleDateFormat object. For example:A sample run of the above program would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.*; import java.text.*;    public class DateDemo {     public static void main(String args[]) {       SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd");         String input = args.length == 0 ? "1818-11-11" : args[0];         System.out.print(input + " Parses as ");         Date t;         try {            t = ft.parse(input);            System.out.println(t);        } catch (ParseException e) {            System.out.println("Unparseable using " + ft);        }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> $ java DateDemo 1818-11-11 Parses as Wed Nov 11 00:00:00 GMT 1818 $ java DateDemo 2007-12-01 2007-12-01 Parses as Sat Dec 01 00:00:00 GMT 2007 </pre></code><br>'),
(383, 'Sleeping for a While:', 'You can sleep for any period of time from one millisecond up to the lifetime of your computer. For example, following program would sleep for 10 seconds:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.*;    public class SleepDemo {    public static void main(String args[]) {       try {           System.out.println(new Date( ) + "\n");           Thread.sleep(5*60*10);           System.out.println(new Date( ) + "\n");        } catch (Exception e) {            System.out.println("Got an exception!");        }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Sun May 03 18:04:41 GMT 2009  Sun May 03 18:04:51 GMT 2009 </pre></code><br>'),
(384, 'Measuring Elapsed Time:', 'Sometimes, you may need to measure point in time in milliseconds. So lets re-write above example once again:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.*;    public class DiffDemo {     public static void main(String args[]) {       try {          long start = System.currentTimeMillis( );          System.out.println(new Date( ) + "\n");          Thread.sleep(5*60*10);          System.out.println(new Date( ) + "\n");          long end = System.currentTimeMillis( );          long diff = end - start;          System.out.println("Difference is : " + diff);       } catch (Exception e) {          System.out.println("Got an exception!");       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Sun May 03 18:16:51 GMT 2009  Sun May 03 18:16:57 GMT 2009  Difference is : 5993 </pre></code><br>'),
(385, 'GregorianCalendar Class:', 'GregorianCalendar is a concrete implementation of a Calendar class that implements the normal Gregorian calendar with which you are familiar. I did not discuss Calendar class in this tutorial, you can look standard Java documentation for this.The <b>getInstance( )</b> method of Calendar returns a GregorianCalendar initialized with the current date and time in the default locale and time zone. GregorianCalendar defines two fields: AD and BC. These represent the two eras defined by the Gregorian calendar.There are also several constructors for GregorianCalendar objects:Here is the list of few useful support methods provided by GregorianCalendar class:', ''),
(386, 'Java - Regular Expressions', 'Java provides the java.util.regex package for pattern matching with regular expressions. Java regular expressions are very similar to the Perl programming language and very easy to learn.A regular expression is a special sequence of characters that helps you match or find other strings or sets of strings, using a specialized syntax held in a pattern. They can be used to search, edit, or manipulate text and data. The java.util.regex package primarily consists of the following three classes: <li><p><b>Pattern Class:</b> A Pattern object is a compiled representation of a regular expression. The Pattern class provides no public constructors. To create a pattern, you must first invoke one of its public static <b>compile()</b> methods, which will then return a Pattern object. These methods accept a regular expression as the first argument.</p></li> <li><p><b>Matcher Class:</b> A Matcher object is the engine that interprets the pattern and performs match operations against an input string. Like the Pattern class, Matcher defines no public constructors. You obtain a Matcher object by invoking the <b>matcher()</b> method on a Pattern object.</p></li> <li><p><b>PatternSyntaxException:</b> A PatternSyntaxException object is an unchecked exception that indicates a syntax error in a regular expression pattern.</p></li> ', ''),
(387, 'Capturing Groups:', 'Capturing groups are a way to treat multiple characters as a single unit. They are created by placing the characters to be grouped inside a set of parentheses. For example, the regular expression (dog) creates a single group containing the letters "d", "o", and "g".Capturing groups are numbered by counting their opening parentheses from left to right. In the expression ((A)(B(C))), for example, there are four such groups: <li><p>((A)(B(C)))</p></li> <li><p>(A)</p></li> <li><p>(B(C))</p></li> <li><p>(C)</p></li> To find out how many groups are present in the expression, call the groupCount method on a matcher object. The groupCount method returns an int showing the number of capturing groups present in the matchers pattern.There is also a special group, group 0, which always represents the entire expression. This group is not included in the total reported by groupCount.', ''),
(388, 'Example:', 'Following example illustrates how to find a digit string from the given alphanumeric string:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.regex.Matcher; import java.util.regex.Pattern;  public class RegexMatches {     public static void main( String args[] ){        // String to be scanned to find the pattern.       String line = "This order was placed for QT3000! OK?";       String pattern = "(.*)(\\d+)(.*)";        // Create a Pattern object       Pattern r = Pattern.compile(pattern);        // Now create matcher object.       Matcher m = r.matcher(line);       if (m.find( )) {          System.out.println("Found value: " + m.group(0) );          System.out.println("Found value: " + m.group(1) );          System.out.println("Found value: " + m.group(2) );       } else {          System.out.println("NO MATCH");       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Found value: This order was placed for QT3000! OK? Found value: This order was placed for QT300 Found value: 0 </pre></code><br>'),
(389, 'Regular Expression Syntax:', 'Here is the table listing down all the regular expression metacharacter syntax available in Java:', ''),
(390, 'Methods of the Matcher Class:', 'Here is a list of useful instance methods:', ''),
(391, 'Index Methods:', 'Index methods provide useful index values that show precisely where the match was found in the input string:', ''),
(392, 'Study Methods:', 'Study methods review the input string and return a Boolean indicating whether or not the pattern is found:', ''),
(393, 'Replacement Methods:', 'Replacement methods are useful methods for replacing text in an input string:', ''),
(394, 'The <i>start</i> and <i>end</i> Methods:', 'Following is the example that counts the number of times the word "cat" appears in the input string:This would produce the following result:You can see that this example uses word boundaries to ensure that the letters "c" "a" "t" are not merely a substring in a longer word. It also gives some useful information about where in the input string the match has occurred.The start method returns the start index of the subsequence captured by the given group during the previous match operation, and end returns the index of the last character matched, plus one.', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.regex.Matcher; import java.util.regex.Pattern;  public class RegexMatches {     private static final String REGEX = "\\bcat\\b";     private static final String INPUT =                                     "cat cat cat cattie cat";      public static void main( String args[] ){        Pattern p = Pattern.compile(REGEX);        Matcher m = p.matcher(INPUT); // get a matcher object        int count = 0;         while(m.find()) {          count++;          System.out.println("Match number "+count);          System.out.println("start(): "+m.start());          System.out.println("end(): "+m.end());       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> atch number 1 start(): 0 end(): 3 atch number 2 start(): 4 end(): 7 atch number 3 start(): 8 end(): 11 atch number 4 start(): 19 end(): 22 </pre></code><br>'),
(395, 'The <i>matches</i> and <i>lookingAt</i> Methods:', 'The matches and lookingAt methods both attempt to match an input sequence against a pattern. The difference, however, is that matches requires the entire input sequence to be matched, while lookingAt does not.Both methods always start at the beginning of the input string. Here is the example explaining the functionality:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.regex.Matcher; import java.util.regex.Pattern;  public class RegexMatches {     private static final String REGEX = "foo";     private static final String INPUT = "fooooooooooooooooo";     private static Pattern pattern;     private static Matcher matcher;      public static void main( String args[] ){        pattern = Pattern.compile(REGEX);        matcher = pattern.matcher(INPUT);         System.out.println("Current REGEX is: "+REGEX);        System.out.println("Current INPUT is: "+INPUT);         System.out.println("lookingAt(): "+matcher.lookingAt());        System.out.println("matches(): "+matcher.matches());    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Current REGEX is: foo Current INPUT is: fooooooooooooooooo lookingAt(): true matches(): false </pre></code><br>'),
(396, 'The <i>replaceFirst</i> and <i>replaceAll</i> Methods:', 'The replaceFirst and replaceAll methods replace text that matches a given regular expression. As their names indicate, replaceFirst replaces the first occurrence, and replaceAll replaces all occurrences.Here is the example explaining the functionality:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.regex.Matcher; import java.util.regex.Pattern;  public class RegexMatches {     private static String REGEX = "dog";     private static String INPUT = "The dog says meow. " +                                     "All dogs say meow.";     private static String REPLACE = "cat";      public static void main(String[] args) {        Pattern p = Pattern.compile(REGEX);        // get a matcher object        Matcher m = p.matcher(INPUT);         INPUT = m.replaceAll(REPLACE);        System.out.println(INPUT);    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> The cat says meow. All cats say meow. </pre></code><br>'),
(397, 'The <i>appendReplacement</i> and <i>appendTail</i> Methods:', 'The Matcher class also provides appendReplacement and appendTail methods for text replacement. Here is the example explaining the functionality:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> import java.util.regex.Matcher; import java.util.regex.Pattern;  public class RegexMatches {    private static String REGEX = "a*b";    private static String INPUT = "aabfooaabfooabfoob";    private static String REPLACE = "-";    public static void main(String[] args) {       Pattern p = Pattern.compile(REGEX);       // get a matcher object       Matcher m = p.matcher(INPUT);       StringBuffer sb = new StringBuffer();       while(m.find()){          m.appendReplacement(sb,REPLACE);       }       m.appendTail(sb);       System.out.println(sb.toString());    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> -foo-foo-foo- </pre></code><br>'),
(398, 'Java - Methods', 'A Java method is a collection of statements that are grouped together to perform an operation. When you call the System.out.<b>println()</b> method, for example, the system actually executes several statements in order to display a message on the console.Now you will learn how to create your own methods with or without return values, invoke a method with or without parameters, and apply method abstraction in the program design.', ''),
(399, 'Creating Method:', 'Considering the following example to explain the syntax of a method:Here,  <ul class="list"> <li><p><b>public static</b> : modifier.</p></li> <li><p><b>int</b>: return type</p></li> <li><p><b>methodName</b>: name of the method </p></li> <li><p><b>a, b</b>: formal parameters</p></li> <li><p><b>int a, int b</b>: list of parameters</p></li> </ul>  Method definition consists of a method header and a method body. The same is shown below: <pre class="prettyprint notranslate"> modifier returnType nameOfMethod (Parameter List) {  // method body } </pre> The syntax shown above includes: <li><p><b>modifier:</b> It defines the access type of the method and it is optional to use.</p></li> <li><p><b>returnType:</b> Method may return a value. <li><p><b>nameOfMethod:</b> This is the method name. The method signature consists of the method name and the parameter list.</p></li> <li><p><b>Parameter List:</b> The list of parameters, it is the type, order, and number of parameters of a method. These are optional, method may contain zero parameters.</p></li> <li><p><b>method body:</b> The method body defines what the method does with statements.</p></li> </ul> <h2>Example:</h2> <p>Here is the source code of the above defined  method called max(). This method takes two parameters num1 and num2 and returns the maximum between the two:</p>  <pre class="prettyprint notranslate"> /** the snippet returns the minimum between two numbers */ public static int minFunction(int n1, int n2) {    int min;    if (n1 &gt; n2)       min = n2;    else       min = n1;     return min;  } </pre> <h2>Method Calling:</h2> <p>For using a method, it should be called. There are two ways in which a method is called i.e. method returns a value or returning nothing (no return value).</p> <p>The process of method calling is simple. When a program invokes a method, the program control gets transferred to the called method. This called method then returns control to the caller in two conditions, when: <ul class="list"> <li><p>return statement is executed.</p></li> <li><p>reaches the method ending closing brace.</p></li> </ul> <p>The methods returning void is considered as call to a statement. Lets consider an example:</p> <pre class="prettyprint notranslate"> System.out.println("This is tutorialspoint.com!"); </pre> <p>The method returning value can be understood by the following example:</p> <pre class="prettyprint notranslate"> int result = sum(6, 9); </pre> <h2>Example:</h2> <p>Following is the example to demonstrate how to define a method and how to call it:</p> <pre class="prettyprint notranslate tryit"> public class ExampleMinNumber{        public static void main(String[] args) {       int a = 11;       int b = 6;       int c = minFunction(a, b);       System.out.println("Minimum Value = " + c);    }     /** returns the minimum of two numbers */    public static int minFunction(int n1, int n2) {       int min;       if (n1 &gt; n2)          min = n2;       else          min = n1;        return min;     } } </pre> <p>This would produce the following result:</p> <pre class="prettyprint notranslate"> inimum value = 6 </pre> <h2>The void Keyword:</h2> <p>The void keyword allows us to create methods which do not return a value. Here, in the following example were considering a void method <i>methodRankPoints</i>. This method is a void method which does not return any value. Call to a void method must be a statement i.e. <i>methodRankPoints(255.7);</i>. It is a Java statement which ends with a semicolon as shown below.</p> <h2>Example:</h2> <pre class="prettyprint notranslate tryit"> public class ExampleVoid {     public static void main(String[] args) {       methodRankPoints(255.7);    }     public static void methodRankPoints(double points) {       if (points &gt;= 202.5) {          System.out.println("Rank:A1");       }       else if (points &gt;= 122.4) {          System.out.println("Rank:A2");       }       else {          System.out.println("Rank:A3");       }    } } </pre> <p>This would produce the following result:</p> <pre class="prettyprint notranslate"> Rank:A1 </pre> <h2>Passing Parameters by Value:</h2> <p> While working under calling process, arguments is to be passed. These should be in the same order as their respective parameters in the method specification. Parameters can be passed by value or by reference.</p> <p>Passing Parameters by Value means calling a method with a parameter. Through this the argument value is passed to the parameter.</p> <h2>Example:</h2> <p>The following program shows an example of passing parameter by value. The values of the arguments remains the same even after the method invocation.</p> <pre class="prettyprint notranslate tryit"> public class swappingExample {     public static void main(String[] args) {       int a = 30;       int b = 45;        System.out.println("Before swapping, a = " +                           a + " and b = " + b);        // Invoke the swap method       swapFunction(a, b);       System.out.println("\n**Now, Before and After swapping values will be same here**:");       System.out.println("After swapping, a = " +                          a + " and b is " + b);    }     public static void swapFunction(int a, int b) {           System.out.println("Before swapping(Inside), a = " + a                            + " b = " + b);       // Swap n1 with n2       int c = a;       a = b;       b = c;        System.out.println("After swapping(Inside), a = " + a                            + " b = " + b);    } } </pre> <p>This would produce the following result:</p> <pre class="prettyprint notranslate"> Before swapping, a = 30 and b = 45 Before swapping(Inside), a = 30 b = 45 After swapping(Inside), a = 45 b = 30  **Now, Before and After swapping values will be same here**: After swapping, a = 30 and b is 45 </pre>  <h2>Method Overloading:</h2> <p>When a class has two or more methods by same name but different parameters, it is known as method overloading. It is different from overriding. In overriding a method has same method name, type, number of parameters etc.</p> <p>Lets consider the example shown before for finding minimum numbers of integer type. If, lets say we want to find minimum number of double type. Then the concept of Overloading will be introduced to create two or more methods with the same name but different parameters.<p> <p></p> <p>The below example explains the same:</p> <pre class="prettyprint notranslate tryit"> public class ExampleOverloading{     public static void main(String[] args) {       int a = 11;       int b = 6;       double c = 7.3;       double d = 9.4;       int result1 = minFunction(a, b);       // same function name with different parameters       double result2 = minFunction(c, d);       System.out.println("Minimum Value = " + result1);       System.out.println("Minimum Value = " + result2);    }    // for integer    public static int minFunction(int n1, int n2) {       int min;       if (n1 &gt; n2)          min = n2;       else          min = n1;        return min;     }    // for double    public static double minFunction(double n1, double n2) {      double min;       if (n1 &gt; n2)          min = n2;       else          min = n1;        return min;     } } </pre> <p>This would produce the following result:</p> <pre class="prettyprint notranslate"> inimum Value = 6 inimum Value = 7.3 </pre> <p>Overloading methods makes program readable. Here, two methods are given same name but with different parameters. The minimum number from integer and double types is the result.</p>                  <h2>Using Command-Line Arguments:</h2> <p>Sometimes you will want to pass information into a program when you run it. This is accomplished by passing command-line arguments to main( ).</p> <p>A command-line argument is the information that directly follows the programs name on the command line when it is executed. To access the command-line arguments inside a Java program is quite easy.they are stored as strings in the String array passed to main( ).</p> <h2>Example:</h2> <p>The following program displays all of the command-line arguments that it is called with:</p> <pre class="prettyprint notranslate"> public class CommandLine {     public static void main(String args[]){        for(int i=0; i&lt;args.length; i++){          System.out.println("args[" + i + "]: " +                                            args[i]);       }    } } </pre> <p>Try executing this program as shown here:</p> <pre class="prettyprint notranslate"> $java CommandLine this is a command line 200 -100 </pre> <p>This would produce the following result:</p> <pre class="result notranslate"> args[0]: this args[1]: is args[2]: a args[3]: command args[4]: line args[5]: 200 args[6]: -100 </pre> <h2>The Constructors:</h2> <p>A constructor initializes an object when it is created. It has the same name as its class and is syntactically similar to a method. However, constructors have no explicit return type.</p> <p>Typically, you will use a constructor to give initial values to the instance variables defined by the class, or to perform any other startup procedures required to create a fully formed object.</p> <p>All classes have constructors, whether you define one or not, because Java automatically provides a default constructor that initializes all member variables to zero. However, once you define your own constructor, the default constructor is no longer used.</p> <h2>Example:</h2> <p>Here is a simple example that uses a constructor without parameters:</p> <pre class="prettyprint notranslate" id="cons1"> // A simple constructor. class MyClass {    int x;        // Following is the constructor    MyClass() {       x = 10;    } } </pre> <p>You would call constructor to initialize objects as follows:</p> <pre class="prettyprint notranslate tryit" title="cons1"> public class ConsDemo {     public static void main(String args[]) {       MyClass t1 = new MyClass();       MyClass t2 = new MyClass();       System.out.println(t1.x + " " + t2.x);    } } </pre> <h3>parametarized constructor</h3> <p>Most often, you will need a constructor that accepts one or more parameters. Parameters are added to a constructor in the same way that they are added to a method, just declare them inside the parentheses after the constructors name.</p> <h2>Example:</h2> <p>Here is a simple example that uses a constructor with parameter:</p> <pre class="prettyprint notranslate" id="cons2"> // A simple constructor. class MyClass {    int x;        // Following is the constructor    MyClass(int i ) {       x = i;    } } </pre> <p>You would call constructor to initialize objects as follows:</p> <pre class="prettyprint notranslate tryit" title="cons2"> public class ConsDemo {     public static void main(String args[]) {       MyClass t1 = new MyClass( 10 );       MyClass t2 = new MyClass( 20 );       System.out.println(t1.x + " " + t2.x);    } } </pre> <p>This would produce the following result:</p> <pre class="prettyprint notranslate"> 10 20 </pre>  <h2>The this keyword</h2> <p><b>this</b> is a keyword in Java which is used as a reference to the object of the current class, with in an instance method or a constructor. Using <i>this</i> you can refer the members of a class such as constructors, variables and methods.</p> <p><b>Note</b>The keyword <i>this</i> is used only within instance methods or constructors</p> <img src="/java/images/this.jpg" alt="Java Tutorial" /> <p>&nbsp;</p> In general the keyword <i>this</i> is used to : <ul class="list"> <li><p>Differentiate the instance variables from local variables if they have same names, within a constructor or a method.</p></li></ul> <pre class="prettyprint notranslate"> class Student{     int age;       Student(int age){    this.age=age;	    }  } </pre> <ul class="list"> <li><p>Call  one type of constructor( parametrized constructor or default ) from other in a class. It is known as explicit constructor invocation .</p></li></ul> <pre class="prettyprint notranslate"> class Student{     int age    Student(){    this(20);    }        Student(int age){    this.age=age;	    }  } </pre> ', '<br><code><pre class="prettyprint notranslate"> public static int methodName(int a, int b) {   // body } </pre></code><br>'),
(400, 'Example', 'Here is an example that uses <i>this</i> keyword to access the members of a class. Copy and paste the below given program in a file with name This_Example.java', '<br><code><pre class="prettyprint notranslate tryit"> public class This_Example { 	    //Instance variable num    int num=10; 	    This_Example(){       System.out.println("This is an example program on keyword this ");	    }     This_Example(int num){       //Invoking the default constructor       this();              //Assigning the local variable <i>num</i> to the instance variable <i>num</i>       this.num=num;	       }        public void greet(){       System.out.println("Hi Welcome to Tutorialspoint");    }           public void print(){       //Local variable num       int num=20;              //Printing the instance variable       System.out.println("value of local variable num is : "+num);              //Printing the local variable       System.out.println("value of instance variable num is : "+this.num);              //Invoking the greet method of a class       this.greet();         }        public static void main(String[] args){       //Instantiating the class       This_Example obj1=new This_Example();              //Invoking the print method       obj1.print(); 	         //Passing a new value to the num variable through parametrized constructor       This_Example obj2=new This_Example(30);              //Invoking the print method again       obj2.print();     }  }  </pre></code><br><br><code><pre class="result notranslate"> This is an example program on keyword this  value of local variable num is : 20 value of instance variable num is : 10 Hi Welcome to Tutorialspoint This is an example program on keyword this  value of local variable num is : 20 value of instance variable num is : 30 Hi Welcome to Tutorialspoint </pre></code><br>'),
(401, 'Variable Arguments(var-args):', 'JDK 1.5 enables you to pass a variable number of arguments of the same type to a method. The parameter in the method is declared as follows:In the method declaration, you specify the type followed by an ellipsis (...) Only one variable-length parameter may be specified in a method, and this parameter must be the last parameter. Any regular parameters must precede it.', '<br><code><pre class="prettyprint notranslate"> typeName... parameterName </pre></code><br>'),
(402, 'Example:', 'This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class VarargsDemo {     public static void main(String args[]) {       // Call method with variable args   	  printMax(34, 3, 3, 2, 56.5);       printMax(new double[]{1, 2, 3});    }     public static void printMax( double... numbers) {    if (numbers.length == 0) {       System.out.println("No argument passed");       return;    }     double result = numbers[0];     for (int i = 1; i &lt;  numbers.length; i++)       if (numbers[i] &gt;  result)       result = numbers[i];       System.out.println("The max value is " + result);    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> The max value is 56.5 The max value is 3.0 </pre></code><br>'),
(403, 'Java - Files and I/O', 'The java.io package contains nearly every class you might ever need to perform input and output (I/O) in Java. All these streams represent an input source and an output destination. The stream in the java.io package supports many data  such as primitives, Object, localized characters, etc.', ''),
(404, 'Stream', 'A stream can be defined as a sequence of data. there are two kinds of Streams<ul class="list"> <li><p><b>InPutStream:</b> The InputStream is used to read data from a source.</p></li> <li><p><b>OutPutStream:</b> the OutputStream is used for writing data to a destination.</p></li> </ul> &nbsp;&nbsp;Java provides strong but flexible support for I/O related to Files and networks but this tutorial covers very basic functionality related to streams and I/O. We would see most commonly used example one by one:', ''),
(405, 'Byte Streams', 'Java byte streams are used to perform input and output of 8-bit bytes. Though there are many classes  related to byte streams but the most frequently used classes are , <b>FileInputStream</b> and <b>FileOutputStream</b>. Following is an example which makes use of these two classes to copy an input file into an output file:Now lets have a file <b>input.txt</b> with the following content:As a next step, compile above program and execute it, which will result in creating output.txt file with the same content as we have in input.txt. So lets put above code in CopyFile.java file and do the following:', '<br><code><pre class="prettyprint notranslate"> import java.io.*;  public class CopyFile {    public static void main(String args[]) throws IOException    {       FileInputStream in = null;       FileOutputStream out = null;        try {          in = new FileInputStream("input.txt");          out = new FileOutputStream("output.txt");                    int c;          while ((c = in.read()) != -1) {             out.write(c);          }       }finally {          if (in != null) {             in.close();          }          if (out != null) {             out.close();          }       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> This is test for copy file. </pre></code><br><br><code><pre class="prettyprint notranslate"> $javac CopyFile.java $java CopyFile </pre></code><br>'),
(406, 'Character Streams', 'Java <b>Byte</b> streams  are used to perform input and output of 8-bit bytes, where as Java <b>Character</b> streams are used to perform input and output for 16-bit unicode. Though there are many classes  related to character streams but the most frequently used classes are , <b>FileReader </b> and <b>FileWriter.</b>. Though internally FileReader uses FileInputStream and FileWriter uses FileOutputStream but here major difference is that FileReader reads two bytes at a time and  FileWriter writes two bytes at a time.We can re-write above example which makes use of these two classes to copy an input file (having unicode characters) into an output file:Now lets have a file <b>input.txt</b> with the following content:As a next step, compile above program and execute it, which will result in creating output.txt file with the same content as we have in input.txt. So lets put above code in CopyFile.java file and do the following:', '<br><code><pre class="prettyprint notranslate"> import java.io.*;  public class CopyFile {    public static void main(String args[]) throws IOException    {       FileReader in = null;       FileWriter out = null;        try {          in = new FileReader("input.txt");          out = new FileWriter("output.txt");                    int c;          while ((c = in.read()) != -1) {             out.write(c);          }       }finally {          if (in != null) {             in.close();          }          if (out != null) {             out.close();          }       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> This is test for copy file. </pre></code><br><br><code><pre class="prettyprint notranslate"> $javac CopyFile.java $java CopyFile </pre></code><br>'),
(407, 'Standard Streams', 'All the programming languages provide support for standard I/O where users program can take input from a keyboard and then produce output on the computer screen. If you are aware if C or C++ programming languages, then you must be aware of three standard  devices STDIN, STDOUT and STDERR. Similar way Java provides following three standard streams  <li><p><b>Standard Input:</b> This is used to feed the data to users program and usually a keyboard is used as standard input stream and represented as <b>System.in</b>.</p></li> <li><p><b>Standard Output:</b> This is used to output the data produced by the users program and usually a computer screen is used to standard output stream and represented as <b>System.out</b>.</p></li> <li><p><b>Standard Error:</b> This is used to output the error data produced by the users program and usually a computer screen is used to standard error stream and represented as <b>System.err</b>.</p></li> Following is a simple program which creates <b>InputStreamReader</b> to read standard input stream until the user types a "q":Lets keep above code in ReadConsole.java file and try to compile and execute it as below. This program continues reading and outputting same character until we press q:', '<br><code><pre class="prettyprint notranslate tryit"> import java.io.*;  public class ReadConsole {    public static void main(String args[]) throws IOException    {       InputStreamReader cin = null;        try {          cin = new InputStreamReader(System.in);          System.out.println("Enter characters, q to quit.");          char c;          do {             c = (char) cin.read();             System.out.print(c);          } while(c != q);       }finally {          if (cin != null) {             cin.close();          }       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> $javac ReadConsole.java $java ReadConsole Enter characters, q to quit. 1 1 e e q q </pre></code><br>'),
(408, 'Reading and Writing Files:', 'As described earlier, A stream can be defined as a sequence of data. The <b>InputStream</b> is used to read data from a source and the <b>OutputStream</b> is used for writing data to a destination.Here is a hierarchy of classes to deal with Input and Output streams.The two important streams are <b>FileInputStream</b> and <b>FileOutputStream</b>, which would be discussed in this tutorial:', ''),
(409, 'FileInputStream:', 'This stream is used for reading data from the files. Objects can be created using the keyword new and there are several types of constructors available.Following constructor takes a file name as a string to create an input stream object to read the file.:Following constructor takes a file object to create an input stream object to read the file. First we create a file object using File() method as follows:Once you have <i>InputStream</i> object in hand, then there is a list of helper methods which can be used to read to stream or to do other operations on the stream.There are other important input streams available, for more detail you can refer to the following links: <li><p><a href="/java/java_bytearrayinputstream.htm" title="ByteArrayInputStream">ByteArrayInputStream</a></p></li> <li><p><a href="/java/java_datainputstream.htm" title="DataInputStream">DataInputStream</a></p></li> ', '<br><code><pre class="prettyprint notranslate"> InputStream f = new FileInputStream("C:/java/hello"); </pre></code><br><br><code><pre class="prettyprint notranslate"> File f = new File("C:/java/hello"); InputStream f = new FileInputStream(f); </pre></code><br>'),
(410, 'FileOutputStream:', 'FileOutputStream is used to create a file and write data into it. The stream would create a file, if it doesnt already exist, before opening it for output.Here are two constructors which can be used to create a FileOutputStream object.Following constructor takes a file name as a string to create an input stream object to write the file:Following constructor takes a file object to create an output stream object to write the file. First, we create a file object using File() method as follows:Once you have <i>OutputStream</i> object in hand, then there is a list of helper methods, which can be used to write to stream or to do other operations on the stream.There are other important output streams available, for more detail you can refer to the following links: <li><p><a href="/java/java_bytearrayoutputstream.htm" title="ByteArrayOutputStream">ByteArrayOutputStream</a></p></li> <li><p><a href="/java/java_dataoutputstream.htm" title="DataOutputStream">DataOutputStream</a></p></li> ', '<br><code><pre class="prettyprint notranslate"> OutputStream f = new FileOutputStream("C:/java/hello")  </pre></code><br><br><code><pre class="prettyprint notranslate"> File f = new File("C:/java/hello"); OutputStream f = new FileOutputStream(f); </pre></code><br>'),
(411, 'Example:', 'Following is the example to demonstrate InputStream and OutputStream:The above code would create file test.txt and would write given numbers in binary format. Same would be output on the stdout screen.', '<br><code><pre class="prettyprint notranslate"> import java.io.*;  public class fileStreamTest{     public static void main(String args[]){        try{       byte bWrite [] = {11,21,3,40,5};       OutputStream os = new FileOutputStream("test.txt");       for(int x=0; x &lt; bWrite.length ; x++){          os.write( bWrite[x] ); // writes the bytes       }       os.close();             InputStream is = new FileInputStream("test.txt");       int size = is.available();        for(int i=0; i&lt; size; i++){          System.out.print((char)is.read() + "  ");       }       is.close();    }catch(IOException e){       System.out.print("Exception");    }	    } } </pre></code><br>'),
(412, 'File Navigation and I/O:', 'There are several other classes that we would be going through to get to know the basics of File Navigation and I/O. <li><p><a href="/java/java_file_class.htm" title="File Class">File Class</a></p></li> <li><p><a href="/java/java_filereader_class.htm" title="FileReader  Class">FileReader  Class</a></p></li> <li><p><a href="/java/java_filewriter_class.htm" title="FileWriter  Class">FileWriter  Class</a></p></li> ', ''),
(413, 'Directories in Java:', 'A directory is a File which can contains a list of other files and directories. You use <b>File</b> object to create directories, to list down files available in a directory. For complete detail check a list of all the methods which you can call on File object and what are related to directories.', ''),
(414, 'Creating Directories:', 'There are two useful <b>File</b> utility methods, which can be used to create directories: <li><p>The <b>mkdir( )</b> method creates a directory, returning true on success and false on failure. Failure indicates that the path specified in the File object already exists, or that the directory cannot be created because the entire path does not exist yet.</p></li> <li><p>The <b>mkdirs()</b> method creates both a directory and all the parents of the directory.</p></li> Following example creates "/tmp/user/java/bin" directory:Compile and execute above code to create "/tmp/user/java/bin".<b>Note:</b> Java  automatically takes care of path separators on UNIX and Windows as per conventions. If you use a forward slash (/) on a Windows version of Java, the path will still resolve correctly.', '<br><code><pre class="prettyprint notranslate"> import java.io.File;  public class CreateDir {    public static void main(String args[]) {       String dirname = "/tmp/user/java/bin";       File d = new File(dirname);       // Create directory now.       d.mkdirs();   } } </pre></code><br>'),
(415, 'Java - Exceptions', 'An exception (or exceptional event) is a problem that arises during the <b>execution</b> of a program. When an Exception occurs the normal flow of the program is disrupted and the program/Application terminates abnormally, which is not recommended, therefore these exceptions are to be handled. An exception can occur for many different reasons, below given are some scenarios where exception occurs. <li><p>A user has entered invalid data.</p></li> <li><p>A file that needs to be opened cannot be found.</p></li> <li><p>A network connection has been lost in the middle of communications or the JVM has run out of memory.</p></li> Some of these exceptions are caused by user error, others by programmer error, and others by physical resources that have failed in some manner.Based on these we have three categories of Exceptions  you need to understand them to know how exception handling works in Java,  <li><p><b>Checked exceptions:</b> A checked exception is an exception that occurs at the compile time, these are also called as compile time exceptions. These exceptions cannot simply be ignored at the time of compilation, the Programmer should take care of (handle) these exceptions.<p> </p> For example, if you use <b>FileReader</b> class in your program to read data from a file, if the file specified in its constructor doesnt exist, then an <i>FileNotFoundException </i>occurs, and compiler prompts the programmer to handle the exception.</p></li>&nbsp;<b>Note:</b> Since the methods <b>read()</b> and <b>close()</b> of FileReader class throws IOException, you can observe that compiler notifies to handle IOException, along with FileNotFoundException. <li><p><b>Unchecked exceptions:</b> An Unchecked  exception is an exception that occurs at the time of execution, these are also called as Runtime Exceptions, these include programming bugs, such as logic errors or improper use of an API. runtime exceptions are ignored at the time of compilation.</p> <p>For example, if you have declared an array of size 5 in your program, and trying to call the 6th element of the array then an <i>ArrayIndexOutOfBoundsExceptionexception</i> occurs.</p></li> If you compile and execute the above program you will get exception as shown below. <li><p><b>Errors:</b> These are not exceptions at all, but problems that arise beyond the control of the user or the programmer. Errors are typically ignored in your code because you can rarely do anything about an error. For example, if a stack overflow occurs, an error will arise. They are also ignored at the time of compilation.</p></li> ', '<br><code><pre class="prettyprint notranslate"> import java.io.File; import java.io.FileReader;  public class FilenotFound_Demo {     public static void main(String args[]){		       File file=new File("E://file.txt");       FileReader fr = new FileReader(file);     }     } </pre></code><br><br><code><pre class="prettyprint notranslate"> C:>javac FilenotFound_Demo.java FilenotFound_Demo.java:8: error: unreported exception FileNotFoundException; must be caught or declared to be thrown       FileReader fr = new FileReader(file);                       ^ 1 error </pre></code><br><br><code><pre class="prettyprint notranslate"> public class Unchecked_Demo {        public static void main(String args[]){       int num[]={1,2,3,4};       System.out.println(num[5]);    }  } </pre></code><br><br><code><pre class="prettyprint notranslate"> Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 5 	at Exceptions.Unchecked_Demo.main(Unchecked_Demo.java:8) </pre></code><br>');
INSERT INTO `textbook` (`textid`, `topic`, `content`, `code`) VALUES
(416, 'Exception Hierarchy:', 'All exception classes are subtypes of the java.lang.Exception class. The exception class is a subclass of the Throwable class. Other than the exception class there is another subclass called Error which is derived from the Throwable class.Errors are abnormal conditions that happen in case of severe failures, these are not handled by the java programs. Errors are generated to indicate errors generated by the runtime environment. Example : JVM is out of Memory. Normally programs cannot recover from errors.The Exception class has two main subclasses: IOException class and RuntimeException Class.Here is a list of most common checked and unchecked <a href="/java/java_builtin_exceptions.htm">Javas Built-in Exceptions</a>.', ''),
(417, 'Exceptions Methods:', 'Following is the list of important medthods available in the Throwable class.', ''),
(418, 'Catching Exceptions:', 'A method catches an exception using a combination of the <b>try</b> and <b>catch</b> keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following:The code which is prone to exceptions is placed in the try block, when an exception occurs, that exception occurred is handled by catch block associated with it. Every try block should be immediately followed either by a catch block or finally block. A catch statement involves declaring the type of exception you are trying to catch. If an exception occurs in protected code, the catch block (or blocks) that follows the try is checked. If the type of exception that occurred is listed in a catch block, the exception is passed to the catch block much as an argument is passed into a method parameter.', '<br><code><pre class="prettyprint notranslate"> try {    //Protected code }catch(ExceptionName e1) {    //Catch block } </pre></code><br>'),
(419, 'Example:', 'The following is an array is declared with 2 elements. Then the code tries to access the 3rd element of the array which throws an exception.This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> // File Name : ExcepTest.java import java.io.*; public class ExcepTest{     public static void main(String args[]){       try{          int a[] = new int[2];          System.out.println("Access element three :" + a[3]);       }catch(ArrayIndexOutOfBoundsException e){          System.out.println("Exception thrown  :" + e);       }       System.out.println("Out of the block");    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3 Out of the block </pre></code><br>'),
(420, 'Multiple catch Blocks:', 'A try block can be followed by multiple catch blocks. The syntax for multiple catch blocks looks like the following:The previous statements demonstrate three catch blocks, but you can have any number of them after a single try. If an exception occurs in the protected code, the exception is thrown to the first catch block in the list. If the data type of the exception thrown matches ExceptionType1, it gets caught there. If not, the exception passes down to the second catch statement. This continues until the exception either is caught or falls through all catches, in which case the current method stops execution and the exception is thrown down to the previous method on the call stack.', '<br><code><pre class="prettyprint notranslate"> try {    //Protected code }catch(ExceptionType1 e1) {    //Catch block }catch(ExceptionType2 e2) {    //Catch block }catch(ExceptionType3 e3) {    //Catch block } </pre></code><br>'),
(421, 'Example:', 'Here is code segment showing how to use multiple try/catch statements.', '<br><code><pre class="prettyprint notranslate"> try {    file = new FileInputStream(fileName);    x = (byte) file.read(); }catch(IOException i) {    i.printStackTrace();    return -1; }catch(FileNotFoundException f) //Not valid! {    f.printStackTrace();    return -1; } </pre></code><br>'),
(422, 'Catching multiple type of exceptions', 'Since Java 7 you can handle more than one exceptions using a single catch block, this feature simplifies the code. Below given is the syntax of writing  ', '<br><code><pre class="prettyprint notranslate"> catch (IOException|FileNotFoundException ex) {    logger.log(ex);    throw ex; </pre></code><br>'),
(423, 'The throws/throw Keywords:', 'If a method does not handle a checked exception, the method must declare it using the <b>throws </b> keyword. The throws keyword appears at the end of a methods signature.You can throw an exception, either a newly instantiated one or an exception that you just caught, by using the <b>throw</b> keyword.The following method declares that it throws a RemoteException:A method can declare that it throws more than one exception, in which case the exceptions are declared in a list separated by commas. For example, the following method declares that it throws a RemoteException and an InsufficientFundsException:', '<br><code><pre class="prettyprint notranslate"> import java.io.*; public class className {    public void deposit(double amount) throws RemoteException    {       // Method implementation       throw new RemoteException();    }    //Remainder of class definition } </pre></code><br><br><code><pre class="prettyprint notranslate"> import java.io.*; public class className {    public void withdraw(double amount) throws RemoteException,                               InsufficientFundsException    {        // Method implementation    }    //Remainder of class definition } </pre></code><br>'),
(424, 'The finally block', 'The finally block follows a try block or a catch block. A finally block of code always executes, irrespective of occurrence of an Exception.Using a finally block allows you to run any cleanup-type statements that you want to execute, no matter what happens in the protected code.A finally block appears at the end of the catch blocks and has the following syntax:', '<br><code><pre class="prettyprint notranslate"> try {    //Protected code }catch(ExceptionType1 e1) {    //Catch block }catch(ExceptionType2 e2) {    //Catch block }catch(ExceptionType3 e3) {    //Catch block }finally {    //The finally block always executes. } </pre></code><br>'),
(425, 'Example:', 'This would produce the following result:Note the following: <li><p>A catch clause cannot exist without a try statement. </p></li> <li><p>It is not compulsory to have finally clauses when ever a try/catch block is present. </p></li> <li><p>The try block cannot be present without either catch clause or finally clause.</p></li> <li><p>Any code cannot be present in between the try, catch, finally blocks. </p></li> ', '<br><code><pre class="prettyprint notranslate tryit"> public class ExcepTest{     public static void main(String args[]){       int a[] = new int[2];       try{          System.out.println("Access element three :" + a[3]);       }catch(ArrayIndexOutOfBoundsException e){          System.out.println("Exception thrown  :" + e);       }       finally{          a[0] = 6;          System.out.println("First element value: " +a[0]);          System.out.println("The finally statement is executed");       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3 First element value: 6 The finally statement is executed </pre></code><br>'),
(426, 'The try-with-resources', 'Generally when we use any resources like streams, connections etc.. we have to close them explicitly using finally block. In the program given below we are reading data from a file using <b>FileReader</b> and we are closing it using finally block.<b>try-with-resources</b>, also referred as <b>automatic resource management</b>. is a new exception handling mechanism that was introduced in Java7, which automatically closes the resources used within the try catch block.To use this statement you simply need to declare the required resources within the parenthesis, the created resource will be closed automatically at the end of the block, below given is the syntax of try-with-resources statement. Below given is the program that reads the data in a file using try-with-resources statement.Following points are to be kept in mind while working with try-with resources statement. <li><p>To use a class with try-with-resources statement it should implement <b>AutoCloseable</b> interface and the <b>close()</b> method of it gets invoked automatically at runtime. </p></li> <li><p>You can declare more than one class in try-with-resources statement.</p></li> <li><p>while you declare multiple classes in the try block of try-with-resources statement these classes are closed in reverse order.</p></li> <li><p>Except the deceleration of resources within the parenthesis every thing is same as normal try/catch block of a try block.</p></li> <li><p>The resource declared in try gets instantiated just before the start of the try-block.</p></li> <li><p>The resource declared at the try block is implicitly declared as final. </p></li> ', '<br><code><pre class="prettyprint notranslate"> import java.io.File; import java.io.FileReader; import java.io.IOException;  public class ReadData_Demo {     public static void main(String args[]){       FileReader fr=null;		       try{          File file=new File("file.txt");          fr = new FileReader(file);  char [] a = new char[50];          fr.read(a); // reads the content to the array          for(char c : a)          System.out.print(c); //prints the characters one by one       }catch(IOException e){           e.printStackTrace();        }        finally{	           try{               fr.close();           }catch(IOException ex){		                ex.printStackTrace();            }        }     }  } </pre></code><br><br><code><pre class ="prettyprint notranslate"> try(FileReader fr=new FileReader("file path"))    {    //use the resource    }catch(){       //body of catch      }    } </pre></code><br><br><code><pre class ="prettyprint notranslate"> import java.io.FileReader; import java.io.IOException;  public class Try_withDemo {     public static void main(String args[]){       		       try(FileReader fr=new FileReader("E://file.txt")){          char [] a = new char[50];          fr.read(a); // reads the contentto the array          for(char c : a)          System.out.print(c); //prints the characters one by one       }catch(IOException e){           e.printStackTrace();        }       } } </pre></code><br>'),
(427, 'User-defined Exceptions:', 'You can create your own exceptions in Java. Keep the following points in mind when writing your own exception classes: <li><p>All exceptions must be a child of Throwable.</p></li> <li><p>If you want to write a checked exception that is automatically enforced by the Handle or Declare Rule, you need to extend the Exception class.</p></li> <li><p>If you want to write a runtime exception, you need to extend the RuntimeException class.</p></li> We can define our own Exception class as below:You just need to extend the predefined  <b>Exception</b> class to create your own Exception. These are considered to be checked exceptions. The following <b>InsufficientFundsException</b> class is a user-defined exception that extends the Exception class, making it a checked exception. An exception class is like any other class, containing useful fields and methods.', '<br><code><pre class="prettyprint notranslate"> class MyException extends Exception{ } </pre></code><br>'),
(428, 'Example:', 'To demonstrate using our user-defined exception, the following CheckingAccount class contains a withdraw() method that throws an InsufficientFundsException.The following BankDemo program demonstrates invoking the deposit() and withdraw() methods of CheckingAccount.Compile all the above three files and run BankDemo, this would produce the following result:', '<br><code><pre class="prettyprint notranslate" id="exception"> // File Name InsufficientFundsException.java import java.io.*;  public class InsufficientFundsException extends Exception {    private double amount;    public InsufficientFundsException(double amount)    {       this.amount = amount;    }     public double getAmount()    {       return amount;    } } </pre></code><br><br><code><pre class="prettyprint notranslate" id="account"> // File Name CheckingAccount.java import java.io.*;  public class CheckingAccount {    private double balance;    private int number;        public CheckingAccount(int number)    {       this.number = number;    }        public void deposit(double amount)    {       balance += amount;    }        public void withdraw(double amount) throws InsufficientFundsException    {       if(amount &lt;= balance)       {          balance -= amount;       }       else       {          double needs = amount - balance;          throw new InsufficientFundsException(needs);       }    }        public double getBalance()    {       return balance;    }        public int getNumber()    {       return number;    } } </pre></code><br><br><code><pre class="prettyprint notranslate tryit" title="exception, account"> // File Name BankDemo.java public class BankDemo {    public static void main(String [] args)    {       CheckingAccount c = new CheckingAccount(101);       System.out.println("Depositing $500...");       c.deposit(500.00);              try       {          System.out.println("\nWithdrawing $100...");          c.withdraw(100.00);          System.out.println("\nWithdrawing $600...");          c.withdraw(600.00);       }catch(InsufficientFundsException e)       {          System.out.println("Sorry, but you are short $" + e.getAmount());          e.printStackTrace();       }     } } </pre></code><br><br><code><pre class="result notranslate"> Depositing $500...  Withdrawing $100...  Withdrawing $600... Sorry, but you are short $200.0 InsufficientFundsException         at CheckingAccount.withdraw(CheckingAccount.java:25)         at BankDemo.main(BankDemo.java:13) </pre></code><br>'),
(429, 'Nested Classes', 'In Java, just like methods, variables of a class too can have another class as its member. Writing a class within another is allowed in Java. The class written within is called the <b>nested class</b>, and the class that holds the inner class is called the <b>outer class</b>.', ''),
(430, 'Syntax', 'The syntax to write a nested class is given below. Here the class <b>Outer_Demo</b> is the outer class and the class <b>Inner_Demo</b> is the nested class.Nested classes are divided into two types:  <li><p><b>Non-static nested classes: </b>These are the non-static members of a class. </p></li> <li><p><b>Static nested classes: </b>These are the static members of a class.</p></li> &nbsp;', '<br><code><pre class="prettyprint notranslate"> class Outer_Demo{    class Nested_Demo{       }    } </pre></code><br>'),
(431, 'Inner Classes (Non-static Nested Classes)', 'Inner classes are a security mechanism in Java. We know a class cannot be associated with the access modifier <b>private</b>, but if we have the class as a member of other class, then the inner class can be made private. And this is also used to access the private members of a class. Inner classes are of three types depending on how and where you define them. They are: <li>Inner Class</li> <li>Method-local Inner Classlass</li> <li>Anonymous Inner Class</li> ', ''),
(432, 'Inner Class', 'Creating an inner class is quite simple. You just need to write a class within a class. Unlike a class, an inner class can be private and once you declare an inner class private, it cannot be accessed from an object outside the class.Given below is the program to create an inner class and access it. In the given example, we make the inner class private and access the class through a method.Here you can observe that <b>Outer_Demo</b> is the outer class, <b>Inner_Demo</b> is the inner class, <b>display_Inner()</b> is the method inside which we are instantiating the inner class, and this method is invoked from the <b>main</b> method.If you compile and execute the above program, you will get the following result.As mentioned earlier, inner classes are also used to access the private members of a class. Suppose a class is having private members to access them. Write an inner class in it, return the private members from a method within the inner class, say, <b>getValue()</b>, and finally from another class (from which you want to access the private members) call the getValue() method of the inner class.   To instantiate the inner class, initially you have to instantiate the outer class. Thereafter, using the object of the outer class, you can instantiate the inner class as shown below.The following program shows how to access the private members of a class using inner class.If you compile and execute the above program, you will get the following result. <pre class="result notranslate"> The value of num in the class Test is: 175 </pre>  <h2>Method-local Inner Class</h2> In Java, we can write a class within a method and this will be a local type. Like local variables, the scope of the inner class is restricted within the method.A method-local inner class can be instantiated only within the method where the inner class is defined. The following program shows how to use a method-local inner class.If you compile and execute the above program, you will get the following result.', '<br><code><pre class="prettyprint notranslate"> class Outer_Demo{    int num;    //inner class    private class Inner_Demo{       public void print(){	             System.out.println("This is an inner class");       }    }    //Accessing he inner class from the method within    void display_Inner(){       Inner_Demo inner = new Inner_Demo();       inner.print();    } }     public class My_class{    public static void main(String args[]){       //Instantiating the outer class        Outer_Demo outer = new Outer_Demo();       //Accessing the display_Inner() method.       outer.display_Inner();    }  } </pre></code><br><br><code><pre class="result notranslate"> This is an inner class. </pre></code><br><br><code><pre class="prettyprint notranslate"> Outer_Demo outer=new Outer_Demo(); Outer_Demo.Inner_Demo inner=outer.new Inner_Demo(); </pre></code><br><br><code><pre class="prettyprint notranslate"> class Outer_Demo {    //private variable of the outer class    private int num= 175;      //inner class       public class Inner_Demo{       public int getNum(){          System.out.println("This is the getnum method of the inner class");          return num;       }    } }  public class My_class2{    public static void main(String args[]){       //Instantiating the outer class       Outer_Demo outer=new Outer_Demo();       //Instantiating the inner class       Outer_Demo.Inner_Demo inner=outer.new Inner_Demo();       System.out.println(inner.getNum());    } } </pre></code><br><br><code><pre class = "prettyprint notranslate"> public class Outerclass{        //instance method of the outer class     void my_Method(){       int num = 23;           //method-local inner class       class MethodInner_Demo{          public void print(){             System.out.println("This is method inner class "+num);	             }          }//end of inner class 	          //Accessing the inner class       MethodInner_Demo inner = new MethodInner_Demo();       inner.print();    }        public static void main(String args[]){       Outerclass outer = new Outerclass();       outer.my_Method();	   	       } } </pre></code><br><br><code><pre class="result notranslate"> This is method inner class 23 </pre></code><br>'),
(433, 'Anonymous Inner Class', 'An inner class declared without a class name is known as an <b>anonymous inner class</b>. In case of anonymous inner classes, we declare and instantiate them at the same time. Generally they are used whenever you need to override the method of a class or an interface. The syntax of an anonymous inner class is as follows:The following program shows how to override the method of a class using anonymous inner class.If you compile and execute the above program, you will get the following result.In the same way, you can override the methods of the concrete class as well as the interface using an anonymous inner class.Generally if a method accepts an object of an interface, an abstract class, or a concrete class, then we can implement the interface, extend the abstract class, and pass the object to the method. If it is a class, then we can directly pass it to the method.But in all the three cases, you can pass an anonymous inner class to the method. Here is the syntax of passing an anonymous inner class as a method argument:The following program shows how to pass an anonymous inner class as a method argument.If you compile and execute the above program, it gives you the following result.', '<br><code><pre  class="prettyprint notranslate"> AnonymousInner an_inner = new AnonymousInner(){    public void my_method(){    ........    ........    }	     }; </pre></code><br><br><code><pre  class="prettyprint notranslate"> abstract class AnonymousInner{    public abstract void mymethod(); }  public class Outer_class {    public static void main(String args[]){       AnonymousInner inner = new AnonymousInner(){          public void mymethod(){             System.out.println("This is an example of anonymous inner class");    	            }	           };       inner.mymethod();	    } } </pre></code><br><br><code><pre class="result notranslate"> This is an example of anonymous inner class </pre></code><br><br><code><pre class="prettyprint notranslate"> obj.my_Method(new My_Class(){    public void Do(){    .....    .....    } }); </pre></code><br><br><code><pre class="prettyprint notranslate"> //interface interface Message{    String greet();	 }  public class My_class {    //method which accepts the object of interface Message    public void displayMessage(Message m){       System.out.println(m.greet() +", This is an example of anonymous inner calss as an argument");	       }     public static void main(String args[]){       //Instantiating the class       My_class obj = new My_class(); 		       //Passing an anonymous inner class as an argument       obj.displayMessage(new Message(){          public String greet(){             return "Hello";  		             }       });    } } </pre></code><br><br><code><pre class="result notranslate"> Hello This is an example of anonymous inner class as an argument </pre></code><br>'),
(434, 'Java - Inheritance', 'Inheritance can be defined as the process where one class acquires the properties (methods and fields) of another. With the use of inheritance the information is made manageable in a hierarchical order.The class which inherits the properties of other is known as subclass (derived class, child class) and the class whose properties are inherited is known as superclass (base class, parent class).', ''),
(435, 'extends Keyword', '<b>extends</b> is the keyword used to inherit the properties of a class. Below given is the syntax of extends keyword.', '<br><code><pre class="prettyprint notranslate"> class Super{    .....    ..... }  class Sub extends Super{    .....    .....  } </pre></code><br>'),
(436, 'Sample Code', 'Below given is an example demonstrating Java inheritance. In this example you can observe two classes namely Calculation and My_Calculation.Using extends keyword the My_Calculation inherits the methods addition() and Subtraction() of Calculation class.Copy and paste the program given below in a file with name My_Calculation.javaCompile and execute the above code as shown belowAfter executing the program it will produce the following result.In the given program when an object to <b>My_Calculation</b> class is created, a copy of the contents of the super class is made with in it. That is why, using the object of the subclass you can access the members of a super class.The Superclass reference variable can hold the subclass object, but using that variable you can access only the members of the superclass, so to access the members of both classes it is recommended to always create reference variable to the subclass.If you consider the above program you can instantiate the class as given below as well. But using the superclass reference variable ( <b>cal</b> in this case ) you cannot call the method <b>multiplication()</b>, which belongs to the subclass My_Calculation.<b>Note</b> &minus; A subclass inherits all the members (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.', '<br><code><pre class="prettyprint notranslate tryit"> class Calculation{     int z; 	    public void addition(int x, int y){       z = x+y;       System.out.println("The sum of the given numbers:"+z);    } 	    public void Substraction(int x,int y){       z = x-y;       System.out.println("The difference between the given numbers:"+z);    }     }  public class My_Calculation extends Calculation{           public void multiplication(int x, int y){       z = x*y;       System.out.println("The product of the given numbers:"+z);    } 	    public static void main(String args[]){       int a = 20, b = 10;       My_Calculation demo = new My_Calculation();       demo.addition(a, b);       demo.Substraction(a, b);       demo.multiplication(a, b);          }  } </pre></code><br><br><code><pre class="result notranslate"> javac My_Calculation.java java My_Calculation </pre></code><br><br><code><pre class="result notranslate"> The sum of the given numbers:30 The difference between the given numbers:10 The product of the given numbers:200 </pre></code><br><br><code><pre class="prettyprint notranslate"> Calculation cal = new My_Calculation(); demo.addition(a, b); demo.Subtraction(a, b); </pre></code><br>'),
(437, 'The super keyword', 'The <b>super</b> keyword is similar to <b>this</b> keyword following are the scenarios where the super keyword is used. <li><p>It is used to <b>differentiate the members</b> of superclass from the members of subclass, if they have same names.</p></li> <li><p>It is used to <b>invoke the superclass</b> constructor from subclass.</p></li> If a class is inheriting the properties of another class. And if the members of the superclass have the names same as the sub class, to differentiate these variables we use super keyword as shown below.This section provides you a program that demonstrates the usage of the <b>super</b> keyword.In the given program you have two classes namely <i>Sub_class</i> and <i>Super_class</i>, both have a  method named display() with different implementations, and a variable named num with different values. We are invoking display() method of both classes and printing the value of the variable num of both classes, here you can observe that we have used super key word to differentiate the members of super class from sub class.Copy and paste the program in a file with name Sub_class.java.Compile and execute the above code using the following syntax.On executing the program you will get the following result &minus;If a class is inheriting the properties of another class, the subclass automatically acquires the default constructor of the super class. But if you want to call a parametrized constructor of the super class, you need to use the super keyword as shown below.The program given in this section demonstrates how to use the super keyword to invoke the parametrized constructor of the superclass. This program contains a super class and a sub class, where the super class contains a parametrized constructor which accepts a string value, and we used the super keyword to invoke the parametrized constructor of the super class.Copy and paste the below given program in a file with name Subclass.javaCompile and execute the above code using the following syntax.On executing the program you will get the following result &minus;', '<br><code><pre class="prettyprint notranslate"> super.variable super.method(); </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> class Super_class{     int num = 20;        //display method of superclass    public void display(){          System.out.println("This is the display method of superclass");    }	  }  public class Sub_class extends Super_class {     int num = 10;        //display method of sub class    public void display(){       System.out.println("This is the display method of subclass");    }        public void my_method(){ 	         //Instantiating subclass       Sub_class sub = new Sub_class(); 	         //Invoking the display() method of sub class       sub.display(); 	         //Invoking the display() method of superclass       super.display(); 	         //printing the value of variable num of subclass       System.out.println("value of the variable named num in sub class:"+ sub.num); 		         //printing the value of variable num of superclass       System.out.println("value of the variable named num in super class:"+ super.num);         }        public static void main(String args[]){       Sub_class obj = new Sub_class();       obj.my_method();           } } </pre></code><br><br><code><pre class="prettyprint notranslate"> javac Super_Demo java Super </pre></code><br><br><code><pre class="result notranslate"> This is the display method of subclass This is the display method of superclass value of the variable named num in sub class:10 value of the variable named num in super class:20 </pre></code><br><br><code><pre class="result notranslate"> super(values); </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> class Superclass{        int age;     Superclass(int age){       this.age = age; 		     }     public void getAge(){       System.out.println("The value of the variable named age in super class is: " +age);    }  }  public class Subclass extends Superclass {        Subclass(int age){       super(age);    }     public static void main(String argd[]){       Subclass s = new Subclass(24);       s.getAge();    }  } </pre></code><br><br><code><pre class="prettyprint notranslate"> javac Subclass java Subclass </pre></code><br><br><code><pre class="result notranslate"> The value of the variable named age in super class is: 24 </pre></code><br>'),
(438, 'IS-A Relationship', 'IS-A is a way of saying : This object is a type of that object. Let us see how the <b>extends</b> keyword is used to achieve inheritance.Now, based on the above example, In Object Oriented terms, the following are true &minus; <li><p>Animal is the superclass of Mammal class.</p></li> <li><p>Animal is the superclass of Reptile class.</p></li> <li><p>Mammal and Reptile are subclasses of Animal class.</p></li> <li><p>Dog is the subclass of both Mammal and Animal classes.</p></li> Now, if we consider the IS-A relationship, we can say &minus; <li><p>Mammal IS-A Animal</p></li> <li><p>Reptile IS-A Animal</p></li> <li><p>Dog IS-A Mammal</p></li> <li><p>Hence : Dog IS-A Animal as well</p></li> With use of the extends keyword the subclasses will be able to inherit all the properties of the superclass except for the private properties of the superclass.We can assure that Mammal is actually an Animal with the use of the instance operator.', '<br><code><pre class="prettyprint notranslate" id="animal"> public class Animal{ }  public class Mammal extends Animal{ }  public class Reptile extends Animal{ }  public class Dog extends Mammal{ } </pre></code><br>'),
(439, 'Example', 'This would produce the following result &minus;Since we have a good understanding of the <b>extends</b> keyword let us look into how the <b>implements </b> keyword is used to get the IS-A relationship.Generally, the <b>implements</b> keyword is used with classes to inherit the properties of an interface. Interfaces can never be extended by a class.', '<br><code><pre class="prettyprint notranslate tryit"> class Animal{ }  class Mammal extends Animal{ }  class Reptile extends Animal{ }  public class Dog extends Mammal{     public static void main(String args[]){        Animal a = new Animal();       Mammal m = new Mammal();       Dog d = new Dog();        System.out.println(m instanceof Animal);       System.out.println(d instanceof Mammal);       System.out.println(d instanceof Animal);    } } </pre></code><br><br><code><pre class="result notranslate"> true true true </pre></code><br>'),
(440, 'The instanceof Keyword', 'Let us use the <b>instanceof</b> operator to check determine whether Mammal is actually an Animal, and dog is actually an AnimalThis would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> interface Animal{}  class Mammal implements Animal{}  public class Dog extends Mammal{     public static void main(String args[]){        Mammal m = new Mammal();       Dog d = new Dog();        System.out.println(m instanceof Animal);       System.out.println(d instanceof Mammal);       System.out.println(d instanceof Animal);    } }  </pre></code><br><br><code><pre class="result notranslate"> true true true </pre></code><br>'),
(441, 'HAS-A relationship', 'These relationships are mainly based on the usage. This determines whether a certain class <b>HAS-A </b> certain thing. This relationship helps to reduce duplication of code as well as bugs.Lets us look into an example &minus;This shows that class Van HAS-A Speed. By having a separate class for Speed, we do not have to put the entire code that belongs to speed inside the Van class., which makes it possible to reuse the Speed class in multiple applications.In Object-Oriented feature, the users do not need to bother about which object is doing the real work. To achieve this, the Van class hides the implementation details from the users of the Van class. So basically what happens is the users would ask the Van class to do a certain action and the Van class will either do the work by itself or ask another class to perform the action.', '<br><code><pre class="prettyprint notranslate"> public class Vehicle{} public class Speed{}  public class Van extends Vehicle{ 	private Speed sp; }  </pre></code><br>'),
(442, 'Java - Overriding', 'In the previous chapter, we talked about super classes and sub classes. If a class inherits a method from its super class, then there is a chance to override the method provided that it is not marked final.The benefit of overriding is: ability to define a behaviour thats specific to the subclass type which means a subclass can implement a parent class method based on its requirement.In object-oriented terms, overriding means to override the functionality of an existing method.', ''),
(443, 'Example:', 'Let us look at an example.This would produce the following result:In the above example, you can see that the even though <b>b</b> is a type of Animal it runs the move method in the Dog class. The reason for this is: In compile time, the check is made on the reference type. However, in the runtime, JVM figures out the object type and would run the method that belongs to that particular object.Therefore, in the above example, the program will compile properly since Animal class has the method move. Then, at the runtime, it runs the method specific for that object.Consider the following example :This would produce the following result:This program will throw a compile time error since bs reference type Animal doesnt have a method by the name of bark.', '<br><code><pre class="prettyprint notranslate tryit"> class Animal{     public void move(){       System.out.println("Animals can move");    } }  class Dog extends Animal{     public void move(){       System.out.println("Dogs can walk and run");    } }  public class TestDog{     public static void main(String args[]){       Animal a = new Animal(); // Animal reference and object       Animal b = new Dog(); // Animal reference but Dog object        a.move();// runs the method in Animal class        b.move();//Runs the method in Dog class    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Animals can move Dogs can walk and run </pre></code><br><br><code><pre class="prettyprint notranslate tryit"> class Animal{     public void move(){       System.out.println("Animals can move");    } }  class Dog extends Animal{     public void move(){       System.out.println("Dogs can walk and run");    }    public void bark(){       System.out.println("Dogs can bark");    } }  public class TestDog{     public static void main(String args[]){       Animal a = new Animal(); // Animal reference and object       Animal b = new Dog(); // Animal reference but Dog object        a.move();// runs the method in Animal class       b.move();//Runs the method in Dog class       b.bark();    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> TestDog.java:30: cannot find symbol symbol  : method bark() location: class Animal                 b.bark();                  ^ </pre></code><br>'),
(444, 'Rules for method overriding:', ' <li><p>The argument list should be exactly the same as that of the overridden method.</p></li> <li><p>The return type should be the same or a subtype of the return type declared in the original overridden method in the superclass.</p></li> <li><p>The access level cannot be more restrictive than the overridden methods access level. For example: if the superclass method is declared public then the overridding method in the sub class cannot be either private or protected.</p></li> <li><p>Instance methods can be overridden only if they are inherited by the subclass.</p></li> <li><p>A method declared final cannot be overridden.</p></li> <li><p>A method declared static cannot be overridden but can be re-declared.</p></li> <li><p>If a method cannot be inherited, then it cannot be overridden.</p></li> <li><p>A subclass within the same package as the instances superclass can override any superclass method that is not declared private or final.</p></li> <li><p>A subclass in a different package can only override the non-final methods declared public or protected.</p></li> <li><p>An overriding method can throw any uncheck exceptions, regardless of whether the overridden method throws exceptions or not. However the overriding method should not throw checked exceptions that are new or broader than the ones declared by the overridden method. The overriding method can throw narrower or fewer exceptions than the overridden method.</p></li> <li><p>Constructors cannot be overridden.</p></li> ', ''),
(445, 'Java - Polymorphism', 'Polymorphism is the ability of an object to take on many forms. The most common use of polymorphism in OOP occurs when a parent class reference is used to refer to a child class object.Any Java object that can pass more than one IS-A test is considered to be polymorphic. In Java, all Java objects are polymorphic since any object will pass the IS-A test for their own type and for the class Object.It is important to know that the only possible way to access an object is through a reference variable. A reference variable can be of only one type. Once declared, the type of a reference variable cannot be changed.The reference variable can be reassigned to other objects provided that it is not declared final. The type of the reference variable would determine the methods that it can invoke on the object.A reference variable can refer to any object of its declared type or any subtype of its declared type. A reference variable can be declared as a class or interface type.', ''),
(446, 'Example:', 'Let us look at an example.Now, the Deer class is considered to be polymorphic since this has multiple inheritance. Following are true for the above example: <li><p>A Deer IS-A Animal</p></li> <li><p>A Deer IS-A Vegetarian</p></li> <li><p>A Deer IS-A Deer </p></li> <li><p>A Deer IS-A Object</p></li> When we apply the reference variable facts to a Deer object reference, the following declarations are legal:All the reference variables d,a,v,o refer to the same Deer object in the heap.', '<br><code><pre class="prettyprint notranslate"> public interface Vegetarian{} public class Animal{} public class Deer extends Animal implements Vegetarian{} </pre></code><br><br><code><pre class="prettyprint notranslate"> Deer d = new Deer(); Animal a = d; Vegetarian v = d; Object o = d; </pre></code><br>'),
(447, 'Java - Abstraction', 'As per dictionary, Abstraction is the quality of dealing with ideas rather than events. for example when you consider the case of e-mail, complex details such as what happens soon you send an e-mail, the protocol your email server uses are hidden from the user, therefore to send an e-mail you just need to type the content, mention the address of the receiver and click send.like wise in Object oriented programming  Abstraction is a process process of hiding the implementation details from the user, only the functionality will be provided to the user. In other words user will have the information on what the object does instead of how it does it.In Java Abstraction is achieved using Abstract classes, and Interfaces.', ''),
(448, 'Abstract Class ', 'A class which contains the <b>abstract</b> keyword in its declaration is known as abstract class. <li><p>Abstract classes may or may not contain <i>abstract methods</i> ie., methods with out body ( public void get(); )</p></li> <li><p>But, if a class have at least one abstract method, then the class <b>must</b> be declared abstract.</p></li> <li><p>If a class is declared abstract it cannot be instantiated.</p></li> <li><p>To use an abstract class you have to inherit it from another class, provide implementations to the abstract methods in it.</p></li> <li><p>If you inherit an abstract class you have to provide implementations to all the abstract methods in it.</p></li>  ', ''),
(449, 'Example', 'You can observe that except abstract methods the Employee class is same as normal class in Java. The class is now abstract, but it still has three fields, seven methods, and one constructor.Now you can try to instantiate the Employee class as shown below:When you compile the above class, it gives you the following error:', '<br><code><pre class="prettyprint notranslate" id="employee"> /* File name : Employee.java */ public abstract class Employee {    private String name;    private String address;    private int number;    public Employee(String name, String address, int number)    {       System.out.println("Constructing an Employee");       this.name = name;       this.address = address;       this.number = number;    }    public double computePay()    {      System.out.println("Inside Employee computePay");      return 0.0;    }    public void mailCheck()    {       System.out.println("Mailing a check to " + this.name        + " " + this.address);    }    public String toString()    {       return name + " " + address + " " + number;    }    public String getName()    {       return name;    }    public String getAddress()    {       return address;    }    public void setAddress(String newAddress)    {       address = newAddress;    }    public int getNumber()    {      return number;    } } </pre></code><br><br><code><pre class="prettyprint notranslate tryit" title="employee"> /* File name : AbstractDemo.java */ public class AbstractDemo {    public static void main(String [] args)    {       /* Following is not allowed and would raise error */       Employee e = new Employee("George W.", "Houston, TX", 43);        System.out.println("\n Call mailCheck using Employee reference--");       e.mailCheck();     } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Employee.java:46: Employee is abstract; cannot be instantiated       Employee e = new Employee("George W.", "Houston, TX", 43);                    ^ 1 error </pre></code><br>'),
(450, 'Inheriting the Abstract Class:', 'We can inherit the properties of Employee class just like concrete class as shown below:Here, you cannot instantiate the Employee class, but you can instantiate the Salary Class, and using this instance you can access the all the three fields and seven methods of Employee class as shown below.This produces the following result:', '<br><code><pre class="prettyprint notranslate" id="salary"> /* File name : Salary.java */ public class Salary extends Employee {    private double salary; //Annual salary    public Salary(String name, String address, int number, double       salary)    {        super(name, address, number);        setSalary(salary);    }    public void mailCheck()    {        System.out.println("Within mailCheck of Salary class ");        System.out.println("Mailing check to " + getName()        + " with salary " + salary);    }    public double getSalary()    {        return salary;    }    public void setSalary(double newSalary)    {        if(newSalary &gt;= 0.0)        {           salary = newSalary;        }    }    public double computePay()    {       System.out.println("Computing salary pay for " + getName());       return salary/52;    } } </pre></code><br><br><code><pre class="prettyprint notranslate tryit" title="employee, salary"> /* File name : AbstractDemo.java */ public class AbstractDemo {    public static void main(String [] args)    {       Salary s = new Salary("Mohd Mohtashim", "Ambehta, UP", 3, 3600.00);       Employee e = new Salary("John Adams", "Boston, MA", 2, 2400.00);        System.out.println("Call mailCheck using Salary reference --");       s.mailCheck();        System.out.println("\n Call mailCheck using Employee reference--");       e.mailCheck();     } } </pre></code><br><br><code><pre class="result notranslate"> Constructing an Employee Constructing an Employee Call mailCheck using  Salary reference -- Within mailCheck of Salary class ailing check to Mohd Mohtashim with salary 3600.0  Call mailCheck using Employee reference-- Within mailCheck of Salary class ailing check to John Adams with salary 2400. </pre></code><br>'),
(451, 'Java - Encapsulation', 'Encapsulation is one of the four fundamental OOP concepts. The other three are inheritance, polymorphism, and abstraction.Encapsulation in Java is a mechanism of wrapping the data (variables) and code acting on the data (methods) together as as single unit. In encapsulation the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class, therefore it is also known as data hiding.To achieve encapsulation in Java <li><p>Declare the variables of a class as private.</p></li> <li><p>Provide public setter and getter methods to modify and view the variables values.</p></li> ', ''),
(452, 'Example:', 'Below given is an example that demonstrates how to achieve  Encapsulation in Java:The public setXXX() and getXXX() methods are the access points of the instance variables of the EncapTest class. Normally, these methods are referred as getters and setters. Therefore any class that wants to access the variables should access them through these getters and setters.The variables of the EncapTest class can be accessed as below::This would produce the following result:', '<br><code><pre class="prettyprint notranslate" id="encaptest"> /* File name : EncapTest.java */ public class EncapTest{     private String name;    private String idNum;    private int age;     public int getAge(){       return age;    }     public String getName(){       return name;    }     public String getIdNum(){       return idNum;    }     public void setAge( int newAge){       age = newAge;    }     public void setName(String newName){       name = newName;    }     public void setIdNum( String newId){       idNum = newId;    } } </pre></code><br><br><code><pre class="prettyprint notranslate tryit" title="encaptest"> /* File name : RunEncap.java */ public class RunEncap{     public static void main(String args[]){       EncapTest encap = new EncapTest();       encap.setName("James");       encap.setAge(20);       encap.setIdNum("12343ms");        System.out.print("Name : " + encap.getName() + " Age : " + encap.getAge());     } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Name : James Age : 20 </pre></code><br>'),
(453, 'Java - Packages', 'Packages are used in Java in order to prevent naming conflicts, to control access, to make searching/locating and usage of classes, interfaces, enumerations and annotations easier, etc.A Package can be defined as a grouping of related types (classes, interfaces, enumerations and annotations ) providing access protection and name space management.Some of the existing packages in Java are:: <li><p><b>java.lang</b> - bundles the fundamental classes</p></li> <li><p><b>java.io</b> -  classes for input , output functions are bundled in this package</p></li> Programmers can define their own packages to bundle group of classes/interfaces, etc. It is a good practice to group related classes implemented by you so that a programmer can easily determine that the classes, interfaces, enumerations, annotations are related.Since the package creates a new namespace there wont be any name conflicts with names in other packages. Using packages, it is easier to provide access control and it is also easier to locate the related classes.', '');
INSERT INTO `textbook` (`textid`, `topic`, `content`, `code`) VALUES
(454, 'Creating a package:', 'While creating a package, you should choose a name for the package and include a <b>package</b> statement along with that name at the top of every source file that contains the classes, interfaces, enumerations, and annotation types that you want to include in the package.The <b>package</b> statement should be the first line in the source file. There can be only one package statement in each source file, and it applies to all types in the file. If a package statement is not used then the class, interfaces, enumerations, and annotation types will  be placed in the current default package.To compile the Java programs with package statements you have to do use -d option as shown below.  <pre class="prettyprint notranslate"> javac -d <b>Destination_folder file_name</b>.java</pre>  Then a folder with the given package name is created in the specified destination, and the compiled class files will be placed in that folder  ', ''),
(455, 'Example:', 'Let us look at an example that creates a package called <b>animals</b>. It is a good practice to use names of packages with lower case letters to avoid any conflicts with the names of classes, interfaces.Below given package example contains interface named <i>animals</i>:Now, let us implement the above interface  in the same package <i>animals</i>:Now compile the java files as shown below:Now a package/folder with the name <b>animals</b> will be created in the current directory and these class files will be placed in it as shown below.&nbsp;You can execute the class file with in the package and get the result as shown below.', '<br><code><pre class="prettyprint notranslate" id="animal"> /* File name : Animal.java */ package animals; interface Animal {    public void eat();    public void travel(); } </pre></code><br><br><code><pre class="prettyprint notranslate tryit" title="animal"> package animals;  /* File name : MammalInt.java */ public class MammalInt implements Animal{     public void eat(){       System.out.println("Mammal eats");    }     public void travel(){       System.out.println("Mammal travels");    }      public int noOfLegs(){       return 0;    }     public static void main(String args[]){       MammalInt m = new MammalInt();       m.eat();       m.travel();    } }  </pre></code><br><br><code><pre class="result notranslate"> $ javac -d . Animal.java  $ javac -d . MammalInt.java </pre></code><br><br><code><pre class="result notranslate"> $ java animals.MammalInt ammal eats ammal travels</pre></code><br>'),
(456, 'The import Keyword:', 'If a class wants to use another class in the same package, the package name does not need to be used. Classes in the same package find each other without any special syntax.', ''),
(457, 'Example:', 'Here, a class named Boss is added to the payroll package that already contains Employee. The Boss can then refer to the Employee class without using the payroll prefix, as demonstrated by the following Boss class.What happens if the Employee class is not in the payroll package? The Boss class must then use one of the following techniques for referring to a class in a different package. <li><p>The fully qualified name of the class can be used. For example:</p></li>  <li><p>The package can be imported using the import keyword and the wild card (*). For example:</p></li>  <li><p>The class itself can be imported using the import keyword. For example:</p></li> <b>Note:</b> A class file can contain any number of import statements. The import statements must appear after the package statement and before the class declaration.', '<br><code><pre class="prettyprint notranslate"> package payroll;  public class Boss {    public void payEmployee(Employee e)    {       e.mailCheck();    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> payroll.Employee </pre></code><br><br><code><pre class="prettyprint notranslate"> import payroll.*; </pre></code><br><br><code><pre class="prettyprint notranslate"> import payroll.Employee; </pre></code><br>'),
(458, 'The Directory Structure of Packages:', 'Two major results occur when a class is placed in a package: <li><p>The name of the package becomes a part of the name of the class, as we just discussed in the previous section.</p></li> <li><p>The name of the package must match the directory structure where the corresponding bytecode resides.</p></li> Here is simple way of managing your files in Java:Put the source code for a class, interface, enumeration, or annotation type in a text file whose name is the simple name of the type and whose extension is <b>.java</b>. For example:Now, put the source file in a directory whose name reflects the name of the package to which the class belongs:Now, the qualified class name and  pathname would be as below: <li><p>Class name -&gt;  vehicle.Car</p></li> <li><p>Path name -&gt;   vehicleCar.java (in windows)</p></li> In general, a company uses its reversed Internet domain name for its package names.  Example: A companys Internet domain name is apple.com, then all its  package names would start with com.apple. Each component of the package name corresponds to a subdirectory. Example: The company had a com.apple.computers package that contained a Dell.java source file, it would be contained in a series of subdirectories like this:At the time of compilation, the compiler creates a different output file for each class, interface and enumeration defined in it. The base name of the output file is the name of the type, and its extension is <b> .class</b>For example:Now, compile this file as follows using -d option:This would put compiled files as follows:You can import all the classes or interfaces defined in <i>comapplecomputers</i> as follows:Like the .java source files, the compiled .class files should be in a series of directories that reflect the package name. However, the path to the .class files does not have to be the same as the path to the .java source files. You can arrange your source and class directories separately, as: By doing this, it is possible to give the classes directory to other programmers without revealing your sources. You also need to manage source and class files in this manner so that the compiler and the Java Virtual Machine (JVM) can find all the types your program uses. The full path to the classes directory, &lt;path-two&gt;classes, is called the class path, and is set with the CLASSPATH system variable. Both the compiler and the JVM construct the path to your .class files by adding the package name to the class path.Say &lt;path-two&gt;classes is the class path, and the package name is com.apple.computers, then the compiler and JVM will look for .class files in &lt;path-two&gt;classescomapplecompters.A class path may include several paths. Multiple paths should be separated by a semicolon (Windows) or colon (Unix). By default, the compiler and the JVM search the current directory and the JAR file containing the Java platform classes so that these directories are automatically in the class path.', '<br><code><pre class="prettyprint notranslate"> // File Name :  Car.java  package vehicle;  public class Car {    // Class implementation.    } </pre></code><br><br><code><pre class="prettyprint notranslate"> ....vehicleCar.java </pre></code><br><br><code><pre class="prettyprint notranslate"> ....comapplecomputersDell.java </pre></code><br><br><code><pre class="prettyprint notranslate"> // File Name: Dell.java  package com.apple.computers; public class Dell{        } class Ups{        } </pre></code><br><br><code><pre class="prettyprint notranslate"> $javac -d . Dell.java </pre></code><br><br><code><pre class="prettyprint notranslate"> .comapplecomputersDell.class .comapplecomputersUps.class </pre></code><br><br><code><pre class="prettyprint notranslate"> import com.apple.computers.*; </pre></code><br><br><code><pre class="prettyprint notranslate"> &lt;path-one&gt;sourcescomapplecomputersDell.java  &lt;path-two&gt;classescomapplecomputersDell.class </pre></code><br>'),
(459, 'Java - Data Structures', 'The data structures provided by the Java utility package are very powerful and perform a wide range of functions. These data structures consist of the following interface and classes: <li><p>Enumeration</p></li> <li><p>BitSet</p></li> <li><p>Vector</p></li> <li><p>Stack</p></li> <li><p>Dictionary</p></li> <li><p>Hashtable</p></li> <li><p>Properties</p></li> All these classes are now legacy and Java-2 has introduced a new framework called Collections Framework, which is discussed in next tutorial:', ''),
(460, 'The Enumeration:', 'The Enumeration interface isnt itself a data structure, but it is very important within the context of other data structures. The Enumeration interface defines a means to retrieve successive elements from a data structure.For example, Enumeration defines a method called nextElement that is used to get the next element in a data structure that contains multiple elements.To have more detail about this interface, check <a href="/java/java_enumeration_interface.htm">The Enumeration</a>.', ''),
(461, 'The BitSet', 'The BitSet class implements a group of bits or flags that can be set and cleared individually.This class is very useful in cases where you need to keep up with a set of Boolean values; you just assign a bit to each value and set or clear it as appropriate.To have more detail about this class, check <a href="/java/java_bitset_class.htm">The BitSet</a>.', ''),
(462, 'The Vector', 'The Vector class is similar to a traditional Java array, except that it can grow as necessary to accommodate new elements.Like an array, elements of a Vector object can be accessed via an index into the vector. The nice thing about using the Vector class is that you dont have to worry about setting it to a specific size upon creation; it shrinks and grows automatically when necessary.To have more detail about this class, check <a href="/java/java_vector_class.htm">The Vector</a>.', ''),
(463, 'The Stack', 'The Stack class implements a last-in-first-out (LIFO) stack of elements.You can think of a stack literally as a vertical stack of objects; when you add a new element, it gets stacked on top of the others.When you pull an element off the stack, it comes off the top. In other words, the last element you added to the stack is the first one to come back off.To have more detail about this class, check <a href="/java/java_stack_class.htm">The Stack</a>.', ''),
(464, 'The Dictionary', 'The Dictionary class is an abstract class that defines a data structure for mapping keys to values.This is useful in cases where you want to be able to access data via a particular key rather than an integer index.Since the Dictionary class is abstract, it provides only the framework for a key-mapped data structure rather than a specific implementation.To have more detail about this class, check <a href="/java/java_dictionary_class.htm">The Dictionary</a>.', ''),
(465, 'The Hashtable', 'The Hashtable class provides a means of organizing data based on some user-defined key structure.For example, in an address list hash table you could store and sort data based on a key such as ZIP code rather than on a persons name.The specific meaning of keys in regard to hash tables is totally dependent on the usage of the hash table and the data it contains.To have more detail about this class, check <a href="/java/java_hashtable_class.htm">The Hashtable</a>.', ''),
(466, 'Java Collections Framework', 'Prior to Java 2, Java provided ad hoc classes such as <b>Dictionary, Vector, Stack</b>, and <b>Properties</b> to store and manipulate groups of objects. Although these classes were quite useful, they lacked a central, unifying theme. Thus, the way that you used Vector was different from the way that you used Properties.The collections framework was designed to meet several goals. <li><p>The framework had to be high-performance. The implementations for the fundamental collections (dynamic arrays, linked lists, trees, and hashtables) are highly efficient.</p></li> <li><p>The framework had to allow different types of collections to work in a similar manner and with a high degree of interoperability.</p></li> <li><p>Extending and/or adapting a collection had to be easy.</p></li> Towards this end, the entire collections framework is designed around a set of standard interfaces. Several standard implementations such as <b>LinkedList, HashSet,</b> and <b>TreeSet</b>, of these interfaces are provided that you may use as-is and you may also implement your own collection, if you choose.A collections framework is a unified architecture for representing and manipulating collections. All collections frameworks contain the following: <li><p><b>Interfaces:</b> These are abstract data types that represent collections. Interfaces allow collections to be manipulated independently of the details of their representation. In object-oriented languages, interfaces generally form a hierarchy.</p></li> <li><p><b>Implementations, i.e., Classes:</b> These are the concrete implementations of the collection interfaces. In essence, they are reusable data structures.</p></li> <li><p><b>Algorithms:</b> These are the methods that perform useful computations, such as searching and sorting, on objects that implement collection interfaces. The algorithms are said to be polymorphic: that is, the same method can be used on many different implementations of the appropriate collection interface.</p></li> In addition to collections, the framework defines several map interfaces and classes. Maps store key/value pairs. Although maps are not <i>collections</i> in the proper use of the term, but they are fully integrated with collections.', ''),
(467, 'The Collection Interfaces:', 'The collections framework defines several interfaces. This section provides an overview of each interface:', ''),
(468, 'The Collection Classes:', 'Java provides a set of standard collection classes that implement Collection interfaces. Some of the classes provide full implementations that can be used as-is and others are abstract class, providing skeletal implementations that are used as starting points for creating concrete collections.The standard collection classes are summarized in the following table:The <i>AbstractCollection, AbstractSet, AbstractList, AbstractSequentialList</i> and <i>AbstractMap</i> classes provide skeletal implementations of the core collection interfaces, to minimize the effort required to implement them.The following legacy classes defined by java.util have been discussed in previous tutorial:', ''),
(469, 'The Collection Algorithms:', 'The collections framework defines several algorithms that can be applied to collections and maps. These algorithms are defined as static methods within the Collections class.Several of the methods can throw a <b>ClassCastException</b>, which occurs when an attempt is made to compare incompatible types, or an <b>UnsupportedOperationException</b>, which occurs when an attempt is made to modify an unmodifiable collection.Collections define three static variables: EMPTY_SET, EMPTY_LIST, and EMPTY_MAP. All are immutable.', ''),
(470, 'How to use an Iterator ?', 'Often, you will want to cycle through the elements in a collection. For example, you might want to display each element.The easiest way to do this is to employ an iterator, which is an object that implements either the Iterator or the ListIterator interface.Iterator enables you to cycle through a collection, obtaining or removing elements. ListIterator extends Iterator to allow bidirectional traversal of a list and the modification of elements.', ''),
(471, 'How to use a Comparator ?', 'Both TreeSet and TreeMap store elements in sorted order. However, it is the comparator that defines precisely what <i>sorted order</i> means.This interface lets us sort a given collection any number of different ways. Also this interface can be used to sort any instances of any class (even classes we cannot modify).', ''),
(472, 'Java - Generics', 'It would be nice if we could write a single sort method that could sort the elements in an Integer array, a String array or an array of any type that supports ordering.Java <b>Generic</b> methods and generic classes enable programmers to specify, with a single method declaration, a set of related methods or, with a single class declaration, a set of related types, respectively.Generics also provide compile-time type safety that allows programmers to catch invalid types at compile time.Using Java Generic concept, we might write a generic method for sorting an array of objects, then invoke the generic method with Integer arrays, Double arrays, String arrays and so on, to sort the array elements.', ''),
(473, 'Generic Methods:', 'You can write a single generic method declaration that can be called with arguments of different types. Based on the types of the arguments passed to the generic method, the compiler handles each method call appropriately. Following are the rules to define Generic Methods: <li><p>All generic method declarations have a type parameter section delimited by angle brackets (&lt; and &gt;) that precedes the methods return type ( &lt; E &gt; in the next example).</p></li> <li><p>Each type parameter section contains one or more type parameters separated by commas. A type parameter, also known as a type variable, is an identifier that specifies a generic type name.</p></li> <li><p>The type parameters can be used to declare the return type and act as placeholders for the types of the arguments passed to the generic method, which are known as actual type arguments.</p></li> <li><p>A generic methods body is declared like that of any other method. Note that type parameters can represent only reference types, not primitive types (like int, double and char). </p></li> ', ''),
(474, 'Example:', 'Following example illustrates how we can print array of different type using a single Generic method:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class GenericMethodTest {    // generic method printArray                             public static &lt; E &gt; void printArray( E[] inputArray )    {       // Display array elements                        for ( E element : inputArray ){                     System.out.printf( "%s ", element );          }          System.out.println();     }      public static void main( String args[] )     {         // Create arrays of Integer, Double and Character         Integer[] intArray = { 1, 2, 3, 4, 5 };         Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };         Character[] charArray = { H, E, L, L, O };          System.out.println( "Array integerArray contains:" );         printArray( intArray  ); // pass an Integer array          System.out.println( "\nArray doubleArray contains:" );         printArray( doubleArray ); // pass a Double array          System.out.println( "\nArray characterArray contains:" );         printArray( charArray ); // pass a Character array     }  } </pre></code><br><br><code><pre class="result notranslate"> Array integerArray contains: 1 2 3 4 5 6  Array doubleArray contains: 1.1 2.2 3.3 4.4   Array characterArray contains: H E L L O </pre></code><br>'),
(475, 'Bounded Type Parameters:', 'There may be times when youll want to restrict the kinds of types that are allowed to be passed to a type parameter. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. This is what bounded type parameters are for.To declare a bounded type parameter, list the type parameters name, followed by the extends keyword, followed by its upper bound.', ''),
(476, 'Example:', 'Following example illustrates how extends is used in a general sense to mean either "extends" (as in classes) or "implements" (as in interfaces). This example is Generic method to return the largest of three Comparable objects:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> public class MaximumTest {    // determines the largest of three Comparable objects    public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z)    {                             T max = x; // assume x is initially the largest              if ( y.compareTo( max ) &gt; 0 ){          max = y; // y is the largest so far       }       if ( z.compareTo( max ) &gt; 0 ){          max = z; // z is the largest now                        }       return max; // returns the largest object       }    public static void main( String args[] )    {       System.out.printf( "Max of %d, %d and %d is %d\n\n",                     3, 4, 5, maximum( 3, 4, 5 ) );        System.out.printf( "Maxm of %.1f,%.1f and %.1f is %.1f\n\n",                    6.6, 8.8, 7.7, maximum( 6.6, 8.8, 7.7 ) );        System.out.printf( "Max of %s, %s and %s is %s\n","pear",          "apple", "orange", maximum( "pear", "apple", "orange" ) );    } } </pre></code><br><br><code><pre class="result notranslate"> aximum of 3, 4 and 5 is 5  aximum of 6.6, 8.8 and 7.7 is 8.8  aximum of pear, apple and orange is pear </pre></code><br>'),
(477, 'Generic Classes:', 'A generic class declaration looks like a non-generic class declaration, except that the class name is followed by a type parameter section.As with generic methods, the type parameter section of a generic class can have one or more type parameters separated by commas. These classes are known as parameterized classes or parameterized types because they accept one or more parameters.', ''),
(478, 'Java - Serialization', 'Java provides a mechanism, called object serialization where an object can be represented as a sequence of bytes that includes the objects data as well as information about the objects type and the types of data stored in the object.After a serialized object has been written into a file, it can be read from the file and deserialized that is, the type information and bytes that represent the object and its data can be used to recreate the object in memory.Most impressive is that the entire process is JVM independent, meaning an object can be serialized on one platform and deserialized on an entirely different platform.Classes <b>ObjectInputStream</b> and <b>ObjectOutputStream</b> are high-level streams that contain the methods for serializing and deserializing an object.The ObjectOutputStream class contains many write methods for writing various data types, but one method in particular stands out:The above method serializes an Object and sends it to the output stream. Similarly, the ObjectInputStream class contains the following method for deserializing an object:This method retrieves the next Object out of the stream and deserializes it. The return value is Object, so you will need to cast it to its appropriate data type.To demonstrate how serialization works in Java, I am going to use the Employee class that we discussed early on in the book. Suppose that we have the following Employee class, which implements the Serializable interface:Notice that for a class to be serialized successfully, two conditions must be met: <li><p>The class must implement the java.io.Serializable interface.</p></li> <li><p>All of the fields in the class must be serializable. If a field is not serializable, it must be marked <b>transient</b>.</p></li> If you are curious to know if a Java Standard  Class is  serializable or not, check the documentation for the class. The test is simple: If the class implements java.io.Serializable, then it is serializable; otherwise, its not.', '<br><code><pre class="prettyprint notranslate"> public final void writeObject(Object x) throws IOException </pre></code><br><br><code><pre class="prettyprint notranslate"> public final Object readObject() throws IOException, ClassNotFoundException </pre></code><br><br><code><pre class="prettyprint notranslate"> public class Employee implements java.io.Serializable {    public String name;    public String address;    public transient int SSN;    public int number;        public void mailCheck()    {       System.out.println("Mailing a check to " + name + " " + address);    } } </pre></code><br>'),
(479, 'Serializing an Object:', 'The ObjectOutputStream class is used to serialize an Object. The following SerializeDemo program instantiates an Employee object and serializes it to a file.When the program is done executing, a file named employee.ser is created. The program does not generate any output, but study the code and try to determine what the program is doing.<b>Note:</b> When serializing an object to a file, the standard convention in Java is to give the file a <b>.ser </b> extension.', '<br><code><pre class="prettyprint notranslate"> import java.io.*;  public class SerializeDemo {    public static void main(String [] args)    {       Employee e = new Employee();       e.name = "Reyan Ali";       e.address = "Phokka Kuan, Ambehta Peer";       e.SSN = 11122333;       e.number = 101;              try       {          FileOutputStream fileOut =          new FileOutputStream("/tmp/employee.ser");          ObjectOutputStream out = new ObjectOutputStream(fileOut);          out.writeObject(e);          out.close();          fileOut.close();          System.out.printf("Serialized data is saved in /tmp/employee.ser");       }catch(IOException i)       {           i.printStackTrace();       }    } } </pre></code><br>'),
(480, 'Java - Networking', 'The term <i>network programming</i> refers to writing programs that execute across multiple devices (computers), in which the devices are all connected to each other using a network.The java.net package of the J2SE APIs contains a collection of classes and interfaces that provide the low-level communication details, allowing you to write programs that focus on solving the problem at hand.The java.net package provides support for the two common network protocols: <li><p><b>TCP:</b> TCP stands for Transmission Control Protocol, which allows for reliable communication between two applications. TCP is typically used over the Internet Protocol, which is referred to as TCP/IP.</p></li> <li><p><b>UDP:</b> UDP stands for User Datagram Protocol, a connection-less protocol that allows for packets of data to be transmitted between applications.</p></li> This tutorial gives good understanding on the following two subjects: <li><p><b>Socket Programming</b>: This is most widely used concept in Networking and it has been explained in very detail.</p></li> <li><p><b>URL Processing</b>: This would be covered separately. Click here to learn about <a href="/java/java_url_processing.htm" title="URL Processing">URL Processing</a> in Java language.</p></li> ', ''),
(481, 'Socket Programming:', 'Sockets provide the communication mechanism between two computers using TCP. A client program creates a socket on its end of the communication and attempts to connect that socket to a server.When the connection is made, the server creates a socket object on its end of the communication. The client and server can now communicate by writing to and reading from the socket.The java.net.Socket class represents a socket, and the java.net.ServerSocket class provides a mechanism for the server program to listen for clients and establish connections with them.The following steps occur when establishing a TCP connection between two computers using sockets: <li><p>The server instantiates a ServerSocket object, denoting which port number communication is to occur on.</p></li> <li><p>The server invokes the accept() method of the ServerSocket class. This method waits until a client connects to the server on the given port.</p></li> <li><p>After the server is waiting, a client instantiates a Socket object, specifying the server name and port number to connect to.</p></li> <li><p>The constructor of the Socket class attempts to connect the client to the specified server and port number. If communication is established, the client now has a Socket object capable of communicating with the server.</p></li> <li><p>On the server side, the accept() method returns a reference to a new socket on the server that is connected to the clients socket.</p></li> After the connections are established, communication can occur using I/O streams. Each socket has both an OutputStream and an InputStream. The clients OutputStream is connected to the servers InputStream, and the clients InputStream is connected to the servers OutputStream.TCP is a twoway communication protocol, so data can be sent across both streams at the same time. There are following usefull classes providing complete set of methods to implement sockets.', ''),
(482, 'ServerSocket Class Methods:', 'The <b>java.net.ServerSocket</b> class is used by server applications to obtain a port and listen for client requests The ServerSocket class has four constructors:If the ServerSocket constructor does not throw an exception, it means that your application has successfully bound to the specified port and is ready for client requests.Here are some of the common methods of the ServerSocket class:When the ServerSocket invokes accept(), the method does not return until a client connects. After a client does connect, the ServerSocket creates a new Socket on an unspecified port and returns a reference to this new Socket. A TCP connection now exists between the client and server, and communication can begin.', ''),
(483, 'Socket Class Methods:', 'The <b>java.net.Socket</b> class represents the socket that both the client and server use to communicate with each other. The client obtains a Socket object by instantiating one, whereas the server obtains a Socket object from the return value of the accept() method.The Socket class has five constructors that a client uses to connect to a server:When the Socket constructor returns, it does not simply instantiate a Socket object but it actually attempts to connect to the specified server and port.Some methods of interest in the Socket class are listed here. Notice that both the client and server have a Socket object, so these methods can be invoked by both the client and server.', ''),
(484, 'InetAddress Class Methods:', 'This class represents an Internet Protocol (IP) address. Here are following usefull methods which you would need while doing socket programming:', ''),
(485, 'Socket Client Example:', 'The following GreetingClient is a client program that connects to a server by using a socket and sends a greeting, and then waits for a response.', '<br><code><pre class="prettyprint notranslate"> // File Name GreetingClient.java  import java.net.*; import java.io.*;  public class GreetingClient {    public static void main(String [] args)    {       String serverName = args[0];       int port = Integer.parseInt(args[1]);       try       {          System.out.println("Connecting to " + serverName + 		 " on port " + port);          Socket client = new Socket(serverName, port);          System.out.println("Just connected to "  		 + client.getRemoteSocketAddress());          OutputStream outToServer = client.getOutputStream();          DataOutputStream out = new DataOutputStream(outToServer);          out.writeUTF("Hello from "                       + client.getLocalSocketAddress());          InputStream inFromServer = client.getInputStream();          DataInputStream in =                         new DataInputStream(inFromServer);          System.out.println("Server says " + in.readUTF());          client.close();       }catch(IOException e)       {          e.printStackTrace();       }    } } </pre></code><br>'),
(486, 'Java - Sending Email', 'To send an e-mail using your Java Application is simple enough but to start with you should have <b>JavaMail API</b> and <b>Java Activation Framework (JAF)</b> installed on your machine. <li><p>You can download  latest version of <a href="http://java.sun.com/products/javamail/" target="_blank">JavaMail (Version 1.2)</a> from Javas standard website.</p></li> <li><p>You can download  latest version of <a href="http://java.sun.com/products/javabeans/glasgow/jaf.html" target="_blank">JAF (Version 1.1.1)</a> from Javas standard website.</p></li> Download and unzip these files, in the newly created top level directories you will find a number of jar files for both the applications.  You need to add <b>mail.jar</b> and <b>activation.jar</b> files in your CLASSPATH.', ''),
(487, 'Send a Simple E-mail:', 'Here is an example to send a simple e-mail from your machine. Here it is assumed that your <b>localhost </b> is connected to the internet and capable enough to send an email.Compile and run this program to send a simple e-mail:If you want to send an e-mail to multiple recipients then following methods would be used to specify multiple e-mail IDs:Here is the description of the parameters: <li><p><b>type:</b> This would be set to TO, CC or BCC. Here CC represents Carbon Copy and BCC represents Black Carbon Copy. Example <i>Message.RecipientType.TO</i></p></li> <li><p><b>addresses:</b> This is the array of email ID. You would need to use InternetAddress() method while specifying email IDs</p></li> ', '<br><code><pre class="prettyprint notranslate"> // File Name SendEmail.java  import java.util.*; import javax.mail.*; import javax.mail.internet.*; import javax.activation.*;  public class SendEmail {    public static void main(String [] args)    {           // Recipients email ID needs to be mentioned.       String to = "abcd@gmail.com";        // Senders email ID needs to be mentioned       String from = "web@gmail.com";        // Assuming you are sending email from localhost       String host = "localhost";        // Get system properties       Properties properties = System.getProperties();        // Setup mail server       properties.setProperty("mail.smtp.host", host);        // Get the default Session object.       Session session = Session.getDefaultInstance(properties);        try{          // Create a default MimeMessage object.          MimeMessage message = new MimeMessage(session);           // Set From: header field of the header.          message.setFrom(new InternetAddress(from));           // Set To: header field of the header.          message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));           // Set Subject: header field          message.setSubject("This is the Subject Line!");           // Now set the actual message          message.setText("This is actual message");           // Send message          Transport.send(message);          System.out.println("Sent message successfully....");       }catch (MessagingException mex) {          mex.printStackTrace();       }    } } </pre></code><br><br><code><pre class="result notranslate"> $ java SendEmail Sent message successfully.... </pre></code><br><br><code><pre class="prettyprint notranslate"> void addRecipients(Message.RecipientType type, Address[] addresses)throws MessagingException </pre></code><br>'),
(488, 'Send an HTML E-mail:', 'Here is an example to send an HTML email from your machine. Here it is assumed that your <b>localhost </b> is connected to the internet and capable enough to send an email.This example is very similar to previous one, except here we are using setContent() method to set content whose second argument is "text/html" to specify that the HTML content is included in the message.Using this example, you can send as big as HTML content you like.Compile and run this program to send an HTML e-mail:', '<br><code><pre class="prettyprint notranslate"> // File Name SendHTMLEmail.java  import java.util.*; import javax.mail.*; import javax.mail.internet.*; import javax.activation.*;  public class SendHTMLEmail {    public static void main(String [] args)    {              // Recipients email ID needs to be mentioned.       String to = "abcd@gmail.com";        // Senders email ID needs to be mentioned       String from = "web@gmail.com";        // Assuming you are sending email from localhost       String host = "localhost";        // Get system properties       Properties properties = System.getProperties();        // Setup mail server       properties.setProperty("mail.smtp.host", host);        // Get the default Session object.       Session session = Session.getDefaultInstance(properties);        try{          // Create a default MimeMessage object.          MimeMessage message = new MimeMessage(session);           // Set From: header field of the header.          message.setFrom(new InternetAddress(from));           // Set To: header field of the header.          message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));           // Set Subject: header field          message.setSubject("This is the Subject Line!");           // Send the actual HTML message, as big as you like          message.setContent("&lt;h1&gt;This is actual message&lt;/h1&gt;", "text/html" );           // Send message          Transport.send(message);          System.out.println("Sent message successfully....");       }catch (MessagingException mex) {          mex.printStackTrace();       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> $ java SendHTMLEmail Sent message successfully.... </pre></code><br>'),
(489, 'Send Attachment in E-mail:', 'Here is an example to send an email with attachment from your machine. Here it is assumed that your <b>localhost </b> is connected to the internet and capable enough to send an email.Compile and run this program to send an HTML e-mail:', '<br><code><pre class="prettyprint notranslate"> // File Name SendFileEmail.java  import java.util.*; import javax.mail.*; import javax.mail.internet.*; import javax.activation.*;  public class SendFileEmail {    public static void main(String [] args)    {              // Recipients email ID needs to be mentioned.       String to = "abcd@gmail.com";        // Senders email ID needs to be mentioned       String from = "web@gmail.com";        // Assuming you are sending email from localhost       String host = "localhost";        // Get system properties       Properties properties = System.getProperties();        // Setup mail server       properties.setProperty("mail.smtp.host", host);        // Get the default Session object.       Session session = Session.getDefaultInstance(properties);        try{          // Create a default MimeMessage object.          MimeMessage message = new MimeMessage(session);           // Set From: header field of the header.          message.setFrom(new InternetAddress(from));           // Set To: header field of the header.          message.addRecipient(Message.RecipientType.TO,                                   new InternetAddress(to));           // Set Subject: header field          message.setSubject("This is the Subject Line!");           // Create the message part           BodyPart messageBodyPart = new MimeBodyPart();           // Fill the message          messageBodyPart.setText("This is message body");                    // Create a multipar message          Multipart multipart = new MimeMultipart();           // Set text message part          multipart.addBodyPart(messageBodyPart);           // Part two is attachment          messageBodyPart = new MimeBodyPart();          String filename = "file.txt";          DataSource source = new FileDataSource(filename);          messageBodyPart.setDataHandler(new DataHandler(source));          messageBodyPart.setFileName(filename);          multipart.addBodyPart(messageBodyPart);           // Send the complete message parts          message.setContent(multipart );           // Send message          Transport.send(message);          System.out.println("Sent message successfully....");       }catch (MessagingException mex) {          mex.printStackTrace();       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> $ java SendFileEmail Sent message successfully.... </pre></code><br>'),
(490, 'Java - Multithreading', 'Java is a<i>multi threaded programming language</i> which means we can develop multi threaded program using Java. A multi threaded program contains two or more parts that can run concurrently and each part  can handle different task at the same time making optimal use of the available resources specially when your computer has multiple CPUs.By definition multitasking is when multiple processes share common processing resources such as a CPU. Multi threading extends the idea of multitasking into applications where you can subdivide specific operations within a single application into individual threads. Each of the threads can run in parallel. The OS divides processing time not only among different applications, but also among each thread within an application.Multi threading enables you to write in a way where multiple activities can proceed concurrently in the same program.', ''),
(491, 'Life Cycle of a Thread:', 'A thread goes through various stages in its life cycle. For example, a thread is born, started, runs, and then dies. Following diagram shows complete life cycle of a thread.Above-mentioned stages are explained here: <li><p><b>New:</b> A new thread begins its life cycle in the new state. It remains in this state until the program starts the thread. It is also referred to as a born thread.</p></li> <li><p><b>Runnable:</b> After a newly born thread is started, the thread becomes runnable. A thread in this state is considered to be executing its task.</p></li> <li><p><b>Waiting:</b> Sometimes, a thread transitions to the waiting state while the thread waits for another thread to perform a task.A thread transitions back to the runnable state only when another thread signals the waiting thread to continue executing.</p></li> <li><p><b>Timed waiting:</b> A runnable thread can enter the timed waiting state for a specified interval of time. A thread in this state transitions back to the runnable state when that time interval expires or when the event it is waiting for occurs.</p></li> <li><p><b>Terminated ( Dead ): </b> A runnable thread enters the terminated state when it completes its task or otherwise terminates.</p></li> ', ''),
(492, 'Thread Priorities:', 'Every Java thread has a priority that helps the operating system determine the order in which threads are scheduled.Java thread priorities are in the range between MIN_PRIORITY (a constant of 1) and MAX_PRIORITY (a constant of 10). By default, every thread is given priority NORM_PRIORITY (a constant of 5).Threads with higher priority are more important to a program and should be allocated processor time before lower-priority threads. However, thread priorities cannot guarantee the order in which threads execute and very much platform dependent.', ''),
(493, 'Create Thread by Implementing Runnable Interface:', 'If your class is intended to be executed as a thread then you can achieve this by implementing <b>Runnable</b> interface. You will need to follow three basic steps:As a first step you need to implement a  run() method provided by  <b>Runnable</b> interface. This method provides entry point for the thread and you will put you complete business logic inside this method. Following is simple syntax of run() method:At second step you will instantiate a <b>Thread</b> object using the following constructor:Where, <i>threadObj</i> is an instance of a class that implements the <b>Runnable</b> interface and <b>threadName</b> is the name given to the new thread.Once Thread object is created, you can start it by calling <b>start( )</b> method, which executes a call to run( ) method.  Following is simple syntax of start() method:', '<br><code><pre class="prettyprint notranslate"> public void run( ) </pre></code><br><br><code><pre class="prettyprint notranslate"> Thread(Runnable threadObj, String threadName); </pre></code><br><br><code><pre class="prettyprint notranslate"> void start( ); </pre></code><br>'),
(494, 'Example:', 'Here is an example that creates a new thread and starts it running:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> class RunnableDemo implements Runnable {    private Thread t;    private String threadName;        RunnableDemo( String name){        threadName = name;        System.out.println("Creating " +  threadName );    }    public void run() {       System.out.println("Running " +  threadName );       try {          for(int i = 4; i &gt; 0; i--) {             System.out.println("Thread: " + threadName + ", " + i);             // Let the thread sleep for a while.             Thread.sleep(50);          }      } catch (InterruptedException e) {          System.out.println("Thread " +  threadName + " interrupted.");      }      System.out.println("Thread " +  threadName + " exiting.");    }        public void start ()    {       System.out.println("Starting " +  threadName );       if (t == null)       {          t = new Thread (this, threadName);          t.start ();       }    }  }  public class TestThread {    public static void main(String args[]) {           RunnableDemo R1 = new RunnableDemo( "Thread-1");       R1.start();              RunnableDemo R2 = new RunnableDemo( "Thread-2");       R2.start();    }    } </pre></code><br><br><code><pre class="prettyprint notranslate"> Creating Thread-1 Starting Thread-1 Creating Thread-2 Starting Thread-2 Running Thread-1 Thread: Thread-1, 4 Running Thread-2 Thread: Thread-2, 4 Thread: Thread-1, 3 Thread: Thread-2, 3 Thread: Thread-1, 2 Thread: Thread-2, 2 Thread: Thread-1, 1 Thread: Thread-2, 1 Thread Thread-1 exiting. Thread Thread-2 exiting. </pre></code><br>'),
(495, 'Create Thread by Extending Thread Class:', 'The second way to create a thread is to create a new class that extends <b>Thread</b> class using the following two simple steps. This approach provides more flexibility in handling multiple threads created using available methods in Thread class.You will need to override <b>run( )</b> method available in Thread class. This method provides entry point for the thread and you will put you complete business logic inside this method. Following is simple syntax of run() method:Once Thread object is created, you can start it by calling <b>start( )</b> method, which executes a call to run( ) method.  Following is simple syntax of start() method:', '<br><code><pre class="prettyprint notranslate"> public void run( ) </pre></code><br><br><code><pre class="prettyprint notranslate"> void start( ); </pre></code><br>'),
(496, 'Example:', 'Here is the preceding program rewritten to extend Thread:This would produce the following result:', '<br><code><pre class="prettyprint notranslate tryit"> class ThreadDemo extends Thread {    private Thread t;    private String threadName;        ThreadDemo( String name){        threadName = name;        System.out.println("Creating " +  threadName );    }    public void run() {       System.out.println("Running " +  threadName );       try {          for(int i = 4; i &gt; 0; i--) {             System.out.println("Thread: " + threadName + ", " + i);             // Let the thread sleep for a while.             Thread.sleep(50);          }      } catch (InterruptedException e) {          System.out.println("Thread " +  threadName + " interrupted.");      }      System.out.println("Thread " +  threadName + " exiting.");    }        public void start ()    {       System.out.println("Starting " +  threadName );       if (t == null)       {          t = new Thread (this, threadName);          t.start ();       }    }  }  public class TestThread {    public static void main(String args[]) {           ThreadDemo T1 = new ThreadDemo( "Thread-1");       T1.start();              ThreadDemo T2 = new ThreadDemo( "Thread-2");       T2.start();    }    } </pre></code><br><br><code><pre class="prettyprint notranslate"> Creating Thread-1 Starting Thread-1 Creating Thread-2 Starting Thread-2 Running Thread-1 Thread: Thread-1, 4 Running Thread-2 Thread: Thread-2, 4 Thread: Thread-1, 3 Thread: Thread-2, 3 Thread: Thread-1, 2 Thread: Thread-2, 2 Thread: Thread-1, 1 Thread: Thread-2, 1 Thread Thread-1 exiting. Thread Thread-2 exiting. </pre></code><br>'),
(497, 'Thread Methods:', 'Following is the list of important methods available in the Thread class.The previous methods are invoked on a particular Thread object. The following methods in the Thread class are static. Invoking one of the static methods performs the operation on the currently running thread.', '');
INSERT INTO `textbook` (`textid`, `topic`, `content`, `code`) VALUES
(498, 'Example:', 'The following ThreadClassDemo program demonstrates some of these methods of the Thread class. Consider a class <b>DisplayMessage</b> which implements <b>Runnable</b>:Following is another class which extends Thread class:Following is the main program which makes use of above defined classes:This would produce the following result. You can try this example again and again and you would get different result every time.', '<br><code><pre class="prettyprint notranslate"> // File Name : DisplayMessage.java // Create a thread to implement Runnable public class DisplayMessage implements Runnable {    private String message;    public DisplayMessage(String message)    {       this.message = message;    }    public void run()    {       while(true)       {          System.out.println(message);       }    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> // File Name : GuessANumber.java // Create a thread to extentd Thread public class GuessANumber extends Thread {    private int number;    public GuessANumber(int number)    {       this.number = number;    }    public void run()    {       int counter = 0;       int guess = 0;       do       {           guess = (int) (Math.random() * 100 + 1);           System.out.println(this.getName()                        + " guesses " + guess);           counter++;       }while(guess != number);       System.out.println("** Correct! " + this.getName()                        + " in " + counter + " guesses.**");    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> // File Name : ThreadClassDemo.java public class ThreadClassDemo {    public static void main(String [] args)    {       Runnable hello = new DisplayMessage("Hello");       Thread thread1 = new Thread(hello);       thread1.setDaemon(true);       thread1.setName("hello");       System.out.println("Starting hello thread...");       thread1.start();              Runnable bye = new DisplayMessage("Goodbye");       Thread thread2 = new Thread(bye);       thread2.setPriority(Thread.MIN_PRIORITY);       thread2.setDaemon(true);       System.out.println("Starting goodbye thread...");       thread2.start();        System.out.println("Starting thread3...");       Thread thread3 = new GuessANumber(27);       thread3.start();       try       {          thread3.join();       }catch(InterruptedException e)       {          System.out.println("Thread interrupted.");       }       System.out.println("Starting thread4...");       Thread thread4 = new GuessANumber(75);        	  thread4.start();       System.out.println("main() is ending...");    } } </pre></code><br><br><code><pre class="prettyprint notranslate"> Starting hello thread... Starting goodbye thread... Hello Hello Hello Hello Hello Hello Goodbye Goodbye Goodbye Goodbye Goodbye ....... </pre></code><br>'),
(499, 'Java - Applet Basics', 'An applet is a Java program that runs in a Web browser. An applet can be a fully functional Java application because it has the entire Java API at its disposal.There are some important differences between an applet and a standalone Java application, including the following: <li><p>An applet is a Java class that extends the java.applet.Applet class.</p></li> <li><p>A main() method is not invoked on an applet, and an applet class will not define main().</p></li> <li><p>Applets are designed to be embedded within an HTML page.</p></li> <li><p>When a user views an HTML page that contains an applet, the code for the applet is downloaded to the users machine.</p></li> <li><p>A JVM is required to view an applet. The JVM can be either a plug-in of the Web browser or a separate runtime environment.</p></li> <li><p>The JVM on the users machine creates an instance of the applet class and invokes various methods during the applets lifetime.</p></li> <li><p>Applets have strict security rules that are enforced by the Web browser. The security of an applet is often referred to as sandbox security, comparing the applet to a child playing in a sandbox with various rules that must be followed.</p></li> <li><p>Other classes that the applet needs can be downloaded in a single Java Archive (JAR) file.</p></li> ', ''),
(500, 'Life Cycle of an Applet:', 'Four methods in the Applet class give you the framework on which you build any serious applet: <li><p><b>init:</b> This method is intended for whatever initialization is needed for your applet. It is called after the param tags inside the applet tag have been processed.</p></li> <li><p><b>start:</b> This method is automatically called after the browser calls the init method. It is also called whenever the user returns to the page containing the applet after having gone off to other pages.</p></li> <li><p><b>stop:</b> This method is automatically called when the user moves off the page on which the applet sits. It can, therefore, be called repeatedly in the same applet. </p></li> <li><p><b>destroy:</b> This method is only called when the browser shuts down normally. Because applets are meant to live on an HTML page, you should not normally leave resources behind after a user leaves the page that contains the applet.</p></li> <li><p><b>paint:</b> Invoked immediately after the start() method, and also any time the applet needs to repaint itself in the browser. The paint() method is actually inherited from the java.awt.</p></li> ', ''),
(501, 'A "Hello, World" Applet:', 'The following is a simple applet named HelloWorldApplet.java:These import statements bring the classes into the scope of our applet class: <li><p>java.applet.Applet.</p></li> <li><p>java.awt.Graphics.</p></li> Without those import statements, the Java compiler would not recognize the classes Applet and Graphics, which the applet class refers to.', '<br><code><pre class="prettyprint notranslate"> import java.applet.*; import java.awt.*;  public class HelloWorldApplet extends Applet {    public void paint (Graphics g)    {       g.drawString ("Hello World", 25, 50);    } } </pre></code><br>'),
(502, 'The Applet CLASS:', 'Every applet is an extension of the <i>java.applet.Applet class</i>. The base Applet class provides methods that a derived Applet class may call to obtain information and services from the browser context.These include methods that do the following: <li><p>Get applet parameters</p></li> <li><p>Get the network location of the HTML file that contains the applet</p></li> <li><p>Get the network location of the applet class directory</p></li> <li><p>Print a status message in the browser</p></li> <li><p>Fetch an image</p></li> <li><p>Fetch an audio clip</p></li> <li><p>Play an audio clip</p></li> <li><p>Resize the applet</p></li> Additionally, the Applet class provides an interface by which the viewer or browser obtains information about the applet and controls the applets execution. The viewer may: <li><p>request information about the author, version and copyright of the applet</p></li> <li><p>request a description of the parameters the applet recognizes</p></li> <li><p>initialize the applet</p></li> <li><p>destroy the applet</p></li> <li><p>start the applets execution</p></li> <li><p>stop the applets execution</p></li> The Applet class provides default implementations of each of these methods. Those implementations may be overridden as necessary.The "Hello, World" applet is complete as it stands. The only method overridden is the paint method.', ''),
(503, 'Invoking an Applet:', 'An applet may be invoked by embedding directives in an HTML file and viewing the file through an applet viewer or Java-enabled browser.The &lt;applet&gt; tag is the basis for embedding an applet in an HTML file. Below is an example that invokes the "Hello, World" applet:<b>Note:</b> You can refer to <a href="/html/html_applet_tag.htm" title="HTML Applet Tag" target="_blank">HTML Applet Tag</a> to understand more about calling applet from HTML.The code attribute of the &lt;applet&gt; tag is required. It specifies the Applet class to run. Width and height are also required to specify the initial size of the panel in which an applet runs. The applet directive must be closed with a &lt;/applet&gt; tag.If an applet takes parameters, values may be passed for the parameters by adding &lt;param&gt; tags between &lt;applet&gt; and &lt;/applet&gt;. The browser ignores text and other tags between the applet tags.Non-Java-enabled browsers do not process &lt;applet&gt; and &lt;/applet&gt;. Therefore, anything that appears between the tags, not related to the applet, is visible in non-Java-enabled browsers.The viewer or browser looks for the compiled Java code at the location of the document. To specify otherwise, use the codebase attribute of the &lt;applet&gt; tag as shown:If an applet resides in a package other than the default, the holding package must be specified in the code attribute using the period character (.) to separate package/class components. For example:', '<br><code><pre class="prettyprint notranslate"> &lt;html&gt; &lt;title&gt;The Hello, World Applet&lt;/title&gt; &lt;hr&gt; &lt;applet code="HelloWorldApplet.class" width="320" height="120"&gt; If your browser was Java-enabled, a "Hello, World" message would appear here. &lt;/applet&gt; &lt;hr&gt; &lt;/html&gt; </pre></code><br><br><code><pre class="prettyprint notranslate"> &lt;applet codebase="http://amrood.com/applets" code="HelloWorldApplet.class" width="320" height="120"&gt; </pre></code><br><br><code><pre class="prettyprint notranslate"> &lt;applet code="mypackage.subpackage.TestApplet.class"             width="320" height="120"&gt; </pre></code><br>'),
(504, 'Getting Applet Parameters:', 'The following example demonstrates how to make an applet respond to setup parameters specified in the document. This applet displays a checkerboard pattern of black and a second color.The second color and the size of each square may be specified as parameters to the applet within the document.CheckerApplet gets its parameters in the init() method. It may also get its parameters in the paint() method. However, getting the values and saving the settings once at the start of the applet, instead of at every refresh, is convenient and efficient.The applet viewer or browser calls the init() method of each applet it runs. The viewer calls init() once, immediately after loading the applet. (Applet.init() is implemented to do nothing.) Override the default implementation to insert custom initialization code.The Applet.getParameter() method fetches a parameter given the parameters name (the value of a parameter is always a string). If the value is numeric or other non-character data, the string must be parsed.The following is a skeleton of CheckerApplet.java:Here are CheckerApplets init() and private parseSquareSize() methods:The applet calls parseSquareSize() to parse the squareSize parameter. parseSquareSize() calls the library method Integer.parseInt(), which parses a string and returns an integer. Integer.parseInt() throws an exception whenever its argument is invalid.Therefore, parseSquareSize() catches exceptions, rather than allowing the applet to fail on bad input.The applet calls parseColor() to parse the color parameter into a Color value. parseColor() does a series of string comparisons to match the parameter value to the name of a predefined color. You need to implement these methods to make this applet works.', '<br><code><pre class="prettyprint notranslate"> import java.applet.*; import java.awt.*; public class CheckerApplet extends Applet {    int squareSize = 50;// initialized to default size    public void init () {}    private void parseSquareSize (String param) {}    private Color parseColor (String param) {}    public void paint (Graphics g) {} } </pre></code><br><br><code><pre class="prettyprint notranslate"> public void init () {    String squareSizeParam = getParameter ("squareSize");    parseSquareSize (squareSizeParam);    String colorParam = getParameter ("color");    Color fg = parseColor (colorParam);    setBackground (Color.black);    setForeground (fg); } private void parseSquareSize (String param) {    if (param == null) return;    try {       squareSize = Integer.parseInt (param);    }    catch (Exception e) {      // Let default value remain    } } </pre></code><br>'),
(505, 'Specifying Applet Parameters:', 'The following is an example of an HTML file with a CheckerApplet embedded in it. The HTML file specifies both parameters to the applet by means of the &lt;param&gt; tag.<b>Note:</b> Parameter names are not case sensitive.', '<br><code><pre class="prettyprint notranslate"> &lt;html&gt; &lt;title&gt;Checkerboard Applet&lt;/title&gt; &lt;hr&gt; &lt;applet code="CheckerApplet.class" width="480" height="320"&gt; &lt;param name="color" value="blue"&gt; &lt;param name="squaresize" value="30"&gt; &lt;/applet&gt; &lt;hr&gt; &lt;/html&gt; </pre></code><br>'),
(506, 'Application Conversion to Applets:', 'It is easy to convert a graphical Java application (that is, an application that uses the AWT and that you can start with the java program launcher) into an applet that you can embed in a web page.Here are the specific steps for converting an application to an applet. <li><p>Make an HTML page with the appropriate tag to load the applet code.</p></li> <li><p>Supply a subclass of the JApplet class. Make this class public. Otherwise, the applet cannot be loaded.</p></li> <li><p>Eliminate the main method in the application. Do not construct a frame window for the application. Your application will be displayed inside the browser.</p></li> <li><p>Move any initialization code from the frame window constructor to the init method of the applet. You dont need to explicitly construct the applet object.the browser instantiates it for you and calls the init method.</p></li> <li><p>Remove the call to setSize; for applets, sizing is done with the width and height parameters in the HTML file.</p></li> <li><p>Remove the call to setDefaultCloseOperation. An applet cannot be closed; it terminates when the browser exits.</p></li> <li><p>If the application calls setTitle, eliminate the call to the method. Applets cannot have title bars. (You can, of course, title the web page itself, using the HTML title tag.)</p></li> <li><p>Dont call setVisible(true). The applet is displayed automatically.</p></li> ', ''),
(507, 'Event Handling:', 'Applets inherit a group of event-handling methods from the Container class.  The Container class defines several methods, such as processKeyEvent and processMouseEvent, for handling particular types of events, and then one catch-all method called processEvent.In order to react an event, an applet must override the appropriate event-specific method.Now, let us call this applet as follows:Initially, the applet will display "initializing the applet. Starting the applet." Then once you click inside the rectangle "mouse clicked" will be displayed as well.', '<br><code><pre class="prettyprint notranslate"> import java.awt.event.MouseListener; import java.awt.event.MouseEvent; import java.applet.Applet; import java.awt.Graphics;  public class ExampleEventHandling extends Applet  			 implements MouseListener {      StringBuffer strBuffer;      public void init() { 	addMouseListener(this); 	strBuffer = new StringBuffer();         addItem("initializing the apple ");     }      public void start() {         addItem("starting the applet ");     }      public void stop() {         addItem("stopping the applet ");     }      public void destroy() {         addItem("unloading the applet");     }      void addItem(String word) {         System.out.println(word);         strBuffer.append(word);         repaint();     }      public void paint(Graphics g) { 	//Draw a Rectangle around the applets display area.         g.drawRect(0, 0,  		   getWidth() - 1, 		   getHeight() - 1);  	//display the string inside the rectangle.         g.drawString(strBuffer.toString(), 10, 20);     }          public void mouseEntered(MouseEvent event) {     }     public void mouseExited(MouseEvent event) {     }     public void mousePressed(MouseEvent event) {     }     public void mouseReleased(MouseEvent event) {     }      public void mouseClicked(MouseEvent event) { 	addItem("mouse clicked! ");     } } </pre></code><br><br><code><pre class="prettyprint notranslate"> &lt;html&gt; &lt;title&gt;Event Handling&lt;/title&gt; &lt;hr&gt; &lt;applet code="ExampleEventHandling.class"  width="300" height="300"&gt; &lt;/applet&gt; &lt;hr&gt; &lt;/html&gt; </pre></code><br>'),
(508, 'Displaying Images:', 'An applet can display images of the format GIF, JPEG, BMP, and others. To display an image within the applet, you use the drawImage() method found in the java.awt.Graphics class.Following is the example showing all the steps to show images:Now, let us call this applet as follows:', '<br><code><pre class="prettyprint notranslate"> import java.applet.*; import java.awt.*; import java.net.*; public class ImageDemo extends Applet {   private Image image;   private AppletContext context;   public void init()   {       context = this.getAppletContext();       String imageURL = this.getParameter("image");       if(imageURL == null)       {          imageURL = "java.jpg";       }       try       {          URL url = new URL(this.getDocumentBase(), imageURL);          image = context.getImage(url);       }catch(MalformedURLException e)       {          e.printStackTrace();          // Display in browser status bar          context.showStatus("Could not load image!");       }    }    public void paint(Graphics g)    {       context.showStatus("Displaying image");       g.drawImage(image, 0, 0, 200, 84, null);       g.drawString("www.javalicense.com", 35, 100);    }   } </pre></code><br><br><code><pre class="prettyprint notranslate"> &lt;html&gt; &lt;title&gt;The ImageDemo applet&lt;/title&gt; &lt;hr&gt; &lt;applet code="ImageDemo.class" width="300" height="200"&gt; &lt;param name="image" value="java.jpg"&gt; &lt;/applet&gt; &lt;hr&gt; &lt;/html&gt; </pre></code><br>'),
(509, 'Java Documentation Comments', 'The Java language supports three types of comments:This tutorial is all about explaining Javadoc. We will see how we can make use of Javadoc for generating useful documentation for our Java code.', ''),
(510, 'What is Javadoc?', 'Javadoc is a tool which comes with JDK and it is used for generating Java code documentation in HTML format from Java source code which has required documentation in a predefined format.Following is a simple example where red part of the code represents Java comments:You can include required HTML tags inside the description part, For example, below example makes use of &lt;h1&gt;....&lt;/h1&gt; for heading and &lt;p&gt; has been used for creating paragraph break:', '<br><code><pre class="prettyprint notranslate"> /** * The HelloWorld program implements an application that * simply displays "Hello World!" to the standard output. * * @author  Zara Ali * @version 1.0 * @since   2014-03-31  */ public class HelloWorld {     public static void main(String[] args) {         /* Prints Hello, World! on standard output.         System.out.println("Hello World!");     } } </pre></code><br><br><code><pre class="prettyprint notranslate"> /** * &lt;h1&gt;Hello, World!&lt;/h1&gt; * The HelloWorld program implements an application that * simply displays "Hello World!" to the standard output. * &lt;p&gt; * Giving proper comments in your program makes it more * user friendly and it is assumed as a high quality code. *  * * @author  Zara Ali * @version 1.0 * @since   2014-03-31  */ public class HelloWorld {     public static void main(String[] args) {         /* Prints Hello, World! on standard output.         System.out.println("Hello World!");     } } </pre></code><br>'),
(511, 'The javadoc Tags:', 'The javadoc tool recognizes the following tags:', ''),
(512, 'What is Java?', 'Java is: <li>Object Oriented </li> <li>Platform independent:</li> <li>Simple</li> <li>Secure</li> <li>Architectural- neutral</li> <li>Portable</li> <li>Robust</li> <li>Multi-threaded </li> <li>Interpreted </li> <li>High Performance</li> <li>Distributed </li> <li>Dynamic</li> ', ''),
(513, 'Java Environment Setup:', 'Java SE is freely available from the link <a href="http://java.sun.com/javase/downloads/index_jdk5.jsp" target="_blank">Download Java</a>. So you download a version based on your operating system.You can refer to installation guide for a complete detail.', ''),
(514, 'Java Basic Syntax:', ' <li><p><b>Object -</b> Objects have states and behaviors. Example: A dog has states-color, name, breed as well as behaviors -wagging, barking, eating. An object is an instance of a class. </p></li> <li><p><b>Class -</b> A class can be defined as a template/ blue print that describe the behaviors/states that object of its type support.</p></li> <li><p><b>Methods -</b> A method is basically a behavior. A class can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.</p></li> <li><p><b>Instant Variables -</b> Each object has its unique set of instant variables. An objects state is created by the values assigned to these instant variables.</p></li> ', ''),
(515, 'First Java Program:', 'Let us look at a simple code that would print the words <i>Hello World</i>.About Java programs, it is very important to keep in mind the following points. <li><p><b>Case Sensitivity - </b> Java is case sensitive which means identifier <b>Hello</b> and <b>hello</b> would have different meaning in Java.</p></li> <li><p><b>Class Names - </b> For all class names the first letter should be in Upper Case. <br /><br /> If several words are used to form a name of the class each inner words first letter should be in Upper Case.<br /><br /> Example <i>class MyFirstJavaClass </i></p></li> <li><p><b>Method Names - </b> All method names should start with a Lower Case letter.  <br /><br /> If several words are  used to form the name of the method, then each inner words first letter should be in Upper Case.<br /><br /> Example <i>public void myMethodName()</i></p></li> <li><p><b>Program File Name - </b> Name of the program file should exactly match the class name.  <br /><br /> When saving the file you should save it using the class name (Remember java is case sensitive) and append .java to the end of the name. (if the file name and the class name do not match your program will not compile).<br /><br /> Example : Assume MyFirstJavaProgram is the class  name. Then the file should be saved as <i>MyFirstJavaProgram.java</i></p></li> <li><p><b>public static void main(String args[]) -</b> java program processing starts from the main() method which is a mandatory part of every java program..</p></li> ', '<br><code><pre class="prettyprint notranslate"> public class MyFirstJavaProgram{     /* This is my first java program.       * This will print Hello World as the output     */      public static void main(String []args){        System.out.println("Hello World"); // prints Hello World     } }  </pre></code><br>'),
(516, 'Java Identifiers:', 'All Java components require names. Names used for classes, variables and methods are called identifiers.In java there are several points to remember about identifiers. They are as follows: <li><p>All identifiers should begin with a letter (A to Z or a to z ), currency character ($) or an underscore (_).</p></li> <li><p>After the first character identifiers can have any combination of characters.</p></li> <li><p>A key word cannot be used as an identifier.</p></li> <li><p>Most importantly identifiers are case sensitive.</p></li> <li><p>Examples of legal identifiers:age, $salary, _value,  __1_value</p></li> <li><p>Examples of illegal identifiers : 123abc, -salary</p></li> ', ''),
(517, 'Java Modifiers:', 'Like other languages, it is possible to modify classes, methods, etc., by using modifiers. There are two categories of modifiers. <li><p><b>Access Modifiers : </b> default, public , protected, private</p></li> <li><p><b>Non-access Modifiers : </b> final, abstract, strictfp</p></li> We will be looking into more details about modifiers in the next section.', ''),
(518, 'Java Variables:', 'We would see following type of variables in Java: <li>Local Variables</li> <li>Class Variables (Static Variables)</li> <li>Instance Variables (Non static variables)</li> ', ''),
(519, 'Java Arrays:', 'Arrays are objects that store multiple variables of the same type. However an Array itself is an object on the heap. We will look into how to declare, construct and initialize in the upcoming chapters.', ''),
(520, 'Java Enums:', 'Enums were introduced in Java 5.0. Enums restrict a variable to have one of only a few predefined values. The values in this enumerated list are called enums.With the use of enums it is possible to reduce the number of bugs in your code. For example if we consider an application for a fresh juice shop it would be possible to restrict the glass size to small, medium and Large. This would make sure that it would not allow anyone to order any size other than the small, medium or large.', ''),
(521, 'Example:', '<b>Note:</b> enums can be declared as their own or inside a class. Methods, variables, constructors can be defined inside enums as well.', '<br><code><pre class="prettyprint notranslate"> class FreshJuice{     enum FreshJuiceSize{ SMALL, MEDIUM, LARGE }    FreshJuiceSize size; }  public class FreshJuiceTest{     public static void main(String args[]){       FreshJuice juice = new FreshJuice();       juice.size = FreshJuice. FreshJuiceSize.MEDIUM ;       System.out.println("Size :" + juice.size);    } } </pre></code><br>'),
(522, 'Java Keywords:', 'The following list shows the reserved words in Java. These reserved words may not be used as constant or variable or any other identifier names.', ''),
(523, 'Comments in Java', 'Java supports single line and multi-line comments very similar to c and c++. All characters available inside any comment are ignored by Java compiler.', '<br><code><pre class="prettyprint notranslate"> public class MyFirstJavaProgram{     /* This is my first java program.     * This will print Hello World as the output     * This is an example of multi-line comments.     */      public static void main(String []args){        // This is an example of single line comment        /* This is also an example of single line comment. */        System.out.println("Hello World");      } }  </pre></code><br>'),
(524, 'Data Types in Java', 'There are two data types available in Java: <li><p>Primitive Data Types</p></li> <li><p>Reference/Object Data Types</p></li> ', ''),
(525, 'Primitive Data Types:', 'There are eight primitive data types supported by Java. Primitive data types are predefined by the language and named by a key word. Let us now look into detail about the eight primitive data types. <li>byte</li> <li>short</li> <li>int</li> <li>long</li> <li>float</li> <li>double</li> <li>boolean</li> <li>char</li> ', ''),
(526, 'Reference Data Types:', ' <li><p>Reference variables are created using defined constructors of the classes. They are used to access objects. These variables are declared to be of a specific type that cannot be changed. For example, Employee, Puppy etc.</p></li>  <li><p>Class objects, and various type of array variables come under reference data type.</p></li> <li><p>Default value of any reference variable is null.</p></li>  <li><p>A reference variable can be used to refer to any object of the declared type or any compatible type.</p></li>  <li><p>Example : Animal animal = new Animal("giraffe");</p></li>  ', ''),
(527, 'Java Literals:', 'A literal is a source code representation of a fixed value. They are represented directly in the code without any computation.Literals can be assigned to any primitive type variable. For example:String literals in Java are specified like they are in most other languages by enclosing a sequence of characters between a pair of double quotes. Examples of string literals are:Java language supports few special escape sequences for String and char literals as well. They are:', '<br><code><pre class="prettyprint notranslate"> byte a = 68; char a = A </pre></code><br><br><code><pre class="prettyprint notranslate"> "Hello World" "two\nlines" ""This is in quotes"" </pre></code><br>'),
(528, 'Java Access Modifiers:', 'Java provides a number of access modifiers to set access levels for classes, variables, methods and constructors. The four access levels are: <li><p>Visible to the package. the default. No modifiers are needed.</p></li> <li><p>Visible to the class only (private).</p></li> <li><p>Visible to the world (public).</p></li> <li><p>Visible to the package and all subclasses (protected).</p></li> ', ''),
(529, 'Java Basic Operators:', 'Java provides a rich set of operators to manipulate variables. We can divide all the Java operators into the following groups:', ''),
(530, 'Misc Operators', 'There are few other operators supported by Java Language.', ''),
(531, 'Conditional Operator ( ? : ):', 'Conditional operator is also known as the ternary operator. This operator consists of three operands and is used to evaluate boolean expressions. The goal of the operator is to decide which value should be assigned to the variable. The operator is written as :', '<br><code><pre class="prettyprint notranslate"> variable x = (expression) ? value if true : value if false </pre></code><br>'),
(532, 'instanceOf Operator:', 'This operator is used only for object reference variables. The operator checks whether the object is of a particular type(class type or interface type).  instanceOf operator is wriiten as:', '<br><code><pre class="prettyprint notranslate"> ( Object reference variable ) instanceOf  (class/interface type) </pre></code><br>'),
(533, 'The while Loop:', 'A while loop is a control structure that allows you to repeat a task a certain number of times.', ''),
(534, 'Syntax:', 'The syntax of a while loop is:', '<br><code><pre class="prettyprint notranslate"> while(Boolean_expression) {    //Statements } </pre></code><br>'),
(535, 'The do...while Loop:', 'A do...while loop is similar to a while loop, except that a do...while loop is guaranteed to execute at least one time.', ''),
(536, 'Syntax:', 'The syntax of a do...while loop is:', '<br><code><pre class="prettyprint notranslate"> do {    //Statements }while(Boolean_expression); </pre></code><br>'),
(537, 'The for Loop:', 'A for loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times.A for loop is useful when you know how many times a task is to be repeated.', ''),
(538, 'Syntax:', 'The syntax of a for loop is:', '<br><code><pre class="prettyprint notranslate"> for(initialization; Boolean_expression; update) {    //Statements } </pre></code><br>'),
(539, 'Enhanced for loop in Java:', 'As of java 5 the enhanced for loop was introduced. This is mainly used for Arrays.', ''),
(540, 'Syntax:', 'The syntax of enhanced for loop is:', '<br><code><pre class="prettyprint notranslate"> for(declaration : expression) {    //Statements } </pre></code><br>'),
(541, 'The break Keyword:', 'The <i>break</i> keyword is used to stop the entire loop. The break keyword must be used inside any loop or a switch statement.The break keyword will stop the execution of the innermost loop and start executing the next line of code after the block.', ''),
(542, 'The continue Keyword:', 'The <i>continue</i> keyword can be used in any of the loop control structures. It causes the loop to immediately jump to the next iteration of the loop. <li><p>In a for loop, the continue keyword causes flow of control to immediately jump to the update statement.</p></li> <li><p>In a while loop or do/while loop, flow of control immediately jumps to the Boolean expression.</p></li> ', ''),
(543, 'Syntax:', 'The syntax of a continue is a single statement inside any loop:', '<br><code><pre class="prettyprint notranslate"> continue; </pre></code><br>'),
(544, 'The if Statement:', 'An if statement consists of a Boolean expression followed by one or more statements.', ''),
(545, 'Syntax:', 'The syntax of an if statement is:', '<br><code><pre class="prettyprint notranslate"> if(Boolean_expression) {    //Statements will execute if the Boolean expression is true } </pre></code><br>'),
(546, 'The if...else Statement:', 'An if statement can be followed by an optional <i>else</i> statement, which executes when the Boolean expression is false.', ''),
(547, 'Syntax:', 'The syntax of a if...else is:', '<br><code><pre class="prettyprint notranslate"> if(Boolean_expression){    //Executes when the Boolean expression is true }else{    //Executes when the Boolean expression is false } </pre></code><br>'),
(548, 'The if...else if...else Statement:', 'An if statement can be followed by an optional <i>else if...else</i> statement, which is very usefull to test various conditions using single if...else if statement.', ''),
(549, 'Syntax:', 'The syntax of a if...else is:', '<br><code><pre class="prettyprint notranslate"> if(Boolean_expression 1){    //Executes when the Boolean expression 1 is true }else if(Boolean_expression 2){    //Executes when the Boolean expression 2 is true }else if(Boolean_expression 3){    //Executes when the Boolean expression 3 is true }else {    //Executes when the one of the above condition is true. } </pre></code><br>'),
(550, 'Nested if...else Statement:', 'It is always legal to nest if-else statements. When using if , else if , else statements there are few points to keep in mind. <li><p>An if can have zero or one elses and it must come after any else ifs.</p></li> <li><p>An if can have zero to many else ifs and they must come before the else.</p></li> <li><p>Once an else if succeeds, none of he remaining else ifs or elses will be tested.</p></li> ', ''),
(551, 'Syntax:', 'The syntax for a nested if...else is as follows:', '<br><code><pre class="prettyprint notranslate"> if(Boolean_expression 1){    //Executes when the Boolean expression 1 is true    if(Boolean_expression 2){       //Executes when the Boolean expression 2 is true    } } </pre></code><br>'),
(552, 'The switch Statement:', 'A <i>switch</i> statement allows a variable to be tested for equality against a list of values. Each value is called a case, and the variable being switched on is checked for each case.', ''),
(553, 'Syntax:', 'The syntax of enhanced for loop is:', '<br><code><pre class="prettyprint notranslate"> switch(expression){     case value :        //Statements        break; //optional     case value :        //Statements        break; //optional     //You can have any number of case statements.     default : //Optional        //Statements } </pre></code><br>'),
(554, 'Java Methods:', 'A Java method is a collection of statements that are grouped together to perform an operation. When you call the System.out.println method, for example, the system actually executes several statements in order to display a message on the console.In general, a method has the following syntax:A method definition consists of a method header and a method body. Here are all the parts of a method: <li><p><b>Modifiers:</b> The modifier, which is optional, tells the compiler how to call the method. This defines the access type of the method.</p></li> <li><p><b>Return Type:</b> A method may return a value. The returnValueType is the data type of the value the method returns. Some methods perform the desired operations without returning a value. In this case, the returnValueType is the keyword <b>void</b>.</p></li> <li><p><b>Method Name:</b> This is the actual name of the method. The method name and the parameter list together constitute the method signature.</p></li> <li><p><b>Parameters:</b> A parameter is like a placeholder. When a method is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of the parameters of a method. Parameters are optional; that is, a method may contain no parameters.</p></li> <li><p><b>Method Body:</b> The method body contains a collection of statements that define what the method does.</p></li> ', '<br><code><pre class="prettyprint notranslate"> modifier returnValueType methodName(list of parameters) {   // Method body; } </pre></code><br>'),
(555, 'Java Classes &amp; Objects:', ' <li><p><b>Object -</b> Objects have states and behaviors. Example: A dog has states-color, name, breed as well as behaviors -wagging, barking, eating. An object is an instance of a class. </p></li> <li><p><b>Class -</b> A class can be defined as a template/ blue print that describe the behaviors/states that object of its type support.</p></li> A sample of a class is given below:A class can contain any of the following variable types. <li><p><b>Local variables . </b>variables defined inside methods, constructors or blocks are called local variables. The variable will be declared and initialized within the method and the variable will be destroyed when the method has completed.</p></li> <li><p><b>Instance variables . </b>Instance variables are variables within a class but outside any method. These variables are instantiated when the class is loaded. Instance variables can be accessed from inside any method, constructor or blocks of that particular class.</p></li> <li><p><b>Class variables . </b> Class variables are variables declared with in a class, outside any method, with the static keyword.</p></li> ', '<br><code><pre class="prettyprint notranslate"> public class Dog{    String breed;    int age;    String color;     void barking(){    }        void hungry(){    }        void sleeping(){    } } </pre></code><br>'),
(556, 'Exceptions Handling:', 'A method catches an exception using a combination of the <b>try</b> and <b>catch</b> keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following:', '<br><code><pre class="prettyprint notranslate"> try {    //Protected code }catch(ExceptionName e1) {    //Catch block } </pre></code><br>'),
(557, 'Multiple catch Blocks:', 'A try block can be followed by multiple catch blocks. The syntax for multiple catch blocks looks like the following:', '<br><code><pre class="prettyprint notranslate"> try {    //Protected code }catch(ExceptionType1 e1) {    //Catch block }catch(ExceptionType2 e2) {    //Catch block }catch(ExceptionType3 e3) {    //Catch block } </pre></code><br>'),
(558, 'The throws/throw Keywords:', 'If a method does not handle a checked exception, the method must declare it using the <b>throws</b> keyword. The throws keyword appears at the end of a methods signature.You can throw an exception, either a newly instantiated one or an exception that you just caught, by using the <b>throw</b> keyword. Try to understand the different in throws and throw keywords.', ''),
(559, 'Java - Useful Resources', 'The following resources contain additional information on Java. Please use them to get more in-depth knowledge on this topic.', ''),
(560, 'Useful Links on Java', ' <li><p><a target="_blank" rel="nofollow" href="http://java.sun.com/docs/books/tutorial/index.html">The Java<sup><font size="-2">TM</font></sup> Tutorials</a> &minus; The Java Tutorials are practical guides for programmers who want to use the Java programming language to create applications.</p></li> <li><p><a target="_blank" rel="nofollow" href="http://java.sun.com/j2se/1.4.2/docs/index.html">Java<sup><font size="-2">TM</font></sup> 2 SDK, Standard Edition </a> &minus; Official site for Java<sup><font size="-2">TM</font></sup> 2 SDK, Standard Edition </p></li> <li><p><a target="_blank" rel="nofollow" href="http://www.java.com/en/download/index.jsp">Free Java Download</a> &minus; Download Java for your desktop computer now!</p></li> <li><p><a target="_blank" rel="nofollow" href="http://java.sun.com/reference/docs/">Sun Developer Network</a> &minus; Sun Microsystems official website listing down all the API documentation, latest Java Technologies, Books and other resource.</p></li> ', ''),
(561, 'Java - Overview', 'Java programming language was originally developed by Sun Microsystems which was initiated by James Gosling and released in 1995 as core component of Sun Microsystems Java platform (Java 1.0 [J2SE]).The latest release of the Java Standard Edition is Java SE 8. With the advancement of Java and its widespread popularity, multiple configurations were built to suite various types of platforms. Ex: J2EE for Enterprise Applications, J2ME for Mobile Applications.The new J2 versions were renamed as Java SE, Java EE and Java ME respectively. Java is guaranteed to be <b>Write Once, Run Anywhere.</b>Java is: <li><p><b>Object Oriented:</b> In Java, everything is an Object. Java can be easily extended since it is based on the Object model.</p></li> <li><p><b>Platform independent:</b> Unlike many other programming languages including C and C++, when Java is compiled, it is not compiled into platform specific machine, rather into platform independent byte code. This byte code is distributed over the web and interpreted by virtual Machine (JVM) on whichever platform it is being run.</p></li> <li><p><b>Simple:</b> Java is designed to be easy to learn. If you understand the basic concept of OOP Java would be easy to master.</p></li> <li><p><b>Secure:</b> With Javas secure feature it enables to develop virus-free, tamper-free systems. Authentication techniques are based on public-key encryption.</p></li> <li><p><b>Architectural-neutral: </b>Java compiler generates an architecture-neutral object file format which makes the compiled code to be executable on many processors, with the presence of Java runtime system.</p></li> <li><p><b>Portable:</b> Being architectural-neutral and having no implementation dependent aspects of the specification makes Java portable. Compiler in Java is written in ANSI C with a clean portability boundary which is a POSIX subset.</p></li> <li><p><b>Robust:</b> Java makes an effort to eliminate error prone situations by emphasizing mainly on compile time error checking and runtime checking.</p></li> <li><p><b>Multithreaded:</b> With Javas multithreaded feature it is possible to write programs that can do many tasks simultaneously. This design feature allows developers to construct smoothly running interactive applications.</p></li> <li><p><b>Interpreted:</b> Java byte code is translated on the fly to native machine instructions and is not stored anywhere. The development process is more rapid and analytical since the linking is an incremental and light weight process. </p></li> <li><p><b>High Performance:</b> With the use of Just-In-Time compilers, Java enables high performance.</p></li> <li><p><b>Distributed:</b> Java is designed for the distributed environment of the internet.</p></li> <li><p><b>Dynamic:</b> Java is considered to be more dynamic than C or C++ since it is designed to adapt to an evolving environment. Java programs can carry extensive amount of run-time information that can be used to verify and resolve accesses to objects on run-time.</p></li> ', ''),
(562, 'History of Java:', 'James Gosling initiated the Java language project in June 1991 for use in one of his many set-top box projects. The language, initially called Oak after an oak tree that stood outside Goslings office, also went by the name Green and ended up later being renamed as Java, from a list of random words.Sun released the first public implementation as Java 1.0 in 1995. It promised <b>Write Once, Run Anywhere</b>(WORA), providing no-cost run-times on popular platforms. On 13 November 2006, Sun released much of Java as free and open source software under the terms of the GNU General Public License (GPL).On 8 May 2007, Sun finished the process, making all of Javas core code free and open-source, aside from a small portion of code to which Sun did not hold the copyright.', ''),
(563, 'Tools you will need:', 'For performing the examples discussed in this tutorial, you will need a Pentium 200-MHz computer with a minimum of 64 MB of RAM (128 MB of RAM recommended).You also will need the following softwares: <li><p>Linux 7.1 or Windows xp/7/8 operating system.</p></li> <li><p>Java JDK 8 </p></li> <li><p>Microsoft Notepad or any other text editor</p></li> This tutorial will provide the necessary skills to create GUI, networking, and Web applications using Java.', ''),
(564, 'Try It Option:', 'We have provided you an option to compile and execute available code online. Just click on <b>Try it</b> button avaiable at top-right corner of the code window to compile and execute available code. There are certain examples which can not be executed online, so we have skipped those examples.There may be a case that you do not see the result of the compiled/executed code, in such case you can re-try to compile and execute the code using <b>execute</b> button available in compliation pop-up window.', '<br><code><pre class="prettyprint notranslate tryit"> public class MyFirstJavaProgram {      public static void main(String []args) {        System.out.println("Hello World");     } }  </pre></code><br>'),
(565, 'What is Java?', 'Java is: <li>Object Oriented </li> <li>Platform independent:</li> <li>Simple</li> <li>Secure</li> <li>Architectural- neutral</li> <li>Portable</li> <li>Robust</li> <li>Multi-threaded </li> <li>Interpreted </li> <li>High Performance</li> <li>Distributed </li> <li>Dynamic</li> ', ''),
(566, 'Java Environment Setup:', 'Java SE is freely available from the link <a href="http://java.sun.com/javase/downloads/index_jdk5.jsp" target="_blank">Download Java</a>. So you download a version based on your operating system.You can refer to installation guide for a complete detail.', ''),
(567, 'Java Basic Syntax:', ' <li><p><b>Object -</b> Objects have states and behaviors. Example: A dog has states-color, name, breed as well as behaviors -wagging, barking, eating. An object is an instance of a class. </p></li> <li><p><b>Class -</b> A class can be defined as a template/ blue print that describe the behaviors/states that object of its type support.</p></li> <li><p><b>Methods -</b> A method is basically a behavior. A class can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.</p></li> <li><p><b>Instant Variables -</b> Each object has its unique set of instant variables. An objects state is created by the values assigned to these instant variables.</p></li> ', ''),
(568, 'First Java Program:', 'Let us look at a simple code that would print the words <i>Hello World</i>.About Java programs, it is very important to keep in mind the following points. <li><p><b>Case Sensitivity - </b> Java is case sensitive which means identifier <b>Hello</b> and <b>hello</b> would have different meaning in Java.</p></li> <li><p><b>Class Names - </b> For all class names the first letter should be in Upper Case. <br /><br /> If several words are used to form a name of the class each inner words first letter should be in Upper Case.<br /><br /> Example <i>class MyFirstJavaClass </i></p></li> <li><p><b>Method Names - </b> All method names should start with a Lower Case letter.  <br /><br /> If several words are  used to form the name of the method, then each inner words first letter should be in Upper Case.<br /><br /> Example <i>public void myMethodName()</i></p></li> <li><p><b>Program File Name - </b> Name of the program file should exactly match the class name.  <br /><br /> When saving the file you should save it using the class name (Remember java is case sensitive) and append .java to the end of the name. (if the file name and the class name do not match your program will not compile).<br /><br /> Example : Assume MyFirstJavaProgram is the class  name. Then the file should be saved as <i>MyFirstJavaProgram.java</i></p></li> <li><p><b>public static void main(String args[]) -</b> java program processing starts from the main() method which is a mandatory part of every java program..</p></li> ', '<br><code><pre class="prettyprint notranslate"> public class MyFirstJavaProgram{     /* This is my first java program.       * This will print Hello World as the output     */      public static void main(String []args){        System.out.println("Hello World"); // prints Hello World     } }  </pre></code><br>'),
(569, 'Java Identifiers:', 'All Java components require names. Names used for classes, variables and methods are called identifiers.In java there are several points to remember about identifiers. They are as follows: <li><p>All identifiers should begin with a letter (A to Z or a to z ), currency character ($) or an underscore (_).</p></li> <li><p>After the first character identifiers can have any combination of characters.</p></li> <li><p>A key word cannot be used as an identifier.</p></li> <li><p>Most importantly identifiers are case sensitive.</p></li> <li><p>Examples of legal identifiers:age, $salary, _value,  __1_value</p></li> <li><p>Examples of illegal identifiers : 123abc, -salary</p></li> ', ''),
(570, 'Java Modifiers:', 'Like other languages, it is possible to modify classes, methods, etc., by using modifiers. There are two categories of modifiers. <li><p><b>Access Modifiers : </b> default, public , protected, private</p></li> <li><p><b>Non-access Modifiers : </b> final, abstract, strictfp</p></li> We will be looking into more details about modifiers in the next section.', ''),
(571, 'Java Variables:', 'We would see following type of variables in Java: <li>Local Variables</li> <li>Class Variables (Static Variables)</li> <li>Instance Variables (Non static variables)</li> ', '');
INSERT INTO `textbook` (`textid`, `topic`, `content`, `code`) VALUES
(572, 'Java Arrays:', 'Arrays are objects that store multiple variables of the same type. However an Array itself is an object on the heap. We will look into how to declare, construct and initialize in the upcoming chapters.', ''),
(573, 'Java Enums:', 'Enums were introduced in Java 5.0. Enums restrict a variable to have one of only a few predefined values. The values in this enumerated list are called enums.With the use of enums it is possible to reduce the number of bugs in your code. For example if we consider an application for a fresh juice shop it would be possible to restrict the glass size to small, medium and Large. This would make sure that it would not allow anyone to order any size other than the small, medium or large.', ''),
(574, 'Example:', '<b>Note:</b> enums can be declared as their own or inside a class. Methods, variables, constructors can be defined inside enums as well.', '<br><code><pre class="prettyprint notranslate"> class FreshJuice{     enum FreshJuiceSize{ SMALL, MEDIUM, LARGE }    FreshJuiceSize size; }  public class FreshJuiceTest{     public static void main(String args[]){       FreshJuice juice = new FreshJuice();       juice.size = FreshJuice. FreshJuiceSize.MEDIUM ;       System.out.println("Size :" + juice.size);    } } </pre></code><br>'),
(575, 'Java Keywords:', 'The following list shows the reserved words in Java. These reserved words may not be used as constant or variable or any other identifier names.', ''),
(576, 'Comments in Java', 'Java supports single line and multi-line comments very similar to c and c++. All characters available inside any comment are ignored by Java compiler.', '<br><code><pre class="prettyprint notranslate"> public class MyFirstJavaProgram{     /* This is my first java program.     * This will print Hello World as the output     * This is an example of multi-line comments.     */      public static void main(String []args){        // This is an example of single line comment        /* This is also an example of single line comment. */        System.out.println("Hello World");      } }  </pre></code><br>'),
(577, 'Data Types in Java', 'There are two data types available in Java: <li><p>Primitive Data Types</p></li> <li><p>Reference/Object Data Types</p></li> ', ''),
(578, 'Primitive Data Types:', 'There are eight primitive data types supported by Java. Primitive data types are predefined by the language and named by a key word. Let us now look into detail about the eight primitive data types. <li>byte</li> <li>short</li> <li>int</li> <li>long</li> <li>float</li> <li>double</li> <li>boolean</li> <li>char</li> ', ''),
(579, 'Reference Data Types:', ' <li><p>Reference variables are created using defined constructors of the classes. They are used to access objects. These variables are declared to be of a specific type that cannot be changed. For example, Employee, Puppy etc.</p></li>  <li><p>Class objects, and various type of array variables come under reference data type.</p></li> <li><p>Default value of any reference variable is null.</p></li>  <li><p>A reference variable can be used to refer to any object of the declared type or any compatible type.</p></li>  <li><p>Example : Animal animal = new Animal("giraffe");</p></li>  ', ''),
(580, 'Java Literals:', 'A literal is a source code representation of a fixed value. They are represented directly in the code without any computation.Literals can be assigned to any primitive type variable. For example:String literals in Java are specified like they are in most other languages by enclosing a sequence of characters between a pair of double quotes. Examples of string literals are:Java language supports few special escape sequences for String and char literals as well. They are:', '<br><code><pre class="prettyprint notranslate"> byte a = 68; char a = A </pre></code><br><br><code><pre class="prettyprint notranslate"> "Hello World" "two\nlines" ""This is in quotes"" </pre></code><br>'),
(581, 'Java Access Modifiers:', 'Java provides a number of access modifiers to set access levels for classes, variables, methods and constructors. The four access levels are: <li><p>Visible to the package. the default. No modifiers are needed.</p></li> <li><p>Visible to the class only (private).</p></li> <li><p>Visible to the world (public).</p></li> <li><p>Visible to the package and all subclasses (protected).</p></li> ', ''),
(582, 'Java Basic Operators:', 'Java provides a rich set of operators to manipulate variables. We can divide all the Java operators into the following groups:', ''),
(583, 'Misc Operators', 'There are few other operators supported by Java Language.', ''),
(584, 'Conditional Operator ( ? : ):', 'Conditional operator is also known as the ternary operator. This operator consists of three operands and is used to evaluate boolean expressions. The goal of the operator is to decide which value should be assigned to the variable. The operator is written as :', '<br><code><pre class="prettyprint notranslate"> variable x = (expression) ? value if true : value if false </pre></code><br>'),
(585, 'instanceOf Operator:', 'This operator is used only for object reference variables. The operator checks whether the object is of a particular type(class type or interface type).  instanceOf operator is wriiten as:', '<br><code><pre class="prettyprint notranslate"> ( Object reference variable ) instanceOf  (class/interface type) </pre></code><br>'),
(586, 'The while Loop:', 'A while loop is a control structure that allows you to repeat a task a certain number of times.', ''),
(587, 'Syntax:', 'The syntax of a while loop is:', '<br><code><pre class="prettyprint notranslate"> while(Boolean_expression) {    //Statements } </pre></code><br>'),
(588, 'The do...while Loop:', 'A do...while loop is similar to a while loop, except that a do...while loop is guaranteed to execute at least one time.', ''),
(589, 'Syntax:', 'The syntax of a do...while loop is:', '<br><code><pre class="prettyprint notranslate"> do {    //Statements }while(Boolean_expression); </pre></code><br>'),
(590, 'The for Loop:', 'A for loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times.A for loop is useful when you know how many times a task is to be repeated.', ''),
(591, 'Syntax:', 'The syntax of a for loop is:', '<br><code><pre class="prettyprint notranslate"> for(initialization; Boolean_expression; update) {    //Statements } </pre></code><br>'),
(592, 'Enhanced for loop in Java:', 'As of java 5 the enhanced for loop was introduced. This is mainly used for Arrays.', ''),
(593, 'Syntax:', 'The syntax of enhanced for loop is:', '<br><code><pre class="prettyprint notranslate"> for(declaration : expression) {    //Statements } </pre></code><br>'),
(594, 'The break Keyword:', 'The <i>break</i> keyword is used to stop the entire loop. The break keyword must be used inside any loop or a switch statement.The break keyword will stop the execution of the innermost loop and start executing the next line of code after the block.', ''),
(595, 'The continue Keyword:', 'The <i>continue</i> keyword can be used in any of the loop control structures. It causes the loop to immediately jump to the next iteration of the loop. <li><p>In a for loop, the continue keyword causes flow of control to immediately jump to the update statement.</p></li> <li><p>In a while loop or do/while loop, flow of control immediately jumps to the Boolean expression.</p></li> ', ''),
(596, 'Syntax:', 'The syntax of a continue is a single statement inside any loop:', '<br><code><pre class="prettyprint notranslate"> continue; </pre></code><br>'),
(597, 'The if Statement:', 'An if statement consists of a Boolean expression followed by one or more statements.', ''),
(598, 'Syntax:', 'The syntax of an if statement is:', '<br><code><pre class="prettyprint notranslate"> if(Boolean_expression) {    //Statements will execute if the Boolean expression is true } </pre></code><br>'),
(599, 'The if...else Statement:', 'An if statement can be followed by an optional <i>else</i> statement, which executes when the Boolean expression is false.', ''),
(600, 'Syntax:', 'The syntax of a if...else is:', '<br><code><pre class="prettyprint notranslate"> if(Boolean_expression){    //Executes when the Boolean expression is true }else{    //Executes when the Boolean expression is false } </pre></code><br>'),
(601, 'The if...else if...else Statement:', 'An if statement can be followed by an optional <i>else if...else</i> statement, which is very usefull to test various conditions using single if...else if statement.', ''),
(602, 'Syntax:', 'The syntax of a if...else is:', '<br><code><pre class="prettyprint notranslate"> if(Boolean_expression 1){    //Executes when the Boolean expression 1 is true }else if(Boolean_expression 2){    //Executes when the Boolean expression 2 is true }else if(Boolean_expression 3){    //Executes when the Boolean expression 3 is true }else {    //Executes when the one of the above condition is true. } </pre></code><br>'),
(603, 'Nested if...else Statement:', 'It is always legal to nest if-else statements. When using if , else if , else statements there are few points to keep in mind. <li><p>An if can have zero or one elses and it must come after any else ifs.</p></li> <li><p>An if can have zero to many else ifs and they must come before the else.</p></li> <li><p>Once an else if succeeds, none of he remaining else ifs or elses will be tested.</p></li> ', ''),
(604, 'Syntax:', 'The syntax for a nested if...else is as follows:', '<br><code><pre class="prettyprint notranslate"> if(Boolean_expression 1){    //Executes when the Boolean expression 1 is true    if(Boolean_expression 2){       //Executes when the Boolean expression 2 is true    } } </pre></code><br>'),
(605, 'The switch Statement:', 'A <i>switch</i> statement allows a variable to be tested for equality against a list of values. Each value is called a case, and the variable being switched on is checked for each case.', ''),
(606, 'Syntax:', 'The syntax of enhanced for loop is:', '<br><code><pre class="prettyprint notranslate"> switch(expression){     case value :        //Statements        break; //optional     case value :        //Statements        break; //optional     //You can have any number of case statements.     default : //Optional        //Statements } </pre></code><br>'),
(607, 'Java Methods:', 'A Java method is a collection of statements that are grouped together to perform an operation. When you call the System.out.println method, for example, the system actually executes several statements in order to display a message on the console.In general, a method has the following syntax:A method definition consists of a method header and a method body. Here are all the parts of a method: <li><p><b>Modifiers:</b> The modifier, which is optional, tells the compiler how to call the method. This defines the access type of the method.</p></li> <li><p><b>Return Type:</b> A method may return a value. The returnValueType is the data type of the value the method returns. Some methods perform the desired operations without returning a value. In this case, the returnValueType is the keyword <b>void</b>.</p></li> <li><p><b>Method Name:</b> This is the actual name of the method. The method name and the parameter list together constitute the method signature.</p></li> <li><p><b>Parameters:</b> A parameter is like a placeholder. When a method is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of the parameters of a method. Parameters are optional; that is, a method may contain no parameters.</p></li> <li><p><b>Method Body:</b> The method body contains a collection of statements that define what the method does.</p></li> ', '<br><code><pre class="prettyprint notranslate"> modifier returnValueType methodName(list of parameters) {   // Method body; } </pre></code><br>'),
(608, 'Java Classes &amp; Objects:', ' <li><p><b>Object -</b> Objects have states and behaviors. Example: A dog has states-color, name, breed as well as behaviors -wagging, barking, eating. An object is an instance of a class. </p></li> <li><p><b>Class -</b> A class can be defined as a template/ blue print that describe the behaviors/states that object of its type support.</p></li> A sample of a class is given below:A class can contain any of the following variable types. <li><p><b>Local variables . </b>variables defined inside methods, constructors or blocks are called local variables. The variable will be declared and initialized within the method and the variable will be destroyed when the method has completed.</p></li> <li><p><b>Instance variables . </b>Instance variables are variables within a class but outside any method. These variables are instantiated when the class is loaded. Instance variables can be accessed from inside any method, constructor or blocks of that particular class.</p></li> <li><p><b>Class variables . </b> Class variables are variables declared with in a class, outside any method, with the static keyword.</p></li> ', '<br><code><pre class="prettyprint notranslate"> public class Dog{    String breed;    int age;    String color;     void barking(){    }        void hungry(){    }        void sleeping(){    } } </pre></code><br>'),
(609, 'Exceptions Handling:', 'A method catches an exception using a combination of the <b>try</b> and <b>catch</b> keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following:', '<br><code><pre class="prettyprint notranslate"> try {    //Protected code }catch(ExceptionName e1) {    //Catch block } </pre></code><br>'),
(610, 'Multiple catch Blocks:', 'A try block can be followed by multiple catch blocks. The syntax for multiple catch blocks looks like the following:', '<br><code><pre class="prettyprint notranslate"> try {    //Protected code }catch(ExceptionType1 e1) {    //Catch block }catch(ExceptionType2 e2) {    //Catch block }catch(ExceptionType3 e3) {    //Catch block } </pre></code><br>'),
(611, 'The throws/throw Keywords:', 'If a method does not handle a checked exception, the method must declare it using the <b>throws</b> keyword. The throws keyword appears at the end of a methods signature.You can throw an exception, either a newly instantiated one or an exception that you just caught, by using the <b>throw</b> keyword. Try to understand the different in throws and throw keywords.', ''),
(612, 'Java - Useful Resources', 'The following resources contain additional information on Java. Please use them to get more in-depth knowledge on this topic.', ''),
(613, 'Useful Links on Java', ' <li><p><a target="_blank" rel="nofollow" href="http://java.sun.com/docs/books/tutorial/index.html">The Java<sup><font size="-2">TM</font></sup> Tutorials</a> &minus; The Java Tutorials are practical guides for programmers who want to use the Java programming language to create applications.</p></li> <li><p><a target="_blank" rel="nofollow" href="http://java.sun.com/j2se/1.4.2/docs/index.html">Java<sup><font size="-2">TM</font></sup> 2 SDK, Standard Edition </a> &minus; Official site for Java<sup><font size="-2">TM</font></sup> 2 SDK, Standard Edition </p></li> <li><p><a target="_blank" rel="nofollow" href="http://www.java.com/en/download/index.jsp">Free Java Download</a> &minus; Download Java for your desktop computer now!</p></li> <li><p><a target="_blank" rel="nofollow" href="http://java.sun.com/reference/docs/">Sun Developer Network</a> &minus; Sun Microsystems official website listing down all the API documentation, latest Java Technologies, Books and other resource.</p></li> ', ''),
(614, 'Java - Overview', 'Java programming language was originally developed by Sun Microsystems which was initiated by James Gosling and released in 1995 as core component of Sun Microsystems Java platform (Java 1.0 [J2SE]).The latest release of the Java Standard Edition is Java SE 8. With the advancement of Java and its widespread popularity, multiple configurations were built to suite various types of platforms. Ex: J2EE for Enterprise Applications, J2ME for Mobile Applications.The new J2 versions were renamed as Java SE, Java EE and Java ME respectively. Java is guaranteed to be <b>Write Once, Run Anywhere.</b>Java is: <li><p><b>Object Oriented:</b> In Java, everything is an Object. Java can be easily extended since it is based on the Object model.</p></li> <li><p><b>Platform independent:</b> Unlike many other programming languages including C and C++, when Java is compiled, it is not compiled into platform specific machine, rather into platform independent byte code. This byte code is distributed over the web and interpreted by virtual Machine (JVM) on whichever platform it is being run.</p></li> <li><p><b>Simple:</b> Java is designed to be easy to learn. If you understand the basic concept of OOP Java would be easy to master.</p></li> <li><p><b>Secure:</b> With Javas secure feature it enables to develop virus-free, tamper-free systems. Authentication techniques are based on public-key encryption.</p></li> <li><p><b>Architectural-neutral: </b>Java compiler generates an architecture-neutral object file format which makes the compiled code to be executable on many processors, with the presence of Java runtime system.</p></li> <li><p><b>Portable:</b> Being architectural-neutral and having no implementation dependent aspects of the specification makes Java portable. Compiler in Java is written in ANSI C with a clean portability boundary which is a POSIX subset.</p></li> <li><p><b>Robust:</b> Java makes an effort to eliminate error prone situations by emphasizing mainly on compile time error checking and runtime checking.</p></li> <li><p><b>Multithreaded:</b> With Javas multithreaded feature it is possible to write programs that can do many tasks simultaneously. This design feature allows developers to construct smoothly running interactive applications.</p></li> <li><p><b>Interpreted:</b> Java byte code is translated on the fly to native machine instructions and is not stored anywhere. The development process is more rapid and analytical since the linking is an incremental and light weight process. </p></li> <li><p><b>High Performance:</b> With the use of Just-In-Time compilers, Java enables high performance.</p></li> <li><p><b>Distributed:</b> Java is designed for the distributed environment of the internet.</p></li> <li><p><b>Dynamic:</b> Java is considered to be more dynamic than C or C++ since it is designed to adapt to an evolving environment. Java programs can carry extensive amount of run-time information that can be used to verify and resolve accesses to objects on run-time.</p></li> ', ''),
(615, 'History of Java:', 'James Gosling initiated the Java language project in June 1991 for use in one of his many set-top box projects. The language, initially called Oak after an oak tree that stood outside Goslings office, also went by the name Green and ended up later being renamed as Java, from a list of random words.Sun released the first public implementation as Java 1.0 in 1995. It promised <b>Write Once, Run Anywhere</b>(WORA), providing no-cost run-times on popular platforms. On 13 November 2006, Sun released much of Java as free and open source software under the terms of the GNU General Public License (GPL).On 8 May 2007, Sun finished the process, making all of Javas core code free and open-source, aside from a small portion of code to which Sun did not hold the copyright.', ''),
(616, 'Tools you will need:', 'For performing the examples discussed in this tutorial, you will need a Pentium 200-MHz computer with a minimum of 64 MB of RAM (128 MB of RAM recommended).You also will need the following softwares: <li><p>Linux 7.1 or Windows xp/7/8 operating system.</p></li> <li><p>Java JDK 8 </p></li> <li><p>Microsoft Notepad or any other text editor</p></li> This tutorial will provide the necessary skills to create GUI, networking, and Web applications using Java.', ''),
(617, 'Try It Option:', 'We have provided you an option to compile and execute available code online. Just click on <b>Try it</b> button avaiable at top-right corner of the code window to compile and execute available code. There are certain examples which can not be executed online, so we have skipped those examples.There may be a case that you do not see the result of the compiled/executed code, in such case you can re-try to compile and execute the code using <b>execute</b> button available in compliation pop-up window.', '<br><code><pre class="prettyprint notranslate tryit"> public class MyFirstJavaProgram {      public static void main(String []args) {        System.out.println("Hello World");     } }  </pre></code><br>');

-- --------------------------------------------------------

--
-- Table structure for table `userinfo`
--

CREATE TABLE `userinfo` (
  `uid` int(100) NOT NULL,
  `username` varchar(100) NOT NULL,
  `password` varchar(100) DEFAULT NULL,
  `level` int(5) NOT NULL,
  `prequiz` int(2) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `userinfo`
--

INSERT INTO `userinfo` (`uid`, `username`, `password`, `level`, `prequiz`) VALUES
(0, 'JohnSmith', 'qwer', 1, 1),
(1, 'JerryPrice', 'qwer', 0, 1),
(2, 'JeffreyKelly', 'qwer', 0, 1),
(5, 'AltonSoto', 'qwer', 2, 1),
(7, 'AlexGomez', 'qwer', 2, 1),
(9, 'KatiePena', 'qwer', 2, 1),
(12, 'TaraHolmes', 'qwer', 2, 1),
(15, 'AdaNorton', 'qwer', 2, 1),
(19, 'TinaJones', 'qwer', 0, 1),
(22, 'MattTodd', 'qwer', 2, 1),
(23, 'WilliamHill', 'qwer', 1, 1),
(24, 'BonnieRoberts', 'qwer', 0, 1),
(30, 'CodyRoss', 'qwer', 1, 1),
(32, 'AdaWise', 'qwer', 1, 1),
(33, 'RachelShaw', 'qwer', 0, 1),
(34, 'ElmerBrady', 'qwer', 0, 1),
(36, 'SalShah', 'qwer', 2, 1),
(39, 'KashBhansali', 'qwer', 1, 1),
(40, 'AmiVashi', 'qwer', 1, 1),
(44, 'BKanoongo', 'qwer', 1, 1),
(45, 'NikitShah', 'qwer', 0, 1),
(55, 'SallyJames', 'qwer', 0, 1),
(56, 'LunaLovegood', 'qwer', 2, 1),
(65, 'VirtiShah', 'qwer', 1, 1),
(67, 'NikiTrivedi', 'qwer', 1, 1),
(77, 'AdityaTogani', 'qwer', 1, 1),
(78, 'SagarShah', 'qwer', 2, 1),
(79, 'AkashC', 'qwer', 1, 1),
(80, 'RobertPat', 'qwer', 0, 1),
(82, 'ManaT', 'qwer', 2, 1),
(89, 'DilipSanghvi', 'qwer', 2, 1),
(90, 'AdamMetel', 'qwer', 1, 1),
(100, 'ChiragShah', 'qwer', 1, 1),
(101, 'lilyPotter', '', 0, 1),
(103, 'StephenColbert', 'qwer', 1, 1),
(202, 'harryPotter', 'qwer', 1, 1),
(234, 'JamesFallon', 'qwer', 2, 1),
(255, 'EllenDegen', 'qwer', 1, 1),
(389, 'kkb', 'kkb', 0, 1),
(456, 'SophiaBush', 'qwer', 1, 1);

--
-- Indexes for dumped tables
--

--
-- Indexes for table `cheatsheet`
--
ALTER TABLE `cheatsheet`
  ADD PRIMARY KEY (`cheatid`);

--
-- Indexes for table `notes`
--
ALTER TABLE `notes`
  ADD PRIMARY KEY (`notesid`);

--
-- Indexes for table `notesman`
--
ALTER TABLE `notesman`
  ADD PRIMARY KEY (`notesid`);

--
-- Indexes for table `notessal`
--
ALTER TABLE `notessal`
  ADD PRIMARY KEY (`notesid`);

--
-- Indexes for table `text`
--
ALTER TABLE `text`
  ADD PRIMARY KEY (`textid`);

--
-- Indexes for table `textbook`
--
ALTER TABLE `textbook`
  ADD PRIMARY KEY (`textid`);

--
-- Indexes for table `userinfo`
--
ALTER TABLE `userinfo`
  ADD UNIQUE KEY `UID` (`uid`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `cheatsheet`
--
ALTER TABLE `cheatsheet`
  MODIFY `cheatid` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=146;
--
-- AUTO_INCREMENT for table `notes`
--
ALTER TABLE `notes`
  MODIFY `notesid` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=237;
--
-- AUTO_INCREMENT for table `notesman`
--
ALTER TABLE `notesman`
  MODIFY `notesid` int(11) NOT NULL AUTO_INCREMENT;
--
-- AUTO_INCREMENT for table `notessal`
--
ALTER TABLE `notessal`
  MODIFY `notesid` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=369;
--
-- AUTO_INCREMENT for table `text`
--
ALTER TABLE `text`
  MODIFY `textid` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=341;
--
-- AUTO_INCREMENT for table `textbook`
--
ALTER TABLE `textbook`
  MODIFY `textid` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=618;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
